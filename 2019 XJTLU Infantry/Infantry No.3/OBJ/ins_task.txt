; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\ins_task.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\ins_task.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\ins_task.crf ..\AHRS\INS_task.c]
                          THUMB

                          AREA ||i.IMU_Cali_Slove||, CODE, READONLY, ALIGN=2

                  IMU_Cali_Slove PROC
;;;204    
;;;205    static void IMU_Cali_Slove(fp32 gyro[3], fp32 accel[3], fp32 mag[3], mpu6500_real_data_t *mpu6500, ist8310_real_data_t *ist8310)
000000  b5f0              PUSH     {r4-r7,lr}
;;;206    {
000002  4605              MOV      r5,r0
000004  9c05              LDR      r4,[sp,#0x14]
;;;207        for (uint8_t i = 0; i < 3; i++)
000006  2000              MOVS     r0,#0
000008  e07f              B        |L1.266|
                  |L1.10|
;;;208        {
;;;209            gyro[i] = mpu6500->gyro[0] * Gyro_Scale_Factor[i][0] + mpu6500->gyro[1] * Gyro_Scale_Factor[i][1] + mpu6500->gyro[2] * Gyro_Scale_Factor[i][2] + Gyro_Offset[i];
00000a  ed930a05          VLDR     s0,[r3,#0x14]
00000e  eb000640          ADD      r6,r0,r0,LSL #1
000012  4f40              LDR      r7,|L1.276|
000014  eb070686          ADD      r6,r7,r6,LSL #2
000018  edd60a00          VLDR     s1,[r6,#0]
00001c  ee200a20          VMUL.F32 s0,s0,s1
000020  edd30a06          VLDR     s1,[r3,#0x18]
000024  eb000640          ADD      r6,r0,r0,LSL #1
000028  eb070686          ADD      r6,r7,r6,LSL #2
00002c  ed961a01          VLDR     s2,[r6,#4]
000030  ee000a81          VMLA.F32 s0,s1,s2
000034  edd30a07          VLDR     s1,[r3,#0x1c]
000038  eb000640          ADD      r6,r0,r0,LSL #1
00003c  eb070686          ADD      r6,r7,r6,LSL #2
000040  ed961a02          VLDR     s2,[r6,#8]
000044  ee000a81          VMLA.F32 s0,s1,s2
000048  4e33              LDR      r6,|L1.280|
00004a  eb060680          ADD      r6,r6,r0,LSL #2
00004e  edd60a00          VLDR     s1,[r6,#0]
000052  ee300a20          VADD.F32 s0,s0,s1
000056  eb050680          ADD      r6,r5,r0,LSL #2
00005a  ed860a00          VSTR     s0,[r6,#0]
;;;210            accel[i] = mpu6500->accel[0] * Accel_Scale_Factor[i][0] + mpu6500->accel[1] * Accel_Scale_Factor[i][1] + mpu6500->accel[2] * Accel_Scale_Factor[i][2] + Accel_Offset[i];
00005e  ed930a01          VLDR     s0,[r3,#4]
000062  eb000640          ADD      r6,r0,r0,LSL #1
000066  4f2d              LDR      r7,|L1.284|
000068  eb070686          ADD      r6,r7,r6,LSL #2
00006c  edd60a00          VLDR     s1,[r6,#0]
000070  ee200a20          VMUL.F32 s0,s0,s1
000074  edd30a02          VLDR     s1,[r3,#8]
000078  eb000640          ADD      r6,r0,r0,LSL #1
00007c  eb070686          ADD      r6,r7,r6,LSL #2
000080  ed961a01          VLDR     s2,[r6,#4]
000084  ee000a81          VMLA.F32 s0,s1,s2
000088  edd30a03          VLDR     s1,[r3,#0xc]
00008c  eb000640          ADD      r6,r0,r0,LSL #1
000090  eb070686          ADD      r6,r7,r6,LSL #2
000094  ed961a02          VLDR     s2,[r6,#8]
000098  ee000a81          VMLA.F32 s0,s1,s2
00009c  4e20              LDR      r6,|L1.288|
00009e  eb060680          ADD      r6,r6,r0,LSL #2
0000a2  edd60a00          VLDR     s1,[r6,#0]
0000a6  ee300a20          VADD.F32 s0,s0,s1
0000aa  eb010680          ADD      r6,r1,r0,LSL #2
0000ae  ed860a00          VSTR     s0,[r6,#0]
;;;211            mag[i] = ist8310->mag[0] * Mag_Scale_Factor[i][0] + ist8310->mag[1] * Mag_Scale_Factor[i][1] + ist8310->mag[2] * Mag_Scale_Factor[i][2] + Mag_Offset[i];
0000b2  ed940a01          VLDR     s0,[r4,#4]
0000b6  eb000640          ADD      r6,r0,r0,LSL #1
0000ba  4f1a              LDR      r7,|L1.292|
0000bc  eb070686          ADD      r6,r7,r6,LSL #2
0000c0  edd60a00          VLDR     s1,[r6,#0]
0000c4  ee200a20          VMUL.F32 s0,s0,s1
0000c8  edd40a02          VLDR     s1,[r4,#8]
0000cc  eb000640          ADD      r6,r0,r0,LSL #1
0000d0  eb070686          ADD      r6,r7,r6,LSL #2
0000d4  ed961a01          VLDR     s2,[r6,#4]
0000d8  ee000a81          VMLA.F32 s0,s1,s2
0000dc  edd40a03          VLDR     s1,[r4,#0xc]
0000e0  eb000640          ADD      r6,r0,r0,LSL #1
0000e4  eb070686          ADD      r6,r7,r6,LSL #2
0000e8  ed961a02          VLDR     s2,[r6,#8]
0000ec  ee000a81          VMLA.F32 s0,s1,s2
0000f0  4e0d              LDR      r6,|L1.296|
0000f2  eb060680          ADD      r6,r6,r0,LSL #2
0000f6  edd60a00          VLDR     s1,[r6,#0]
0000fa  ee300a20          VADD.F32 s0,s0,s1
0000fe  eb020680          ADD      r6,r2,r0,LSL #2
000102  ed860a00          VSTR     s0,[r6,#0]
000106  1c46              ADDS     r6,r0,#1              ;207
000108  b2f0              UXTB     r0,r6                 ;207
                  |L1.266|
00010a  2803              CMP      r0,#3                 ;207
00010c  f6ffaf7d          BLT      |L1.10|
;;;212        }
;;;213    }
000110  bdf0              POP      {r4-r7,pc}
;;;214    
                          ENDP

000112  0000              DCW      0x0000
                  |L1.276|
                          DCD      Gyro_Scale_Factor
                  |L1.280|
                          DCD      Gyro_Offset
                  |L1.284|
                          DCD      Accel_Scale_Factor
                  |L1.288|
                          DCD      Accel_Offset
                  |L1.292|
                          DCD      Mag_Scale_Factor
                  |L1.296|
                          DCD      Mag_Offset

                          AREA ||i.IMU_temp_Control||, CODE, READONLY, ALIGN=2

                  IMU_temp_Control PROC
;;;241    
;;;242    static void IMU_temp_Control(fp32 temp)
000000  b510              PUSH     {r4,lr}
;;;243    {
000002  ed2d8b02          VPUSH    {d8}
000006  eeb08a40          VMOV.F32 s16,s0
;;;244        uint16_t tempPWM;
;;;245        static uint8_t temp_constant_time = 0 ;
;;;246        if (first_temperate)
00000a  4824              LDR      r0,|L2.156|
00000c  7800              LDRB     r0,[r0,#0]  ; first_temperate
00000e  b320              CBZ      r0,|L2.90|
;;;247        {
;;;248    		out_incr[TEMP] = pid_incr_calc(&pid_incr[TEMP], temp, temperature.temp_set);
000010  4823              LDR      r0,|L2.160|
000012  ed900a00          VLDR     s0,[r0,#0]
000016  eef00a40          VMOV.F32 s1,s0
00001a  eeb00a48          VMOV.F32 s0,s16
00001e  4821              LDR      r0,|L2.164|
000020  f7fffffe          BL       pid_incr_calc
000024  4820              LDR      r0,|L2.168|
000026  ed800a05          VSTR     s0,[r0,#0x14]
;;;249            if (out_incr[TEMP] < 0.0f)
00002a  ed900a05          VLDR     s0,[r0,#0x14]
00002e  eeb50ac0          VCMPE.F32 s0,#0.0
000032  eef1fa10          VMRS     APSR_nzcv,FPSCR
000036  d203              BCS      |L2.64|
;;;250            {
;;;251                out_incr[TEMP] = 0.0f;
000038  ed9f0a1c          VLDR     s0,|L2.172|
00003c  ed800a05          VSTR     s0,[r0,#0x14]
                  |L2.64|
;;;252            }
;;;253            tempPWM = (uint16_t)out_incr[TEMP];
000040  4819              LDR      r0,|L2.168|
000042  ed900a05          VLDR     s0,[r0,#0x14]
000046  eebc0ac0          VCVT.U32.F32 s0,s0
00004a  ee100a10          VMOV     r0,s0
00004e  b284              UXTH     r4,r0
;;;254            IMUTempPWM(tempPWM);
000050  4621              MOV      r1,r4
000052  4817              LDR      r0,|L2.176|
000054  f7fffffe          BL       TIM_SetCompare2
000058  e01d              B        |L2.150|
                  |L2.90|
;;;255        }
;;;256        else
;;;257        {
;;;258            //在没有达到设置的温度，一直最大功率加热
;;;259            if (temp > temperature.temp_set)
00005a  4811              LDR      r0,|L2.160|
00005c  ed900a00          VLDR     s0,[r0,#0]
000060  eeb40ac8          VCMPE.F32 s0,s16
000064  eef1fa10          VMRS     APSR_nzcv,FPSCR
000068  d210              BCS      |L2.140|
;;;260            {
;;;261                temp_constant_time ++;
00006a  4812              LDR      r0,|L2.180|
00006c  7800              LDRB     r0,[r0,#0]  ; temp_constant_time
00006e  1c40              ADDS     r0,r0,#1
000070  4910              LDR      r1,|L2.180|
000072  7008              STRB     r0,[r1,#0]
;;;262                if(temp_constant_time > 10)
000074  4608              MOV      r0,r1
000076  7800              LDRB     r0,[r0,#0]  ; temp_constant_time
000078  280a              CMP      r0,#0xa
00007a  dd07              BLE      |L2.140|
;;;263                {
;;;264                    //达到设置温度，将积分项设置为一半最大功率，加速收敛
;;;265                    first_temperate = 1;
00007c  2001              MOVS     r0,#1
00007e  4907              LDR      r1,|L2.156|
000080  7008              STRB     r0,[r1,#0]
;;;266    				pid[TEMP].iout = MPU6500_TEMP_PWM_MAX / 12.0f;
000082  ed9f0a0d          VLDR     s0,|L2.184|
000086  480d              LDR      r0,|L2.188|
000088  ed800a63          VSTR     s0,[r0,#0x18c]
                  |L2.140|
;;;267    
;;;268                }
;;;269            }
;;;270    
;;;271            IMUTempPWM(MPU6500_TEMP_PWM_MAX - 1);
00008c  f2413187          MOV      r1,#0x1387
000090  4807              LDR      r0,|L2.176|
000092  f7fffffe          BL       TIM_SetCompare2
                  |L2.150|
;;;272        }
;;;273    //		static uint8_t temp_constant_time = 0 ;
;;;274    //		out[TEMP] = Calculate_Current_Value(&pid[TEMP], temperature.temp_set, temp);	
;;;275    //		TIM3->CCR2 = out[TEMP];
;;;276    //		if (temp > temperature.temp_set)
;;;277    //		{
;;;278    //				temp_constant_time++;
;;;279    //				if(temp_constant_time > 200)
;;;280    //				{
;;;281    //					first_temperate = 1;
;;;282    //				}
;;;283    //		}
;;;284    }
000096  ecbd8b02          VPOP     {d8}
00009a  bd10              POP      {r4,pc}
;;;285    
                          ENDP

                  |L2.156|
                          DCD      first_temperate
                  |L2.160|
                          DCD      temperature
                  |L2.164|
                          DCD      pid_incr+0x154
                  |L2.168|
                          DCD      out_incr
                  |L2.172|
0000ac  00000000          DCFS     0x00000000 ; 0
                  |L2.176|
                          DCD      0x40000400
                  |L2.180|
                          DCD      temp_constant_time
                  |L2.184|
0000b8  43d05555          DCFS     0x43d05555 ; 416.66665649414062
                  |L2.188|
                          DCD      pid

                          AREA ||i.INSTask||, CODE, READONLY, ALIGN=2

                  INSTask PROC
;;;47     
;;;48     void INSTask()
000000  b508              PUSH     {r3,lr}
;;;49     {
;;;50     				
;;;51             //将读取到的mpu6500原始数据处理成国际单位的数据
;;;52             mpu6500_read_over((mpu6500_spi_rxbuf + MPU6500_RX_BUF_DATA_OFFSET), &mpu6500_real_data);
000002  4982              LDR      r1,|L3.524|
000004  4882              LDR      r0,|L3.528|
000006  f7fffffe          BL       mpu6500_read_over
;;;53     //				ist8310_read_over((mpu6500_spi_rxbuf + IST8310_RX_BUF_DATA_OFFSET), &ist8310_real_data);
;;;54             //减去零漂以及旋转坐标系
;;;55             IMU_Cali_Slove(INS_gyro, INS_accel, INS_mag, &mpu6500_real_data, &ist8310_real_data);
00000a  4882              LDR      r0,|L3.532|
00000c  4b7f              LDR      r3,|L3.524|
00000e  4a82              LDR      r2,|L3.536|
000010  4982              LDR      r1,|L3.540|
000012  9000              STR      r0,[sp,#0]
000014  4882              LDR      r0,|L3.544|
000016  f7fffffe          BL       IMU_Cali_Slove
;;;56     
;;;57     
;;;58             //加速度计低通滤波
;;;59             static fp32 accel_fliter_1[3] = {0.0f, 0.0f, 0.0f};
;;;60             static fp32 accel_fliter_2[3] = {0.0f, 0.0f, 0.0f};
;;;61             static fp32 accel_fliter_3[3] = {0.0f, 0.0f, 0.0f};
;;;62             static const fp32 fliter_num[3] = {1.929454039488895f, -0.93178349823448126f, 0.002329458745586203f};
;;;63     
;;;64     
;;;65             //判断是否第一次进入，如果第一次则初始化四元数，之后更新四元数计算角度单位rad
;;;66             static uint8_t updata_count = 0;
;;;67     
;;;68             if( mpu6500_real_data.status & 1 << MPU_DATA_READY_BIT)
00001a  487c              LDR      r0,|L3.524|
00001c  7800              LDRB     r0,[r0,#0]  ; mpu6500_real_data
00001e  f0000001          AND      r0,r0,#1
000022  2800              CMP      r0,#0
000024  d045              BEQ      |L3.178|
;;;69             {
;;;70     
;;;71                 if (updata_count == 0)
000026  487f              LDR      r0,|L3.548|
000028  7800              LDRB     r0,[r0,#0]  ; updata_count
00002a  bbe8              CBNZ     r0,|L3.168|
;;;72                 {
;;;73                     MPU6500_TEMPERATURE_PWM_INIT();
00002c  2101              MOVS     r1,#1
00002e  f2413088          MOV      r0,#0x1388
000032  f7fffffe          BL       TIM3_Init
;;;74     				pid_incr_init(&pid_incr[TEMP], PID_INCR_TEMP, 4999.0f, 4400.0f);
000036  eddf0a7c          VLDR     s1,|L3.552|
00003a  ed9f0a7c          VLDR     s0,|L3.556|
00003e  497c              LDR      r1,|L3.560|
000040  487c              LDR      r0,|L3.564|
000042  f7fffffe          BL       pid_incr_init
;;;75                     //初始化四元数		
;;;76                     AHRS_init(INS_quat, INS_accel, INS_mag);
000046  4a74              LDR      r2,|L3.536|
000048  4974              LDR      r1,|L3.540|
00004a  487b              LDR      r0,|L3.568|
00004c  f7fffffe          BL       AHRS_init
;;;77                     get_angle(INS_quat, INS_Angle, INS_Angle + 1, INS_Angle + 2);
000050  4b7a              LDR      r3,|L3.572|
000052  1f1a              SUBS     r2,r3,#4
000054  1f11              SUBS     r1,r2,#4
000056  4878              LDR      r0,|L3.568|
000058  f7fffffe          BL       get_angle
;;;78     
;;;79                     accel_fliter_1[0] = accel_fliter_2[0] = accel_fliter_3[0] = INS_accel[0];
00005c  486f              LDR      r0,|L3.540|
00005e  ed900a00          VLDR     s0,[r0,#0]
000062  4877              LDR      r0,|L3.576|
000064  ed800a00          VSTR     s0,[r0,#0]
000068  4876              LDR      r0,|L3.580|
00006a  ed800a00          VSTR     s0,[r0,#0]
00006e  4876              LDR      r0,|L3.584|
000070  ed800a00          VSTR     s0,[r0,#0]
;;;80                     accel_fliter_1[1] = accel_fliter_2[1] = accel_fliter_3[1] = INS_accel[1];
000074  4869              LDR      r0,|L3.540|
000076  ed900a01          VLDR     s0,[r0,#4]
00007a  4871              LDR      r0,|L3.576|
00007c  ed800a01          VSTR     s0,[r0,#4]
000080  4870              LDR      r0,|L3.580|
000082  ed800a01          VSTR     s0,[r0,#4]
000086  4870              LDR      r0,|L3.584|
000088  ed800a01          VSTR     s0,[r0,#4]
;;;81                     accel_fliter_1[2] = accel_fliter_2[2] = accel_fliter_3[2] = INS_accel[2];
00008c  4863              LDR      r0,|L3.540|
00008e  ed900a02          VLDR     s0,[r0,#8]
000092  486b              LDR      r0,|L3.576|
000094  ed800a02          VSTR     s0,[r0,#8]
000098  486a              LDR      r0,|L3.580|
00009a  ed800a02          VSTR     s0,[r0,#8]
00009e  486a              LDR      r0,|L3.584|
0000a0  ed800a02          VSTR     s0,[r0,#8]
;;;82                     updata_count++;
0000a4  485f              LDR      r0,|L3.548|
0000a6  e000              B        |L3.170|
                  |L3.168|
0000a8  e004              B        |L3.180|
                  |L3.170|
0000aa  7800              LDRB     r0,[r0,#0]  ; updata_count
0000ac  1c40              ADDS     r0,r0,#1
0000ae  495d              LDR      r1,|L3.548|
0000b0  7008              STRB     r0,[r1,#0]
                  |L3.178|
0000b2  e0a3              B        |L3.508|
                  |L3.180|
;;;83                 }
;;;84                 else
;;;85                 {
;;;86                     //加速度计低通滤波
;;;87                     accel_fliter_1[0] = accel_fliter_2[0];
0000b4  4863              LDR      r0,|L3.580|
0000b6  ed900a00          VLDR     s0,[r0,#0]
0000ba  4863              LDR      r0,|L3.584|
0000bc  ed800a00          VSTR     s0,[r0,#0]
;;;88                     accel_fliter_2[0] = accel_fliter_3[0];
0000c0  485f              LDR      r0,|L3.576|
0000c2  ed900a00          VLDR     s0,[r0,#0]
0000c6  485f              LDR      r0,|L3.580|
0000c8  ed800a00          VSTR     s0,[r0,#0]
;;;89     
;;;90                     accel_fliter_3[0] = accel_fliter_2[0] * fliter_num[0] + accel_fliter_1[0] * fliter_num[1] + INS_accel[0] * fliter_num[2];
0000cc  ed900a00          VLDR     s0,[r0,#0]
0000d0  485e              LDR      r0,|L3.588|
0000d2  edd00a00          VLDR     s1,[r0,#0]
0000d6  ee200a20          VMUL.F32 s0,s0,s1
0000da  485b              LDR      r0,|L3.584|
0000dc  edd00a00          VLDR     s1,[r0,#0]
0000e0  485a              LDR      r0,|L3.588|
0000e2  ed901a01          VLDR     s2,[r0,#4]
0000e6  ee000a81          VMLA.F32 s0,s1,s2
0000ea  484c              LDR      r0,|L3.540|
0000ec  edd00a00          VLDR     s1,[r0,#0]
0000f0  4856              LDR      r0,|L3.588|
0000f2  ed901a02          VLDR     s2,[r0,#8]
0000f6  ee000a81          VMLA.F32 s0,s1,s2
0000fa  4851              LDR      r0,|L3.576|
0000fc  ed800a00          VSTR     s0,[r0,#0]
;;;91     
;;;92                     accel_fliter_1[1] = accel_fliter_2[1];
000100  4850              LDR      r0,|L3.580|
000102  ed900a01          VLDR     s0,[r0,#4]
000106  4850              LDR      r0,|L3.584|
000108  ed800a01          VSTR     s0,[r0,#4]
;;;93                     accel_fliter_2[1] = accel_fliter_3[1];
00010c  484c              LDR      r0,|L3.576|
00010e  ed900a01          VLDR     s0,[r0,#4]
000112  484c              LDR      r0,|L3.580|
000114  ed800a01          VSTR     s0,[r0,#4]
;;;94     
;;;95                     accel_fliter_3[1] = accel_fliter_2[1] * fliter_num[0] + accel_fliter_1[1] * fliter_num[1] + INS_accel[1] * fliter_num[2];
000118  ed900a01          VLDR     s0,[r0,#4]
00011c  484b              LDR      r0,|L3.588|
00011e  edd00a00          VLDR     s1,[r0,#0]
000122  ee200a20          VMUL.F32 s0,s0,s1
000126  4848              LDR      r0,|L3.584|
000128  edd00a01          VLDR     s1,[r0,#4]
00012c  4847              LDR      r0,|L3.588|
00012e  ed901a01          VLDR     s2,[r0,#4]
000132  ee000a81          VMLA.F32 s0,s1,s2
000136  4839              LDR      r0,|L3.540|
000138  edd00a01          VLDR     s1,[r0,#4]
00013c  4843              LDR      r0,|L3.588|
00013e  ed901a02          VLDR     s2,[r0,#8]
000142  ee000a81          VMLA.F32 s0,s1,s2
000146  483e              LDR      r0,|L3.576|
000148  ed800a01          VSTR     s0,[r0,#4]
;;;96     
;;;97                     accel_fliter_1[2] = accel_fliter_2[2];
00014c  483d              LDR      r0,|L3.580|
00014e  ed900a02          VLDR     s0,[r0,#8]
000152  483d              LDR      r0,|L3.584|
000154  ed800a02          VSTR     s0,[r0,#8]
;;;98                     accel_fliter_2[2] = accel_fliter_3[2];
000158  4839              LDR      r0,|L3.576|
00015a  ed900a02          VLDR     s0,[r0,#8]
00015e  4839              LDR      r0,|L3.580|
000160  ed800a02          VSTR     s0,[r0,#8]
;;;99     
;;;100                    accel_fliter_3[2] = accel_fliter_2[2] * fliter_num[0] + accel_fliter_1[2] * fliter_num[1] + INS_accel[2] * fliter_num[2];
000164  ed900a02          VLDR     s0,[r0,#8]
000168  4838              LDR      r0,|L3.588|
00016a  edd00a00          VLDR     s1,[r0,#0]
00016e  ee200a20          VMUL.F32 s0,s0,s1
000172  4835              LDR      r0,|L3.584|
000174  edd00a02          VLDR     s1,[r0,#8]
000178  4834              LDR      r0,|L3.588|
00017a  ed901a01          VLDR     s2,[r0,#4]
00017e  ee000a81          VMLA.F32 s0,s1,s2
000182  4826              LDR      r0,|L3.540|
000184  edd00a02          VLDR     s1,[r0,#8]
000188  4830              LDR      r0,|L3.588|
00018a  ed901a02          VLDR     s2,[r0,#8]
00018e  ee000a81          VMLA.F32 s0,s1,s2
000192  482b              LDR      r0,|L3.576|
000194  ed800a02          VSTR     s0,[r0,#8]
;;;101    
;;;102    							
;;;103                    //更新四元数
;;;104                    AHRS_update(INS_quat, TimingTime, INS_gyro, accel_fliter_3, INS_mag);
000198  4b1f              LDR      r3,|L3.536|
00019a  4602              MOV      r2,r0
00019c  4920              LDR      r1,|L3.544|
00019e  ed9f0a2c          VLDR     s0,|L3.592|
0001a2  4825              LDR      r0,|L3.568|
0001a4  f7fffffe          BL       AHRS_update
;;;105                    get_angle(INS_quat, INS_Angle, INS_Angle + 1, INS_Angle + 2);
0001a8  4b24              LDR      r3,|L3.572|
0001aa  1f1a              SUBS     r2,r3,#4
0001ac  1f11              SUBS     r1,r2,#4
0001ae  4822              LDR      r0,|L3.568|
0001b0  f7fffffe          BL       get_angle
;;;106    
;;;107                    //陀螺仪开机校准
;;;108    //								if(bsp_flag)
;;;109                    {
;;;110                        static uint16_t start_gyro_cali_time = 0;
;;;111                        if(start_gyro_cali_time == 0)
0001b4  4827              LDR      r0,|L3.596|
0001b6  8800              LDRH     r0,[r0,#0]  ; start_gyro_cali_time
0001b8  b9c0              CBNZ     r0,|L3.492|
;;;112                        {		
;;;113    						led_red_on();
0001ba  f7fffffe          BL       led_red_on
;;;114                            Gyro_Offset[0] = gyro_cali_offset[0];
0001be  4826              LDR      r0,|L3.600|
0001c0  ed900a00          VLDR     s0,[r0,#0]
0001c4  4825              LDR      r0,|L3.604|
0001c6  ed800a00          VSTR     s0,[r0,#0]
;;;115                            Gyro_Offset[1] = gyro_cali_offset[1];
0001ca  4823              LDR      r0,|L3.600|
0001cc  ed900a01          VLDR     s0,[r0,#4]
0001d0  4822              LDR      r0,|L3.604|
0001d2  ed800a01          VSTR     s0,[r0,#4]
;;;116                            Gyro_Offset[2] = gyro_cali_offset[2];
0001d6  4820              LDR      r0,|L3.600|
0001d8  ed900a02          VLDR     s0,[r0,#8]
0001dc  481f              LDR      r0,|L3.604|
0001de  ed800a02          VSTR     s0,[r0,#8]
;;;117                            start_gyro_cali_time++;
0001e2  481c              LDR      r0,|L3.596|
0001e4  8800              LDRH     r0,[r0,#0]  ; start_gyro_cali_time
0001e6  1c40              ADDS     r0,r0,#1
0001e8  491a              LDR      r1,|L3.596|
0001ea  8008              STRH     r0,[r1,#0]
                  |L3.492|
;;;118                        }
;;;119    					if(first_temperate)
0001ec  481c              LDR      r0,|L3.608|
0001ee  7800              LDRB     r0,[r0,#0]  ; first_temperate
0001f0  b120              CBZ      r0,|L3.508|
;;;120    					{	
;;;121    						offset_OK_flag1 = 1;
0001f2  2001              MOVS     r0,#1
0001f4  491b              LDR      r1,|L3.612|
0001f6  7008              STRB     r0,[r1,#0]
;;;122    						 led_red_off();
0001f8  f7fffffe          BL       led_red_off
                  |L3.508|
;;;123    					}
;;;124    //                    else if (start_gyro_cali_time < GYRO_OFFSET_START_TIME)
;;;125    //                    {
;;;126    //											
;;;127    //                        IMUWarnBuzzerOn();
;;;128    //                        if(first_temperate)
;;;129    //                        {
;;;130    //                            //当进入gyro_offset函数，如果无运动start_gyro_cali_time++，如果有运动 start_gyro_cali_time = 0
;;;131    //                            gyro_offset(Gyro_Offset, INS_gyro, mpu6500_real_data.status, &start_gyro_cali_time);
;;;132    //                        }
;;;133    //                    }
;;;134    //                    else if (start_gyro_cali_time == GYRO_OFFSET_START_TIME)
;;;135    //                    {
;;;136    //						
;;;137    //                       
;;;138    //                        start_gyro_cali_time++;
;;;139    //                    }
;;;140                    }       //陀螺仪开机校准   code end
;;;141    
;;;142                }           //update count if   code end
;;;143            }               //mpu6500 status  if end
;;;144    				IMU_temp_Control(mpu6500_real_data.temp);
0001fc  4803              LDR      r0,|L3.524|
0001fe  edd00a04          VLDR     s1,[r0,#0x10]
000202  eeb00a60          VMOV.F32 s0,s1
000206  f7fffffe          BL       IMU_temp_Control
;;;145    }
00020a  bd08              POP      {r3,pc}
;;;146    
                          ENDP

                  |L3.524|
                          DCD      mpu6500_real_data
                  |L3.528|
                          DCD      mpu6500_spi_rxbuf+0x1
                  |L3.532|
                          DCD      ist8310_real_data
                  |L3.536|
                          DCD      INS_mag
                  |L3.540|
                          DCD      INS_accel
                  |L3.544|
                          DCD      INS_gyro
                  |L3.548|
                          DCD      updata_count
                  |L3.552|
000228  45898000          DCFS     0x45898000 ; 4400
                  |L3.556|
00022c  459c3800          DCFS     0x459c3800 ; 4999
                  |L3.560|
                          DCD      PID_INCR_TEMP
                  |L3.564|
                          DCD      pid_incr+0x154
                  |L3.568|
                          DCD      INS_quat
                  |L3.572|
                          DCD      INS_Angle+0x8
                  |L3.576|
                          DCD      accel_fliter_3
                  |L3.580|
                          DCD      accel_fliter_2
                  |L3.584|
                          DCD      accel_fliter_1
                  |L3.588|
                          DCD      fliter_num
                  |L3.592|
000250  3a83126f          DCFS     0x3a83126f ; 0.0010000000474974513
                  |L3.596|
                          DCD      start_gyro_cali_time
                  |L3.600|
                          DCD      gyro_cali_offset
                  |L3.604|
                          DCD      Gyro_Offset
                  |L3.608|
                          DCD      first_temperate
                  |L3.612|
                          DCD      offset_OK_flag1

                          AREA ||i.INS_cali_gyro||, CODE, READONLY, ALIGN=2

                  INS_cali_gyro PROC
;;;155    
;;;156    void INS_cali_gyro(fp32 cali_scale[3], fp32 cali_offset[3], uint16_t *time_count)
000000  b570              PUSH     {r4-r6,lr}
;;;157    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;158        if (first_temperate)
000008  4815              LDR      r0,|L4.96|
00000a  7800              LDRB     r0,[r0,#0]  ; first_temperate
00000c  b338              CBZ      r0,|L4.94|
;;;159        {
;;;160            if( *time_count == 0)
00000e  8828              LDRH     r0,[r5,#0]
000010  b988              CBNZ     r0,|L4.54|
;;;161            {
;;;162                Gyro_Offset[0] = gyro_cali_offset[0];
000012  4814              LDR      r0,|L4.100|
000014  ed900a00          VLDR     s0,[r0,#0]
000018  4813              LDR      r0,|L4.104|
00001a  ed800a00          VSTR     s0,[r0,#0]
;;;163                Gyro_Offset[1] = gyro_cali_offset[1];
00001e  4811              LDR      r0,|L4.100|
000020  ed900a01          VLDR     s0,[r0,#4]
000024  4810              LDR      r0,|L4.104|
000026  ed800a01          VSTR     s0,[r0,#4]
;;;164                Gyro_Offset[2] = gyro_cali_offset[2];
00002a  480e              LDR      r0,|L4.100|
00002c  ed900a02          VLDR     s0,[r0,#8]
000030  480d              LDR      r0,|L4.104|
000032  ed800a02          VSTR     s0,[r0,#8]
                  |L4.54|
;;;165            }
;;;166            gyro_offset(Gyro_Offset, INS_gyro, mpu6500_real_data.status, time_count);
000036  480d              LDR      r0,|L4.108|
000038  7802              LDRB     r2,[r0,#0]  ; mpu6500_real_data
00003a  462b              MOV      r3,r5
00003c  490c              LDR      r1,|L4.112|
00003e  480a              LDR      r0,|L4.104|
000040  f7fffffe          BL       gyro_offset
;;;167    
;;;168            cali_offset[0] = Gyro_Offset[0];
000044  4808              LDR      r0,|L4.104|
000046  ed900a00          VLDR     s0,[r0,#0]
00004a  ed840a00          VSTR     s0,[r4,#0]
;;;169            cali_offset[1] = Gyro_Offset[1];
00004e  ed900a01          VLDR     s0,[r0,#4]
000052  ed840a01          VSTR     s0,[r4,#4]
;;;170            cali_offset[2] = Gyro_Offset[2];
000056  ed900a02          VLDR     s0,[r0,#8]
00005a  ed840a02          VSTR     s0,[r4,#8]
                  |L4.94|
;;;171        }
;;;172    }
00005e  bd70              POP      {r4-r6,pc}
;;;173    
                          ENDP

                  |L4.96|
                          DCD      first_temperate
                  |L4.100|
                          DCD      gyro_cali_offset
                  |L4.104|
                          DCD      Gyro_Offset
                  |L4.108|
                          DCD      mpu6500_real_data
                  |L4.112|
                          DCD      INS_gyro

                          AREA ||i.INS_set_cali_gyro||, CODE, READONLY, ALIGN=2

                  INS_set_cali_gyro PROC
;;;182    int16_t ins_set_counts = 0;
;;;183    void INS_set_cali_gyro(fp32 cali_scale[3], fp32 cali_offset[6])
000000  4a09              LDR      r2,|L5.40|
;;;184    {
;;;185    	ins_set_counts++;
000002  8812              LDRH     r2,[r2,#0]  ; ins_set_counts
000004  1c52              ADDS     r2,r2,#1
000006  b212              SXTH     r2,r2
000008  4b07              LDR      r3,|L5.40|
00000a  801a              STRH     r2,[r3,#0]
;;;186        gyro_cali_offset[0]  = cali_offset[0];
00000c  ed910a00          VLDR     s0,[r1,#0]
000010  4a06              LDR      r2,|L5.44|
000012  ed820a00          VSTR     s0,[r2,#0]
;;;187        gyro_cali_offset[1]  = cali_offset[1];
000016  ed910a01          VLDR     s0,[r1,#4]
00001a  ed820a01          VSTR     s0,[r2,#4]
;;;188        gyro_cali_offset[2]  = cali_offset[2];
00001e  ed910a02          VLDR     s0,[r1,#8]
000022  ed820a02          VSTR     s0,[r2,#8]
;;;189    }
000026  4770              BX       lr
;;;190    
                          ENDP

                  |L5.40|
                          DCD      ins_set_counts
                  |L5.44|
                          DCD      gyro_cali_offset

                          AREA ||i.cali_gyro_hook||, CODE, READONLY, ALIGN=2

                  cali_gyro_hook PROC
;;;217    
;;;218    int8_t cali_gyro_hook(void)
000000  b500              PUSH     {lr}
;;;219    {
000002  b087              SUB      sp,sp,#0x1c
;;;220    	imu_cali_t local_cali_t;
;;;221    
;;;222    	INS_cali_gyro(local_cali_t.scale, local_cali_t.offset, &count_time);
000004  4a13              LDR      r2,|L6.84|
000006  a901              ADD      r1,sp,#4
000008  a804              ADD      r0,sp,#0x10
00000a  f7fffffe          BL       INS_cali_gyro
;;;223    	if (count_time > GYRO_CALIBRATE_TIME)
00000e  4811              LDR      r0,|L6.84|
000010  8800              LDRH     r0,[r0,#0]  ; count_time
000012  f6446120          MOV      r1,#0x4e20
000016  4288              CMP      r0,r1
000018  dd18              BLE      |L6.76|
;;;224    	{
;;;225    		count_time = 0;
00001a  2000              MOVS     r0,#0
00001c  490d              LDR      r1,|L6.84|
00001e  8008              STRH     r0,[r1,#0]
;;;226    		OFFSET_Buffer[0] = local_cali_t.offset[0];
000020  ed9d0a01          VLDR     s0,[sp,#4]
000024  480c              LDR      r0,|L6.88|
000026  ed800a00          VSTR     s0,[r0,#0]
;;;227    		OFFSET_Buffer[1] = local_cali_t.offset[1];
00002a  ed9d0a02          VLDR     s0,[sp,#8]
00002e  ed800a01          VSTR     s0,[r0,#4]
;;;228    		OFFSET_Buffer[2] = local_cali_t.offset[2];
000032  ed9d0a03          VLDR     s0,[sp,#0xc]
000036  ed800a02          VSTR     s0,[r0,#8]
;;;229    		flash_write();
00003a  f7fffffe          BL       flash_write
;;;230    		led_red_off();
00003e  f7fffffe          BL       led_red_off
;;;231    		offset_OK_flag = 1;
000042  2001              MOVS     r0,#1
000044  4905              LDR      r1,|L6.92|
000046  7008              STRB     r0,[r1,#0]
                  |L6.72|
;;;232    		return 1;
;;;233    	}
;;;234    	else
;;;235    	{
;;;236    		led_red_on();
;;;237    		return 0;
;;;238    	}
;;;239    	
;;;240    }
000048  b007              ADD      sp,sp,#0x1c
00004a  bd00              POP      {pc}
                  |L6.76|
00004c  f7fffffe          BL       led_red_on
000050  2000              MOVS     r0,#0                 ;237
000052  e7f9              B        |L6.72|
;;;241    
                          ENDP

                  |L6.84|
                          DCD      count_time
                  |L6.88|
                          DCD      OFFSET_Buffer
                  |L6.92|
                          DCD      offset_OK_flag

                          AREA ||i.get_INS_angle_point||, CODE, READONLY, ALIGN=2

                  get_INS_angle_point PROC
;;;190    
;;;191    const fp32 *get_INS_angle_point(void)
000000  4800              LDR      r0,|L7.4|
;;;192    {
;;;193        return INS_Angle;
;;;194    }
000002  4770              BX       lr
;;;195    const fp32 *get_MPU6500_Gyro_Data_Point(void)
                          ENDP

                  |L7.4|
                          DCD      INS_Angle

                          AREA ||i.get_MPU6500_Accel_Data_Point||, CODE, READONLY, ALIGN=2

                  get_MPU6500_Accel_Data_Point PROC
;;;199    
;;;200    const fp32 *get_MPU6500_Accel_Data_Point(void)
000000  4800              LDR      r0,|L8.4|
;;;201    {
;;;202        return INS_accel;
;;;203    }
000002  4770              BX       lr
;;;204    
                          ENDP

                  |L8.4|
                          DCD      INS_accel

                          AREA ||i.get_MPU6500_Gyro_Data_Point||, CODE, READONLY, ALIGN=2

                  get_MPU6500_Gyro_Data_Point PROC
;;;194    }
;;;195    const fp32 *get_MPU6500_Gyro_Data_Point(void)
000000  4800              LDR      r0,|L9.4|
;;;196    {
;;;197        return INS_gyro;
;;;198    }
000002  4770              BX       lr
;;;199    
                          ENDP

                  |L9.4|
                          DCD      INS_gyro

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  mpu6500_spi_rxbuf
                          %        24
                  mpu6500_real_data
                          %        32
                  gyro_cali_offset
                          %        12
                  ist8310_real_data
                          %        16
                  Gyro_Offset
                          %        12
                  Accel_Offset
                          %        12
                  Mag_Offset
                          %        12
                  INS_gyro
                          %        12
                  INS_accel
                          %        12
                  INS_mag
                          %        12
                  INS_Angle
                          %        12
                  INS_quat
                          %        16
                  accel_fliter_1
                          %        12
                  accel_fliter_2
                          %        12
                  accel_fliter_3
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  fliter_num
000000  3ff6f85a          DCFS     0x3ff6f85a ; 1.9294540882110596
000004  bf6e895d          DCFS     0xbf6e895d ; -0.93178349733352661
000008  3b18a9d5          DCFS     0x3b18a9d5 ; 0.0023294587153941393

                          AREA ||.data||, DATA, ALIGN=2

                  Gyro_Scale_Factor
000000  00000000          DCFS     0x00000000 ; 0
000004  3f800000          DCFS     0x3f800000 ; 1
000008  00000000          DCFS     0x00000000 ; 0
00000c  bf800000          DCFS     0xbf800000 ; -1
000010  00000000          DCFS     0x00000000 ; 0
000014  00000000          DCFS     0x00000000 ; 0
000018  00000000          DCFS     0x00000000 ; 0
00001c  00000000          DCFS     0x00000000 ; 0
000020  3f800000          DCFS     0x3f800000 ; 1
                  Accel_Scale_Factor
000024  00000000          DCFS     0x00000000 ; 0
000028  3f800000          DCFS     0x3f800000 ; 1
00002c  00000000          DCFS     0x00000000 ; 0
000030  bf800000          DCFS     0xbf800000 ; -1
000034  00000000          DCFS     0x00000000 ; 0
000038  00000000          DCFS     0x00000000 ; 0
00003c  00000000          DCFS     0x00000000 ; 0
000040  00000000          DCFS     0x00000000 ; 0
000044  3f800000          DCFS     0x3f800000 ; 1
                  Mag_Scale_Factor
000048  3f800000          DCFS     0x3f800000 ; 1
00004c  00000000          DCFS     0x00000000 ; 0
000050  00000000          DCFS     0x00000000 ; 0
000054  00000000          DCFS     0x00000000 ; 0
000058  3f800000          DCFS     0x3f800000 ; 1
00005c  00000000          DCFS     0x00000000 ; 0
000060  00000000          DCFS     0x00000000 ; 0
000064  00000000          DCFS     0x00000000 ; 0
000068  3f800000          DCFS     0x3f800000 ; 1
                  PID_INCR_TEMP
00006c  45fa0000          DCFS     0x45fa0000 ; 8000
000070  3f000000          DCFS     0x3f000000 ; 0.5
000074  00000000          DCFS     0x00000000 ; 0
                  first_temperate
000078  0000              DCB      0x00,0x00
                  ins_set_counts
00007a  0000              DCW      0x0000
                  count_time
00007c  0000              DCW      0x0000
                  updata_count
00007e  0000              DCB      0x00,0x00
                  start_gyro_cali_time
000080  0000              DCW      0x0000
                  temp_constant_time
000082  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\AHRS\\INS_task.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_INS_task_c_59f807d9____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___10_INS_task_c_59f807d9____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_INS_task_c_59f807d9____REVSH|
#line 153
|__asm___10_INS_task_c_59f807d9____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_INS_task_c_59f807d9____RRX|
#line 328
|__asm___10_INS_task_c_59f807d9____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
