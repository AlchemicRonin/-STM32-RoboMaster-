; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_dcmi.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_dcmi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_dcmi.crf ..\FWLIB\src\stm32f4xx_dcmi.c]
                          THUMB

                          AREA ||i.DCMI_CROPCmd||, CODE, READONLY, ALIGN=2

                  DCMI_CROPCmd PROC
;;;222      */
;;;223    void DCMI_CROPCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L1.16|
;;;224    {
;;;225      /* Check the parameters */
;;;226      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;227        
;;;228      if (NewState != DISABLE)
;;;229      {
;;;230        /* Enable the DCMI Crop feature */
;;;231        DCMI->CR |= (uint32_t)DCMI_CR_CROP;
000002  4907              LDR      r1,|L1.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410104          ORR      r1,r1,#4
00000a  4a05              LDR      r2,|L1.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L1.28|
                  |L1.16|
;;;232      }
;;;233      else
;;;234      {
;;;235        /* Disable the DCMI Crop feature */
;;;236        DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
000010  4903              LDR      r1,|L1.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210104          BIC      r1,r1,#4
000018  4a01              LDR      r2,|L1.32|
00001a  6011              STR      r1,[r2,#0]
                  |L1.28|
;;;237      }
;;;238    }
00001c  4770              BX       lr
;;;239    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_CROPConfig||, CODE, READONLY, ALIGN=2

                  DCMI_CROPConfig PROC
;;;204      */
;;;205    void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
000000  8841              LDRH     r1,[r0,#2]
;;;206    {  
;;;207      /* Sets the CROP window coordinates */
;;;208      DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
000002  8802              LDRH     r2,[r0,#0]
000004  ea414102          ORR      r1,r1,r2,LSL #16
000008  4a04              LDR      r2,|L2.28|
00000a  6211              STR      r1,[r2,#0x20]
;;;209                      ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
;;;210    
;;;211      /* Sets the CROP window size */
;;;212      DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
00000c  88c1              LDRH     r1,[r0,#6]
00000e  8882              LDRH     r2,[r0,#4]
000010  ea414102          ORR      r1,r1,r2,LSL #16
000014  4a01              LDR      r2,|L2.28|
000016  6251              STR      r1,[r2,#0x24]
;;;213                      ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
;;;214    }
000018  4770              BX       lr
;;;215    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x50050000

                          AREA ||i.DCMI_CaptureCmd||, CODE, READONLY, ALIGN=2

                  DCMI_CaptureCmd PROC
;;;321      */
;;;322    void DCMI_CaptureCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L3.16|
;;;323    {
;;;324      /* Check the parameters */
;;;325      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;326        
;;;327      if (NewState != DISABLE)
;;;328      {
;;;329        /* Enable the DCMI Capture */
;;;330        DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
000002  4907              LDR      r1,|L3.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410101          ORR      r1,r1,#1
00000a  4a05              LDR      r2,|L3.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L3.28|
                  |L3.16|
;;;331      }
;;;332      else
;;;333      {
;;;334        /* Disable the DCMI Capture */
;;;335        DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
000010  4903              LDR      r1,|L3.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210101          BIC      r1,r1,#1
000018  4a01              LDR      r2,|L3.32|
00001a  6011              STR      r1,[r2,#0]
                  |L3.28|
;;;336      }
;;;337    }
00001c  4770              BX       lr
;;;338    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_ClearFlag||, CODE, READONLY, ALIGN=2

                  DCMI_ClearFlag PROC
;;;460      */
;;;461    void DCMI_ClearFlag(uint16_t DCMI_FLAG)
000000  4901              LDR      r1,|L4.8|
;;;462    {
;;;463      /* Check the parameters */
;;;464      assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
;;;465      
;;;466      /* Clear the flag by writing in the ICR register 1 in the corresponding 
;;;467      Flag position*/
;;;468      
;;;469      DCMI->ICR = DCMI_FLAG;
000002  6148              STR      r0,[r1,#0x14]
;;;470    }
000004  4770              BX       lr
;;;471    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DCMI_ClearITPendingBit PROC
;;;514      */
;;;515    void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
000000  4901              LDR      r1,|L5.8|
;;;516    {
;;;517      /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
;;;518      corresponding pending Bit position*/
;;;519      
;;;520      DCMI->ICR = DCMI_IT;
000002  6148              STR      r0,[r1,#0x14]
;;;521    }
000004  4770              BX       lr
;;;522    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_Cmd||, CODE, READONLY, ALIGN=2

                  DCMI_Cmd PROC
;;;298      */
;;;299    void DCMI_Cmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L6.16|
;;;300    {
;;;301      /* Check the parameters */
;;;302      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;303      
;;;304      if (NewState != DISABLE)
;;;305      {
;;;306        /* Enable the DCMI by setting ENABLE bit */
;;;307        DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
000002  4907              LDR      r1,|L6.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4414180          ORR      r1,r1,#0x4000
00000a  4a05              LDR      r2,|L6.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L6.28|
                  |L6.16|
;;;308      }
;;;309      else
;;;310      {
;;;311        /* Disable the DCMI by clearing ENABLE bit */
;;;312        DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
000010  4903              LDR      r1,|L6.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4214180          BIC      r1,r1,#0x4000
000018  4a01              LDR      r2,|L6.32|
00001a  6011              STR      r1,[r2,#0]
                  |L6.28|
;;;313      }
;;;314    }
00001c  4770              BX       lr
;;;315    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_DeInit||, CODE, READONLY, ALIGN=2

                  DCMI_DeInit PROC
;;;125      */
;;;126    void DCMI_DeInit(void)
000000  2000              MOVS     r0,#0
;;;127    {
;;;128      DCMI->CR = 0x0;
000002  4905              LDR      r1,|L7.24|
000004  6008              STR      r0,[r1,#0]
;;;129      DCMI->IER = 0x0;
000006  60c8              STR      r0,[r1,#0xc]
;;;130      DCMI->ICR = 0x1F;
000008  201f              MOVS     r0,#0x1f
00000a  6148              STR      r0,[r1,#0x14]
;;;131      DCMI->ESCR = 0x0;
00000c  2000              MOVS     r0,#0
00000e  6188              STR      r0,[r1,#0x18]
;;;132      DCMI->ESUR = 0x0;
000010  61c8              STR      r0,[r1,#0x1c]
;;;133      DCMI->CWSTRTR = 0x0;
000012  6208              STR      r0,[r1,#0x20]
;;;134      DCMI->CWSIZER = 0x0;
000014  6248              STR      r0,[r1,#0x24]
;;;135    }
000016  4770              BX       lr
;;;136    
                          ENDP

                  |L7.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DCMI_GetFlagStatus PROC
;;;413      */
;;;414    FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG)
000000  b510              PUSH     {r4,lr}
;;;415    {
000002  4601              MOV      r1,r0
;;;416      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;417      uint32_t dcmireg, tempreg = 0;
000006  2300              MOVS     r3,#0
;;;418    
;;;419      /* Check the parameters */
;;;420      assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
;;;421      
;;;422      /* Get the DCMI register index */
;;;423      dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
000008  130a              ASRS     r2,r1,#12
;;;424      
;;;425      if (dcmireg == 0x00) /* The FLAG is in RISR register */
00000a  b912              CBNZ     r2,|L8.18|
;;;426      {
;;;427        tempreg= DCMI->RISR;
00000c  4c08              LDR      r4,|L8.48|
00000e  68a3              LDR      r3,[r4,#8]
000010  e006              B        |L8.32|
                  |L8.18|
;;;428      }
;;;429      else if (dcmireg == 0x02) /* The FLAG is in SR register */
000012  2a02              CMP      r2,#2
000014  d102              BNE      |L8.28|
;;;430      {
;;;431        tempreg = DCMI->SR;
000016  4c06              LDR      r4,|L8.48|
000018  6863              LDR      r3,[r4,#4]
00001a  e001              B        |L8.32|
                  |L8.28|
;;;432      }
;;;433      else /* The FLAG is in MISR register */
;;;434      {
;;;435        tempreg = DCMI->MISR;
00001c  4c04              LDR      r4,|L8.48|
00001e  6923              LDR      r3,[r4,#0x10]
                  |L8.32|
;;;436      }
;;;437      
;;;438      if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
000020  ea030401          AND      r4,r3,r1
000024  b10c              CBZ      r4,|L8.42|
;;;439      {
;;;440        bitstatus = SET;
000026  2001              MOVS     r0,#1
000028  e000              B        |L8.44|
                  |L8.42|
;;;441      }
;;;442      else
;;;443      {
;;;444        bitstatus = RESET;
00002a  2000              MOVS     r0,#0
                  |L8.44|
;;;445      }
;;;446      /* Return the DCMI_FLAG status */
;;;447      return  bitstatus;
;;;448    }
00002c  bd10              POP      {r4,pc}
;;;449    
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      0x50050000

                          AREA ||i.DCMI_GetITStatus||, CODE, READONLY, ALIGN=2

                  DCMI_GetITStatus PROC
;;;482      */
;;;483    ITStatus DCMI_GetITStatus(uint16_t DCMI_IT)
000000  4601              MOV      r1,r0
;;;484    {
;;;485      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;486      uint32_t itstatus = 0;
000004  2200              MOVS     r2,#0
;;;487      
;;;488      /* Check the parameters */
;;;489      assert_param(IS_DCMI_GET_IT(DCMI_IT));
;;;490      
;;;491      itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
000006  4b04              LDR      r3,|L9.24|
000008  691b              LDR      r3,[r3,#0x10]
00000a  ea030201          AND      r2,r3,r1
;;;492      
;;;493      if ((itstatus != (uint16_t)RESET))
00000e  b10a              CBZ      r2,|L9.20|
;;;494      {
;;;495        bitstatus = SET;
000010  2001              MOVS     r0,#1
000012  e000              B        |L9.22|
                  |L9.20|
;;;496      }
;;;497      else
;;;498      {
;;;499        bitstatus = RESET;
000014  2000              MOVS     r0,#0
                  |L9.22|
;;;500      }
;;;501      return bitstatus;
;;;502    }
000016  4770              BX       lr
;;;503    
                          ENDP

                  |L9.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_ITConfig||, CODE, READONLY, ALIGN=2

                  DCMI_ITConfig PROC
;;;376      */
;;;377    void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L10.14|
;;;378    {
;;;379      /* Check the parameters */
;;;380      assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
;;;381      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;382      
;;;383      if (NewState != DISABLE)
;;;384      {
;;;385        /* Enable the Interrupt sources */
;;;386        DCMI->IER |= DCMI_IT;
000002  4a07              LDR      r2,|L10.32|
000004  68d2              LDR      r2,[r2,#0xc]
000006  4302              ORRS     r2,r2,r0
000008  4b05              LDR      r3,|L10.32|
00000a  60da              STR      r2,[r3,#0xc]
00000c  e006              B        |L10.28|
                  |L10.14|
;;;387      }
;;;388      else
;;;389      {
;;;390        /* Disable the Interrupt sources */
;;;391        DCMI->IER &= (uint16_t)(~DCMI_IT);
00000e  4a04              LDR      r2,|L10.32|
000010  68d2              LDR      r2,[r2,#0xc]
000012  43c3              MVNS     r3,r0
000014  b29b              UXTH     r3,r3
000016  401a              ANDS     r2,r2,r3
000018  4b01              LDR      r3,|L10.32|
00001a  60da              STR      r2,[r3,#0xc]
                  |L10.28|
;;;392      }  
;;;393    }
00001c  4770              BX       lr
;;;394    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_Init||, CODE, READONLY, ALIGN=2

                  DCMI_Init PROC
;;;142      */
;;;143    void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
000000  2100              MOVS     r1,#0
;;;144    {
;;;145      uint32_t temp = 0x0;
;;;146      
;;;147      /* Check the parameters */
;;;148      assert_param(IS_DCMI_CAPTURE_MODE(DCMI_InitStruct->DCMI_CaptureMode));
;;;149      assert_param(IS_DCMI_SYNCHRO(DCMI_InitStruct->DCMI_SynchroMode));
;;;150      assert_param(IS_DCMI_PCKPOLARITY(DCMI_InitStruct->DCMI_PCKPolarity));
;;;151      assert_param(IS_DCMI_VSPOLARITY(DCMI_InitStruct->DCMI_VSPolarity));
;;;152      assert_param(IS_DCMI_HSPOLARITY(DCMI_InitStruct->DCMI_HSPolarity));
;;;153      assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
;;;154      assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));
;;;155    
;;;156      /* The DCMI configuration registers should be programmed correctly before 
;;;157      enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
;;;158      DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
000002  4a0e              LDR      r2,|L11.60|
000004  6812              LDR      r2,[r2,#0]
000006  f2440301          MOV      r3,#0x4001
00000a  439a              BICS     r2,r2,r3
00000c  4b0b              LDR      r3,|L11.60|
00000e  601a              STR      r2,[r3,#0]
;;;159       
;;;160      /* Reset the old DCMI configuration */
;;;161      temp = DCMI->CR;
000010  461a              MOV      r2,r3
000012  6811              LDR      r1,[r2,#0]
;;;162      
;;;163      temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
000014  f64072f2          MOV      r2,#0xff2
000018  4391              BICS     r1,r1,r2
;;;164                          DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
;;;165                          DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
;;;166                      
;;;167      /* Sets the new configuration of the DCMI peripheral */
;;;168      temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
00001a  8802              LDRH     r2,[r0,#0]
00001c  8843              LDRH     r3,[r0,#2]
00001e  431a              ORRS     r2,r2,r3
000020  8883              LDRH     r3,[r0,#4]
000022  431a              ORRS     r2,r2,r3
000024  88c3              LDRH     r3,[r0,#6]
000026  431a              ORRS     r2,r2,r3
000028  8903              LDRH     r3,[r0,#8]
00002a  431a              ORRS     r2,r2,r3
00002c  8943              LDRH     r3,[r0,#0xa]
00002e  431a              ORRS     r2,r2,r3
000030  8983              LDRH     r3,[r0,#0xc]
000032  431a              ORRS     r2,r2,r3
000034  4311              ORRS     r1,r1,r2
;;;169                         DCMI_InitStruct->DCMI_SynchroMode |
;;;170                         DCMI_InitStruct->DCMI_PCKPolarity |
;;;171                         DCMI_InitStruct->DCMI_VSPolarity |
;;;172                         DCMI_InitStruct->DCMI_HSPolarity |
;;;173                         DCMI_InitStruct->DCMI_CaptureRate |
;;;174                         DCMI_InitStruct->DCMI_ExtendedDataMode);
;;;175    
;;;176      DCMI->CR = temp;                              
000036  4a01              LDR      r2,|L11.60|
000038  6011              STR      r1,[r2,#0]
;;;177    }
00003a  4770              BX       lr
;;;178    
                          ENDP

                  |L11.60|
                          DCD      0x50050000

                          AREA ||i.DCMI_JPEGCmd||, CODE, READONLY, ALIGN=2

                  DCMI_JPEGCmd PROC
;;;260      */
;;;261    void DCMI_JPEGCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L12.16|
;;;262    {
;;;263      /* Check the parameters */
;;;264      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;265     
;;;266      if (NewState != DISABLE)
;;;267      {
;;;268        /* Enable the DCMI JPEG format */
;;;269        DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
000002  4907              LDR      r1,|L12.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410108          ORR      r1,r1,#8
00000a  4a05              LDR      r2,|L12.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L12.28|
                  |L12.16|
;;;270      }
;;;271      else
;;;272      {
;;;273        /* Disable the DCMI JPEG format */
;;;274        DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
000010  4903              LDR      r1,|L12.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210108          BIC      r1,r1,#8
000018  4a01              LDR      r2,|L12.32|
00001a  6011              STR      r1,[r2,#0]
                  |L12.28|
;;;275      }
;;;276    }
00001c  4770              BX       lr
;;;277    /**
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_ReadData||, CODE, READONLY, ALIGN=2

                  DCMI_ReadData PROC
;;;343      */
;;;344    uint32_t DCMI_ReadData(void)
000000  4801              LDR      r0,|L13.8|
;;;345    {
;;;346      return DCMI->DR;
000002  6a80              LDR      r0,[r0,#0x28]
;;;347    }
000004  4770              BX       lr
;;;348    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_SetEmbeddedSynchroCodes||, CODE, READONLY, ALIGN=2

                  DCMI_SetEmbeddedSynchroCodes PROC
;;;245      */
;;;246    void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
000000  7801              LDRB     r1,[r0,#0]
;;;247    {
;;;248      DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
000002  7842              LDRB     r2,[r0,#1]
000004  ea412102          ORR      r1,r1,r2,LSL #8
000008  7882              LDRB     r2,[r0,#2]
00000a  ea414102          ORR      r1,r1,r2,LSL #16
00000e  78c2              LDRB     r2,[r0,#3]
000010  ea416102          ORR      r1,r1,r2,LSL #24
000014  4a01              LDR      r2,|L14.28|
000016  6191              STR      r1,[r2,#0x18]
;;;249                              ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
;;;250                              ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
;;;251                              ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
;;;252    }
000018  4770              BX       lr
;;;253    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x50050000

                          AREA ||i.DCMI_StructInit||, CODE, READONLY, ALIGN=1

                  DCMI_StructInit PROC
;;;184      */
;;;185    void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
000000  2100              MOVS     r1,#0
;;;186    {
;;;187      /* Set the default configuration */
;;;188      DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
000002  8001              STRH     r1,[r0,#0]
;;;189      DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
000004  8041              STRH     r1,[r0,#2]
;;;190      DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
000006  8081              STRH     r1,[r0,#4]
;;;191      DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
000008  80c1              STRH     r1,[r0,#6]
;;;192      DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
00000a  8101              STRH     r1,[r0,#8]
;;;193      DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
00000c  8141              STRH     r1,[r0,#0xa]
;;;194      DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
00000e  8181              STRH     r1,[r0,#0xc]
;;;195    }
000010  4770              BX       lr
;;;196    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_dcmi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_dcmi_c_3610e7fb____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___16_stm32f4xx_dcmi_c_3610e7fb____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_dcmi_c_3610e7fb____REVSH|
#line 153
|__asm___16_stm32f4xx_dcmi_c_3610e7fb____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_dcmi_c_3610e7fb____RRX|
#line 328
|__asm___16_stm32f4xx_dcmi_c_3610e7fb____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
