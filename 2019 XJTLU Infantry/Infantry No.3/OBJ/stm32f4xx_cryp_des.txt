; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_cryp_des.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_cryp_des.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_cryp_des.crf ..\FWLIB\src\stm32f4xx_cryp_des.c]
                          THUMB

                          AREA ||i.CRYP_DES_CBC||, CODE, READONLY, ALIGN=1

                  CRYP_DES_CBC PROC
;;;201      */
;;;202    ErrorStatus CRYP_DES_CBC(uint8_t Mode, uint8_t Key[8], uint8_t InitVectors[8],
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;203                             uint8_t *Input, uint32_t Ilength, uint8_t *Output)
;;;204    {
000004  b095              SUB      sp,sp,#0x54
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  4692              MOV      r10,r2
00000c  469b              MOV      r11,r3
;;;205      CRYP_InitTypeDef DES_CRYP_InitStructure;
;;;206      CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
;;;207      CRYP_IVInitTypeDef DES_CRYP_IVInitStructure;
;;;208      __IO uint32_t counter = 0;
00000e  2000              MOVS     r0,#0
000010  9004              STR      r0,[sp,#0x10]
;;;209      uint32_t busystatus = 0;
000012  9003              STR      r0,[sp,#0xc]
;;;210      ErrorStatus status = SUCCESS;
000014  2001              MOVS     r0,#1
000016  9002              STR      r0,[sp,#8]
;;;211      uint32_t keyaddr    = (uint32_t)Key;
000018  464e              MOV      r6,r9
;;;212      uint32_t inputaddr  = (uint32_t)Input;
00001a  465c              MOV      r4,r11
;;;213      uint32_t outputaddr = (uint32_t)Output;
00001c  9d1f              LDR      r5,[sp,#0x7c]
;;;214      uint32_t ivaddr     = (uint32_t)InitVectors;
00001e  4657              MOV      r7,r10
;;;215      uint32_t i = 0;
000020  2000              MOVS     r0,#0
000022  9001              STR      r0,[sp,#4]
;;;216    
;;;217      /* Crypto structures initialisation*/
;;;218      CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
000024  a809              ADD      r0,sp,#0x24
000026  f7fffffe          BL       CRYP_KeyStructInit
;;;219    
;;;220      /* Crypto Init for Encryption process */
;;;221      if(Mode == MODE_ENCRYPT) /* DES encryption */
00002a  f1b80f01          CMP      r8,#1
00002e  d102              BNE      |L1.54|
;;;222      {
;;;223         DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
000030  2000              MOVS     r0,#0
000032  9011              STR      r0,[sp,#0x44]
000034  e001              B        |L1.58|
                  |L1.54|
;;;224      }
;;;225      else /*if(Mode == MODE_DECRYPT)*/ /* DES decryption */
;;;226      {
;;;227         DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
000036  2004              MOVS     r0,#4
000038  9011              STR      r0,[sp,#0x44]
                  |L1.58|
;;;228      }
;;;229    
;;;230      DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_CBC;
00003a  2018              MOVS     r0,#0x18
00003c  9012              STR      r0,[sp,#0x48]
;;;231      DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00003e  2080              MOVS     r0,#0x80
000040  9013              STR      r0,[sp,#0x4c]
;;;232      CRYP_Init(&DES_CRYP_InitStructure);
000042  a811              ADD      r0,sp,#0x44
000044  f7fffffe          BL       CRYP_Init
;;;233    
;;;234      /* Key Initialisation */
;;;235      DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000048  6830              LDR      r0,[r6,#0]
00004a  ba00              REV      r0,r0
00004c  900b              STR      r0,[sp,#0x2c]
;;;236      keyaddr+=4;
00004e  1d36              ADDS     r6,r6,#4
;;;237      DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
000050  6830              LDR      r0,[r6,#0]
000052  ba00              REV      r0,r0
000054  900c              STR      r0,[sp,#0x30]
;;;238      CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
000056  a809              ADD      r0,sp,#0x24
000058  f7fffffe          BL       CRYP_KeyInit
;;;239    
;;;240      /* Initialization Vectors */
;;;241      DES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
00005c  6838              LDR      r0,[r7,#0]
00005e  ba00              REV      r0,r0
000060  9005              STR      r0,[sp,#0x14]
;;;242      ivaddr+=4;
000062  1d3f              ADDS     r7,r7,#4
;;;243      DES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
000064  6838              LDR      r0,[r7,#0]
000066  ba00              REV      r0,r0
000068  9006              STR      r0,[sp,#0x18]
;;;244      CRYP_IVInit(&DES_CRYP_IVInitStructure);
00006a  a805              ADD      r0,sp,#0x14
00006c  f7fffffe          BL       CRYP_IVInit
;;;245    
;;;246      /* Flush IN/OUT FIFO */
;;;247      CRYP_FIFOFlush();
000070  f7fffffe          BL       CRYP_FIFOFlush
;;;248      
;;;249      /* Enable Crypto processor */
;;;250      CRYP_Cmd(ENABLE);
000074  2001              MOVS     r0,#1
000076  f7fffffe          BL       CRYP_Cmd
;;;251    
;;;252      if(CRYP_GetCmdStatus() == DISABLE)
00007a  f7fffffe          BL       CRYP_GetCmdStatus
00007e  b910              CBNZ     r0,|L1.134|
;;;253      {
;;;254        /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;255        the CRYP peripheral (please check the device sales type. */
;;;256        status = ERROR;
000080  2000              MOVS     r0,#0
000082  9002              STR      r0,[sp,#8]
000084  e035              B        |L1.242|
                  |L1.134|
;;;257      }
;;;258      else
;;;259      {
;;;260        for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
000086  2000              MOVS     r0,#0
000088  9001              STR      r0,[sp,#4]
00008a  e028              B        |L1.222|
                  |L1.140|
;;;261        {
;;;262          /* Write the Input block in the Input FIFO */
;;;263          CRYP_DataIn(*(uint32_t*)(inputaddr));
00008c  6820              LDR      r0,[r4,#0]
00008e  f7fffffe          BL       CRYP_DataIn
;;;264          inputaddr+=4;
000092  1d24              ADDS     r4,r4,#4
;;;265          CRYP_DataIn(*(uint32_t*)(inputaddr));
000094  6820              LDR      r0,[r4,#0]
000096  f7fffffe          BL       CRYP_DataIn
;;;266          inputaddr+=4;
00009a  1d24              ADDS     r4,r4,#4
;;;267          
;;;268          /* Wait until the complete message has been processed */
;;;269          counter = 0;
00009c  2000              MOVS     r0,#0
00009e  9004              STR      r0,[sp,#0x10]
;;;270          do
0000a0  bf00              NOP      
                  |L1.162|
;;;271          {
;;;272            busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
0000a2  2010              MOVS     r0,#0x10
0000a4  f7fffffe          BL       CRYP_GetFlagStatus
0000a8  9003              STR      r0,[sp,#0xc]
;;;273            counter++;
0000aa  9804              LDR      r0,[sp,#0x10]
0000ac  1c40              ADDS     r0,r0,#1
0000ae  9004              STR      r0,[sp,#0x10]
;;;274          }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
0000b0  9804              LDR      r0,[sp,#0x10]
0000b2  f5b03f80          CMP      r0,#0x10000
0000b6  d002              BEQ      |L1.190|
0000b8  9803              LDR      r0,[sp,#0xc]
0000ba  2800              CMP      r0,#0
0000bc  d1f1              BNE      |L1.162|
                  |L1.190|
;;;275          
;;;276          if (busystatus != RESET)
0000be  9803              LDR      r0,[sp,#0xc]
0000c0  b110              CBZ      r0,|L1.200|
;;;277          {
;;;278            status = ERROR;
0000c2  2000              MOVS     r0,#0
0000c4  9002              STR      r0,[sp,#8]
0000c6  e007              B        |L1.216|
                  |L1.200|
;;;279          }
;;;280          else
;;;281          {
;;;282            /* Read the Output block from the Output FIFO */
;;;283            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000c8  f7fffffe          BL       CRYP_DataOut
0000cc  6028              STR      r0,[r5,#0]
;;;284            outputaddr+=4;
0000ce  1d2d              ADDS     r5,r5,#4
;;;285            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000d0  f7fffffe          BL       CRYP_DataOut
0000d4  6028              STR      r0,[r5,#0]
;;;286            outputaddr+=4;
0000d6  1d2d              ADDS     r5,r5,#4
                  |L1.216|
0000d8  9801              LDR      r0,[sp,#4]            ;260
0000da  3008              ADDS     r0,r0,#8              ;260
0000dc  9001              STR      r0,[sp,#4]            ;260
                  |L1.222|
0000de  991e              LDR      r1,[sp,#0x78]         ;260
0000e0  9801              LDR      r0,[sp,#4]            ;260
0000e2  4288              CMP      r0,r1                 ;260
0000e4  d202              BCS      |L1.236|
0000e6  9802              LDR      r0,[sp,#8]            ;260
0000e8  2800              CMP      r0,#0                 ;260
0000ea  d1cf              BNE      |L1.140|
                  |L1.236|
;;;287          }
;;;288        }
;;;289        
;;;290        /* Disable Crypto */
;;;291        CRYP_Cmd(DISABLE);
0000ec  2000              MOVS     r0,#0
0000ee  f7fffffe          BL       CRYP_Cmd
                  |L1.242|
;;;292      }
;;;293      return status; 
0000f2  9802              LDR      r0,[sp,#8]
;;;294    }
0000f4  b015              ADD      sp,sp,#0x54
0000f6  e8bd8ff0          POP      {r4-r11,pc}
;;;295    
                          ENDP


                          AREA ||i.CRYP_DES_ECB||, CODE, READONLY, ALIGN=1

                  CRYP_DES_ECB PROC
;;;98       */
;;;99     ErrorStatus CRYP_DES_ECB(uint8_t Mode, uint8_t Key[8], uint8_t *Input, 
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;100                             uint32_t Ilength, uint8_t *Output)
;;;101    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
;;;102      CRYP_InitTypeDef DES_CRYP_InitStructure;
;;;103      CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
;;;104      __IO uint32_t counter = 0;
00000e  2000              MOVS     r0,#0
000010  9002              STR      r0,[sp,#8]
;;;105      uint32_t busystatus = 0;
000012  4683              MOV      r11,r0
;;;106      ErrorStatus status = SUCCESS;
000014  2001              MOVS     r0,#1
000016  9001              STR      r0,[sp,#4]
;;;107      uint32_t keyaddr    = (uint32_t)Key;
000018  4646              MOV      r6,r8
;;;108      uint32_t inputaddr  = (uint32_t)Input;
00001a  464c              MOV      r4,r9
;;;109      uint32_t outputaddr = (uint32_t)Output;
00001c  9d18              LDR      r5,[sp,#0x60]
;;;110      uint32_t i = 0;
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
;;;111    
;;;112      /* Crypto structures initialisation*/
;;;113      CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
000022  a803              ADD      r0,sp,#0xc
000024  f7fffffe          BL       CRYP_KeyStructInit
;;;114    
;;;115      /* Crypto Init for Encryption process */
;;;116      if( Mode == MODE_ENCRYPT ) /* DES encryption */
000028  2f01              CMP      r7,#1
00002a  d102              BNE      |L2.50|
;;;117      {
;;;118         DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
00002c  2000              MOVS     r0,#0
00002e  900b              STR      r0,[sp,#0x2c]
000030  e001              B        |L2.54|
                  |L2.50|
;;;119      }
;;;120      else/* if( Mode == MODE_DECRYPT )*/ /* DES decryption */
;;;121      {      
;;;122         DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
000032  2004              MOVS     r0,#4
000034  900b              STR      r0,[sp,#0x2c]
                  |L2.54|
;;;123      }
;;;124    
;;;125      DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_ECB;
000036  2010              MOVS     r0,#0x10
000038  900c              STR      r0,[sp,#0x30]
;;;126      DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00003a  2080              MOVS     r0,#0x80
00003c  900d              STR      r0,[sp,#0x34]
;;;127      CRYP_Init(&DES_CRYP_InitStructure);
00003e  a80b              ADD      r0,sp,#0x2c
000040  f7fffffe          BL       CRYP_Init
;;;128    
;;;129      /* Key Initialisation */
;;;130      DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000044  6830              LDR      r0,[r6,#0]
000046  ba00              REV      r0,r0
000048  9005              STR      r0,[sp,#0x14]
;;;131      keyaddr+=4;
00004a  1d36              ADDS     r6,r6,#4
;;;132      DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00004c  6830              LDR      r0,[r6,#0]
00004e  ba00              REV      r0,r0
000050  9006              STR      r0,[sp,#0x18]
;;;133      CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
000052  a803              ADD      r0,sp,#0xc
000054  f7fffffe          BL       CRYP_KeyInit
;;;134    
;;;135      /* Flush IN/OUT FIFO */
;;;136      CRYP_FIFOFlush();
000058  f7fffffe          BL       CRYP_FIFOFlush
;;;137    
;;;138      /* Enable Crypto processor */
;;;139      CRYP_Cmd(ENABLE);
00005c  2001              MOVS     r0,#1
00005e  f7fffffe          BL       CRYP_Cmd
;;;140    
;;;141      if(CRYP_GetCmdStatus() == DISABLE)
000062  f7fffffe          BL       CRYP_GetCmdStatus
000066  b910              CBNZ     r0,|L2.110|
;;;142      {
;;;143        /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;144        the CRYP peripheral (please check the device sales type. */
;;;145        status = ERROR;
000068  2000              MOVS     r0,#0
00006a  9001              STR      r0,[sp,#4]
00006c  e035              B        |L2.218|
                  |L2.110|
;;;146      }
;;;147      else
;;;148      {
;;;149        for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
00006e  2000              MOVS     r0,#0
000070  9000              STR      r0,[sp,#0]
000072  e029              B        |L2.200|
                  |L2.116|
;;;150        {
;;;151          
;;;152          /* Write the Input block in the Input FIFO */
;;;153          CRYP_DataIn(*(uint32_t*)(inputaddr));
000074  6820              LDR      r0,[r4,#0]
000076  f7fffffe          BL       CRYP_DataIn
;;;154          inputaddr+=4;
00007a  1d24              ADDS     r4,r4,#4
;;;155          CRYP_DataIn(*(uint32_t*)(inputaddr));
00007c  6820              LDR      r0,[r4,#0]
00007e  f7fffffe          BL       CRYP_DataIn
;;;156          inputaddr+=4;
000082  1d24              ADDS     r4,r4,#4
;;;157          
;;;158          /* Wait until the complete message has been processed */
;;;159          counter = 0;
000084  2000              MOVS     r0,#0
000086  9002              STR      r0,[sp,#8]
;;;160          do
000088  bf00              NOP      
                  |L2.138|
;;;161          {
;;;162            busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
00008a  2010              MOVS     r0,#0x10
00008c  f7fffffe          BL       CRYP_GetFlagStatus
000090  4683              MOV      r11,r0
;;;163            counter++;
000092  9802              LDR      r0,[sp,#8]
000094  1c40              ADDS     r0,r0,#1
000096  9002              STR      r0,[sp,#8]
;;;164          }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
000098  9802              LDR      r0,[sp,#8]
00009a  f5b03f80          CMP      r0,#0x10000
00009e  d002              BEQ      |L2.166|
0000a0  f1bb0f00          CMP      r11,#0
0000a4  d1f1              BNE      |L2.138|
                  |L2.166|
;;;165          
;;;166          if (busystatus != RESET)
0000a6  f1bb0f00          CMP      r11,#0
0000aa  d002              BEQ      |L2.178|
;;;167          {
;;;168            status = ERROR;
0000ac  2000              MOVS     r0,#0
0000ae  9001              STR      r0,[sp,#4]
0000b0  e007              B        |L2.194|
                  |L2.178|
;;;169          }
;;;170          else
;;;171          {
;;;172            
;;;173            /* Read the Output block from the Output FIFO */
;;;174            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000b2  f7fffffe          BL       CRYP_DataOut
0000b6  6028              STR      r0,[r5,#0]
;;;175            outputaddr+=4;
0000b8  1d2d              ADDS     r5,r5,#4
;;;176            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000ba  f7fffffe          BL       CRYP_DataOut
0000be  6028              STR      r0,[r5,#0]
;;;177            outputaddr+=4;
0000c0  1d2d              ADDS     r5,r5,#4
                  |L2.194|
0000c2  9800              LDR      r0,[sp,#0]            ;149
0000c4  3008              ADDS     r0,r0,#8              ;149
0000c6  9000              STR      r0,[sp,#0]            ;149
                  |L2.200|
0000c8  9800              LDR      r0,[sp,#0]            ;149
0000ca  4550              CMP      r0,r10                ;149
0000cc  d202              BCS      |L2.212|
0000ce  9801              LDR      r0,[sp,#4]            ;149
0000d0  2800              CMP      r0,#0                 ;149
0000d2  d1cf              BNE      |L2.116|
                  |L2.212|
;;;178          }
;;;179        }
;;;180        
;;;181        /* Disable Crypto */
;;;182        CRYP_Cmd(DISABLE);
0000d4  2000              MOVS     r0,#0
0000d6  f7fffffe          BL       CRYP_Cmd
                  |L2.218|
;;;183      }
;;;184      return status; 
0000da  9801              LDR      r0,[sp,#4]
;;;185    }
0000dc  b00f              ADD      sp,sp,#0x3c
0000de  e8bd8ff0          POP      {r4-r11,pc}
;;;186    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_cryp_des.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_des_c_9174d91f____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___20_stm32f4xx_cryp_des_c_9174d91f____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_des_c_9174d91f____REVSH|
#line 153
|__asm___20_stm32f4xx_cryp_des_c_9174d91f____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_des_c_9174d91f____RRX|
#line 328
|__asm___20_stm32f4xx_cryp_des_c_9174d91f____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
