; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\encoder.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\encoder.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\encoder.crf ..\BSP\encoder.c]
                          THUMB

                          AREA ||i.CanReceiveMsgProcess||, CODE, READONLY, ALIGN=2

                  CanReceiveMsgProcess PROC
;;;10     volatile Encoder CMFeedEncoder   =  	{0,0,0,0,0,0,0,0,0,0,0,0,0,0};
;;;11     void CanReceiveMsgProcess(CanRxMsg *message)
000000  b510              PUSH     {r4,lr}
;;;12     {
000002  4604              MOV      r4,r0
;;;13     	switch(message->StdId)
000004  6820              LDR      r0,[r4,#0]
000006  f2a02001          SUB      r0,r0,#0x201
00000a  2807              CMP      r0,#7
00000c  d228              BCS      |L1.96|
00000e  e8dff000          TBB      [pc,r0]
000012  0409              DCB      0x04,0x09
000014  0e13181d          DCB      0x0e,0x13,0x18,0x1d
000018  2200              DCB      0x22,0x00
;;;14     	{
;;;15     		case CAN_ID_CM1:    	getEncoderData(&CM1Encoder, message);   	break;
00001a  4621              MOV      r1,r4
00001c  4811              LDR      r0,|L1.100|
00001e  f7fffffe          BL       getEncoderData
000022  e01d              B        |L1.96|
;;;16                 
;;;17     		case CAN_ID_CM2:    	getEncoderData(&CM2Encoder, message); 	  break;
000024  4621              MOV      r1,r4
000026  4810              LDR      r0,|L1.104|
000028  f7fffffe          BL       getEncoderData
00002c  e018              B        |L1.96|
;;;18     
;;;19     		case CAN_ID_CM3:  	  getEncoderData(&CM3Encoder, message);   	break;
00002e  4621              MOV      r1,r4
000030  480e              LDR      r0,|L1.108|
000032  f7fffffe          BL       getEncoderData
000036  e013              B        |L1.96|
;;;20     
;;;21     		case CAN_ID_CM4:	    getEncoderData(&CM4Encoder, message); 	  break;
000038  4621              MOV      r1,r4
00003a  480d              LDR      r0,|L1.112|
00003c  f7fffffe          BL       getEncoderData
000040  e00e              B        |L1.96|
;;;22     
;;;23     		case CAN_ID_YAW:	    getEncoderData(&GMYawEncoder, message);	  break;
000042  4621              MOV      r1,r4
000044  480b              LDR      r0,|L1.116|
000046  f7fffffe          BL       getEncoderData
00004a  e009              B        |L1.96|
;;;24     
;;;25     		case CAN_ID_PITCH:	  getEncoderData(&GMPitchEncoder, message); break;
00004c  4621              MOV      r1,r4
00004e  480a              LDR      r0,|L1.120|
000050  f7fffffe          BL       getEncoderData
000054  e004              B        |L1.96|
;;;26     		
;;;27     		case CAN_ID_CM_FEED:  getEncoderData(&CMFeedEncoder, message);  break;
000056  4621              MOV      r1,r4
000058  4808              LDR      r0,|L1.124|
00005a  f7fffffe          BL       getEncoderData
00005e  bf00              NOP      
                  |L1.96|
000060  bf00              NOP                            ;15
;;;28     	}
;;;29     }
000062  bd10              POP      {r4,pc}
;;;30     
                          ENDP

                  |L1.100|
                          DCD      CM1Encoder
                  |L1.104|
                          DCD      CM2Encoder
                  |L1.108|
                          DCD      CM3Encoder
                  |L1.112|
                          DCD      CM4Encoder
                  |L1.116|
                          DCD      GMYawEncoder
                  |L1.120|
                          DCD      GMPitchEncoder
                  |L1.124|
                          DCD      CMFeedEncoder

                          AREA ||i.getEncoderData||, CODE, READONLY, ALIGN=2

                  getEncoderData PROC
;;;31     //int a11=7000;
;;;32     void getEncoderData(volatile Encoder *v, CanRxMsg * msg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;33     {
000004  ed2d8b06          VPUSH    {d8-d10}
000008  4604              MOV      r4,r0
00000a  460d              MOV      r5,r1
;;;34     //	a11+=20;
;;;35     //	if(a11>7100){
;;;36     //		a11=7000;
;;;37     //	}
;;;38     	int i=0;
00000c  2600              MOVS     r6,#0
;;;39     	int32_t temp_sum = 0;    
00000e  2700              MOVS     r7,#0
;;;40     	v->last_raw_value = v->raw_value;
000010  6820              LDR      r0,[r4,#0]
000012  6060              STR      r0,[r4,#4]
;;;41     	v->raw_value = (msg->Data[0]<<8)|msg->Data[1];
000014  7b28              LDRB     r0,[r5,#0xc]
000016  7ae9              LDRB     r1,[r5,#0xb]
000018  ea402001          ORR      r0,r0,r1,LSL #8
00001c  6020              STR      r0,[r4,#0]
;;;42     	v->diff = v->raw_value - v->last_raw_value;
00001e  6820              LDR      r0,[r4,#0]
000020  6861              LDR      r1,[r4,#4]
000022  1a40              SUBS     r0,r0,r1
000024  60e0              STR      r0,[r4,#0xc]
;;;43     	if(v->diff < -4096)    //两次编码器的反馈值差别太大，表示圈数发生了改变
000026  68e0              LDR      r0,[r4,#0xc]
000028  f5105f80          CMN      r0,#0x1000
00002c  da07              BGE      |L2.62|
;;;44     	{
;;;45     		v->round_cnt++;
00002e  6ba0              LDR      r0,[r4,#0x38]
000030  1c40              ADDS     r0,r0,#1
000032  63a0              STR      r0,[r4,#0x38]
;;;46     		v->ecd_raw_rate = v->diff + 8192;
000034  68e0              LDR      r0,[r4,#0xc]
000036  f5005000          ADD      r0,r0,#0x2000
00003a  61e0              STR      r0,[r4,#0x1c]
00003c  e00d              B        |L2.90|
                  |L2.62|
;;;47     	}
;;;48     	else if(v->diff>4096)
00003e  68e0              LDR      r0,[r4,#0xc]
000040  f5b05f80          CMP      r0,#0x1000
000044  dd07              BLE      |L2.86|
;;;49     	{
;;;50     		v->round_cnt--;
000046  6ba0              LDR      r0,[r4,#0x38]
000048  1e40              SUBS     r0,r0,#1
00004a  63a0              STR      r0,[r4,#0x38]
;;;51     		v->ecd_raw_rate = v->diff - 8192;
00004c  68e0              LDR      r0,[r4,#0xc]
00004e  f5a05000          SUB      r0,r0,#0x2000
000052  61e0              STR      r0,[r4,#0x1c]
000054  e001              B        |L2.90|
                  |L2.86|
;;;52     	}		
;;;53     	else
;;;54     	{
;;;55     		v->ecd_raw_rate = v->diff;
000056  68e0              LDR      r0,[r4,#0xc]
000058  61e0              STR      r0,[r4,#0x1c]
                  |L2.90|
;;;56     	}
;;;57     	//计算得到连续的编码器输出值
;;;58     	v->ecd_value = v->raw_value + v->round_cnt * 8192;
00005a  6821              LDR      r1,[r4,#0]
00005c  6ba0              LDR      r0,[r4,#0x38]
00005e  eb013040          ADD      r0,r1,r0,LSL #13
000062  60a0              STR      r0,[r4,#8]
;;;59     	//计算得到角度值，范围正负无穷大
;;;60     	v->ecd_angle = (float)(v->raw_value - v->ecd_bias)*360/8192 + v->round_cnt * 360;
000064  6820              LDR      r0,[r4,#0]
000066  69a1              LDR      r1,[r4,#0x18]
000068  1a40              SUBS     r0,r0,r1
00006a  ee000a10          VMOV     s0,r0
00006e  eeb80ac0          VCVT.F32.S32 s0,s0
000072  eddf0a37          VLDR     s1,|L2.336|
000076  ee200a20          VMUL.F32 s0,s0,s1
00007a  ed9f1a36          VLDR     s2,|L2.340|
00007e  eec00a01          VDIV.F32 s1,s0,s2
000082  6ba0              LDR      r0,[r4,#0x38]
000084  f44f71b4          MOV      r1,#0x168
000088  4348              MULS     r0,r1,r0
00008a  ee000a10          VMOV     s0,r0
00008e  eeb80ac0          VCVT.F32.S32 s0,s0
000092  ee300a80          VADD.F32 s0,s1,s0
000096  ed840a11          VSTR     s0,[r4,#0x44]
;;;61     	v->rate_buf[v->buf_count++] = v->ecd_raw_rate;
00009a  69e2              LDR      r2,[r4,#0x1c]
00009c  7d20              LDRB     r0,[r4,#0x14]
00009e  1c41              ADDS     r1,r0,#1
0000a0  7521              STRB     r1,[r4,#0x14]
0000a2  f1040120          ADD      r1,r4,#0x20
0000a6  f8412020          STR      r2,[r1,r0,LSL #2]
;;;62     	if(v->buf_count == RATE_BUF_SIZE)
0000aa  7d20              LDRB     r0,[r4,#0x14]
0000ac  2806              CMP      r0,#6
0000ae  d101              BNE      |L2.180|
;;;63     	{
;;;64     		v->buf_count = 0;
0000b0  2000              MOVS     r0,#0
0000b2  7520              STRB     r0,[r4,#0x14]
                  |L2.180|
;;;65     	}
;;;66     	//计算速度平均值
;;;67     	for(i = 0;i < RATE_BUF_SIZE; i++)
0000b4  2600              MOVS     r6,#0
0000b6  e005              B        |L2.196|
                  |L2.184|
;;;68     	{
;;;69     		temp_sum += v->rate_buf[i];
0000b8  f1040020          ADD      r0,r4,#0x20
0000bc  f8500026          LDR      r0,[r0,r6,LSL #2]
0000c0  4407              ADD      r7,r7,r0
0000c2  1c76              ADDS     r6,r6,#1              ;67
                  |L2.196|
0000c4  2e06              CMP      r6,#6                 ;67
0000c6  dbf7              BLT      |L2.184|
;;;70     	}
;;;71     	v->filter_rate = (int32_t)(temp_sum/RATE_BUF_SIZE);
0000c8  2006              MOVS     r0,#6
0000ca  fb97f0f0          SDIV     r0,r7,r0
0000ce  63e0              STR      r0,[r4,#0x3c]
;;;72     	
;;;73     	
;;;74     	if(fabs((float)v->filter_rate_max) < fabs((float)v->filter_rate))
0000d0  6be0              LDR      r0,[r4,#0x3c]
0000d2  ee000a10          VMOV     s0,r0
0000d6  eeb80ac0          VCVT.F32.S32 s0,s0
0000da  ee101a10          VMOV     r1,s0
0000de  4608              MOV      r0,r1
0000e0  f7fffffe          BL       __aeabi_f2d
0000e4  ec410b1a          VMOV     d10,r0,r1
0000e8  eeb00a4a          VMOV.F32 s0,s20
0000ec  eef00a6a          VMOV.F32 s1,s21
0000f0  f7fffffe          BL       __hardfp_fabs
0000f4  eeb08a40          VMOV.F32 s16,s0
0000f8  eef08a60          VMOV.F32 s17,s1
0000fc  6c20              LDR      r0,[r4,#0x40]
0000fe  ee000a10          VMOV     s0,r0
000102  eeb80ac0          VCVT.F32.S32 s0,s0
000106  ee101a10          VMOV     r1,s0
00010a  4608              MOV      r0,r1
00010c  f7fffffe          BL       __aeabi_f2d
000110  ec410b1a          VMOV     d10,r0,r1
000114  eeb00a4a          VMOV.F32 s0,s20
000118  eef00a6a          VMOV.F32 s1,s21
00011c  f7fffffe          BL       __hardfp_fabs
000120  eeb09a40          VMOV.F32 s18,s0
000124  eef09a60          VMOV.F32 s19,s1
000128  ec532b18          VMOV     r2,r3,d8
00012c  ec510b19          VMOV     r0,r1,d9
000130  f7fffffe          BL       __aeabi_cdcmple
000134  d201              BCS      |L2.314|
;;;75     	{
;;;76     		v->filter_rate_max = v->filter_rate;
000136  6be0              LDR      r0,[r4,#0x3c]
000138  6420              STR      r0,[r4,#0x40]
                  |L2.314|
;;;77     	}
;;;78     	v->current = (uint16_t)((msg)->Data[4] << 8 | (msg)->Data[5]);
00013a  7c29              LDRB     r1,[r5,#0x10]
00013c  7be8              LDRB     r0,[r5,#0xf]
00013e  ea412000          ORR      r0,r1,r0,LSL #8
000142  b200              SXTH     r0,r0
000144  f8a4004c          STRH     r0,[r4,#0x4c]
;;;79     	
;;;80     }
000148  ecbd8b06          VPOP     {d8-d10}
00014c  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L2.336|
000150  43b40000          DCFS     0x43b40000 ; 360
                  |L2.340|
000154  46000000          DCFS     0x46000000 ; 8192

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  CM1Encoder
                          %        80
                  CM2Encoder
                          %        80
                  CM3Encoder
                          %        80
                  CM4Encoder
                          %        80
                  GMYawEncoder
                          %        80
                  GMPitchEncoder
                          %        80
                  CMFeedEncoder
                          %        80

;*** Start embedded assembler ***

#line 1 "..\\BSP\\encoder.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_encoder_c_80f85154____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___9_encoder_c_80f85154____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_encoder_c_80f85154____REVSH|
#line 153
|__asm___9_encoder_c_80f85154____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_encoder_c_80f85154____RRX|
#line 328
|__asm___9_encoder_c_80f85154____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
