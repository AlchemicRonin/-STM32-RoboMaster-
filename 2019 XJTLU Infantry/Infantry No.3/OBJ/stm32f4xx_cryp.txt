; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_cryp.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_cryp.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_cryp.crf ..\FWLIB\src\stm32f4xx_cryp.c]
                          THUMB

                          AREA ||i.CRYP_Cmd||, CODE, READONLY, ALIGN=2

                  CRYP_Cmd PROC
;;;402      */
;;;403    void CRYP_Cmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L1.16|
;;;404    {
;;;405      /* Check the parameters */
;;;406      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;407    
;;;408      if (NewState != DISABLE)
;;;409      {
;;;410        /* Enable the Cryptographic processor */
;;;411        CRYP->CR |= CRYP_CR_CRYPEN;
000002  4907              LDR      r1,|L1.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4414100          ORR      r1,r1,#0x8000
00000a  4a05              LDR      r2,|L1.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L1.28|
                  |L1.16|
;;;412      }
;;;413      else
;;;414      {
;;;415        /* Disable the Cryptographic processor */
;;;416        CRYP->CR &= ~CRYP_CR_CRYPEN;
000010  4903              LDR      r1,|L1.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4214100          BIC      r1,r1,#0x8000
000018  4a01              LDR      r2,|L1.32|
00001a  6011              STR      r1,[r2,#0]
                  |L1.28|
;;;417      }
;;;418    }
00001c  4770              BX       lr
;;;419    /**
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0x50060000

                          AREA ||i.CRYP_DMACmd||, CODE, READONLY, ALIGN=2

                  CRYP_DMACmd PROC
;;;680      */
;;;681    void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
000000  b129              CBZ      r1,|L2.14|
;;;682    {
;;;683      /* Check the parameters */
;;;684      assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
;;;685      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;686    
;;;687      if (NewState != DISABLE)
;;;688      {
;;;689        /* Enable the selected CRYP DMA request */
;;;690        CRYP->DMACR |= CRYP_DMAReq;
000002  4a07              LDR      r2,|L2.32|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b05              LDR      r3,|L2.32|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e006              B        |L2.28|
                  |L2.14|
;;;691      }
;;;692      else
;;;693      {
;;;694        /* Disable the selected CRYP DMA request */
;;;695        CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
00000e  4a04              LDR      r2,|L2.32|
000010  6912              LDR      r2,[r2,#0x10]
000012  43c3              MVNS     r3,r0
000014  b2db              UXTB     r3,r3
000016  401a              ANDS     r2,r2,r3
000018  4b01              LDR      r3,|L2.32|
00001a  611a              STR      r2,[r3,#0x10]
                  |L2.28|
;;;696      }
;;;697    }
00001c  4770              BX       lr
;;;698    /**
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x50060000

                          AREA ||i.CRYP_DataIn||, CODE, READONLY, ALIGN=2

                  CRYP_DataIn PROC
;;;445      */
;;;446    void CRYP_DataIn(uint32_t Data)
000000  4901              LDR      r1,|L3.8|
;;;447    {
;;;448      CRYP->DR = Data;
000002  6088              STR      r0,[r1,#8]
;;;449    }
000004  4770              BX       lr
;;;450    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x50060000

                          AREA ||i.CRYP_DataOut||, CODE, READONLY, ALIGN=2

                  CRYP_DataOut PROC
;;;455      */
;;;456    uint32_t CRYP_DataOut(void)
000000  4801              LDR      r0,|L4.8|
;;;457    {
;;;458      return CRYP->DOUT;
000002  68c0              LDR      r0,[r0,#0xc]
;;;459    }
000004  4770              BX       lr
;;;460    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50060000

                          AREA ||i.CRYP_DeInit||, CODE, READONLY, ALIGN=1

                  CRYP_DeInit PROC
;;;218      */
;;;219    void CRYP_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;220    {
;;;221      /* Enable CRYP reset state */
;;;222      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;223    
;;;224      /* Release CRYP from reset state */
;;;225      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;226    }
000012  bd10              POP      {r4,pc}
;;;227    
                          ENDP


                          AREA ||i.CRYP_FIFOFlush||, CODE, READONLY, ALIGN=2

                  CRYP_FIFOFlush PROC
;;;390      */
;;;391    void CRYP_FIFOFlush(void)
000000  4803              LDR      r0,|L6.16|
;;;392    {
;;;393      /* Reset the read and write pointers of the FIFOs */
;;;394      CRYP->CR |= CRYP_CR_FFLUSH;
000002  6800              LDR      r0,[r0,#0]
000004  f4404080          ORR      r0,r0,#0x4000
000008  4901              LDR      r1,|L6.16|
00000a  6008              STR      r0,[r1,#0]
;;;395    }
00000c  4770              BX       lr
;;;396    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetCmdStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetCmdStatus PROC
;;;852      */
;;;853    FunctionalState CRYP_GetCmdStatus(void)
000000  2000              MOVS     r0,#0
;;;854    {
;;;855      FunctionalState state = DISABLE;
;;;856    
;;;857      if ((CRYP->CR & CRYP_CR_CRYPEN) != 0)
000002  4904              LDR      r1,|L7.20|
000004  6809              LDR      r1,[r1,#0]
000006  f4014100          AND      r1,r1,#0x8000
00000a  b109              CBZ      r1,|L7.16|
;;;858      {
;;;859        /* CRYPEN bit is set */
;;;860        state = ENABLE;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L7.18|
                  |L7.16|
;;;861      }
;;;862      else
;;;863      {
;;;864        /* CRYPEN bit is reset */
;;;865        state = DISABLE;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;866      }
;;;867      return state;
;;;868    }
000012  4770              BX       lr
;;;869    
                          ENDP

                  |L7.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetFlagStatus PROC
;;;882      */
;;;883    FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)
000000  4601              MOV      r1,r0
;;;884    {
;;;885      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;886      uint32_t tempreg = 0;
000004  2200              MOVS     r2,#0
;;;887    
;;;888      /* Check the parameters */
;;;889      assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));
;;;890    
;;;891      /* check if the FLAG is in RISR register */
;;;892      if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
000006  f0010320          AND      r3,r1,#0x20
00000a  b113              CBZ      r3,|L8.18|
;;;893      {
;;;894        tempreg = CRYP->RISR;
00000c  4b05              LDR      r3,|L8.36|
00000e  699a              LDR      r2,[r3,#0x18]
000010  e001              B        |L8.22|
                  |L8.18|
;;;895      }
;;;896      else  /* The FLAG is in SR register */
;;;897      {
;;;898        tempreg = CRYP->SR;
000012  4b04              LDR      r3,|L8.36|
000014  685a              LDR      r2,[r3,#4]
                  |L8.22|
;;;899      }
;;;900    
;;;901    
;;;902      /* Check the status of the specified CRYP flag */
;;;903      if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
000016  ea020301          AND      r3,r2,r1
00001a  b10b              CBZ      r3,|L8.32|
;;;904      {
;;;905        /* CRYP_FLAG is set */
;;;906        bitstatus = SET;
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L8.34|
                  |L8.32|
;;;907      }
;;;908      else
;;;909      {
;;;910        /* CRYP_FLAG is reset */
;;;911        bitstatus = RESET;
000020  2000              MOVS     r0,#0
                  |L8.34|
;;;912      }
;;;913    
;;;914      /* Return the CRYP_FLAG status */
;;;915      return  bitstatus;
;;;916    }
000022  4770              BX       lr
;;;917    
                          ENDP

                  |L8.36|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetITStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetITStatus PROC
;;;826      */
;;;827    ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)
000000  4601              MOV      r1,r0
;;;828    {
;;;829      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;830      /* Check the parameters */
;;;831      assert_param(IS_CRYP_GET_IT(CRYP_IT));
;;;832    
;;;833      /* Check the status of the specified CRYP interrupt */
;;;834      if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
000004  4a03              LDR      r2,|L9.20|
000006  69d2              LDR      r2,[r2,#0x1c]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L9.16|
;;;835      {
;;;836        /* CRYP_IT is set */
;;;837        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
;;;838      }
;;;839      else
;;;840      {
;;;841        /* CRYP_IT is reset */
;;;842        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;843      }
;;;844      /* Return the CRYP_IT status */
;;;845      return bitstatus;
;;;846    }
000012  4770              BX       lr
;;;847    
                          ENDP

                  |L9.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_ITConfig||, CODE, READONLY, ALIGN=2

                  CRYP_ITConfig PROC
;;;798      */
;;;799    void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L10.14|
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
;;;803      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;804    
;;;805      if (NewState != DISABLE)
;;;806      {
;;;807        /* Enable the selected CRYP interrupt */
;;;808        CRYP->IMSCR |= CRYP_IT;
000002  4a07              LDR      r2,|L10.32|
000004  6952              LDR      r2,[r2,#0x14]
000006  4302              ORRS     r2,r2,r0
000008  4b05              LDR      r3,|L10.32|
00000a  615a              STR      r2,[r3,#0x14]
00000c  e006              B        |L10.28|
                  |L10.14|
;;;809      }
;;;810      else
;;;811      {
;;;812        /* Disable the selected CRYP interrupt */
;;;813        CRYP->IMSCR &= (uint8_t)~CRYP_IT;
00000e  4a04              LDR      r2,|L10.32|
000010  6952              LDR      r2,[r2,#0x14]
000012  43c3              MVNS     r3,r0
000014  b2db              UXTB     r3,r3
000016  401a              ANDS     r2,r2,r3
000018  4b01              LDR      r3,|L10.32|
00001a  615a              STR      r2,[r3,#0x14]
                  |L10.28|
;;;814      }
;;;815    }
00001c  4770              BX       lr
;;;816    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0x50060000

                          AREA ||i.CRYP_IVInit||, CODE, READONLY, ALIGN=2

                  CRYP_IVInit PROC
;;;332      */
;;;333    void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
000000  4a04              LDR      r2,|L11.20|
;;;334    {
;;;335      CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
000002  6801              LDR      r1,[r0,#0]
000004  6411              STR      r1,[r2,#0x40]
;;;336      CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
000006  6841              LDR      r1,[r0,#4]
000008  6451              STR      r1,[r2,#0x44]
;;;337      CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
00000a  6881              LDR      r1,[r0,#8]
00000c  6491              STR      r1,[r2,#0x48]
;;;338      CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
00000e  68c1              LDR      r1,[r0,#0xc]
000010  64d1              STR      r1,[r2,#0x4c]
;;;339    }
000012  4770              BX       lr
;;;340    
                          ENDP

                  |L11.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_IVStructInit||, CODE, READONLY, ALIGN=1

                  CRYP_IVStructInit PROC
;;;346      */
;;;347    void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
000000  2100              MOVS     r1,#0
;;;348    {
;;;349      CRYP_IVInitStruct->CRYP_IV0Left  = 0;
000002  6001              STR      r1,[r0,#0]
;;;350      CRYP_IVInitStruct->CRYP_IV0Right = 0;
000004  6041              STR      r1,[r0,#4]
;;;351      CRYP_IVInitStruct->CRYP_IV1Left  = 0;
000006  6081              STR      r1,[r0,#8]
;;;352      CRYP_IVInitStruct->CRYP_IV1Right = 0;
000008  60c1              STR      r1,[r0,#0xc]
;;;353    }
00000a  4770              BX       lr
;;;354    
                          ENDP


                          AREA ||i.CRYP_Init||, CODE, READONLY, ALIGN=2

                  CRYP_Init PROC
;;;234      */
;;;235    void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
000000  491c              LDR      r1,|L13.116|
;;;236    {
;;;237      /* Check the parameters */
;;;238      assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
;;;239      assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
;;;240      assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));
;;;241    
;;;242      /* Select Algorithm mode*/  
;;;243      CRYP->CR &= ~CRYP_CR_ALGOMODE;
000002  6809              LDR      r1,[r1,#0]
000004  4a1c              LDR      r2,|L13.120|
000006  4011              ANDS     r1,r1,r2
000008  4a1a              LDR      r2,|L13.116|
00000a  6011              STR      r1,[r2,#0]
;;;244      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  6842              LDR      r2,[r0,#4]
000012  4311              ORRS     r1,r1,r2
000014  4a17              LDR      r2,|L13.116|
000016  6011              STR      r1,[r2,#0]
;;;245    
;;;246      /* Select dataType */ 
;;;247      CRYP->CR &= ~CRYP_CR_DATATYPE;
000018  4611              MOV      r1,r2
00001a  6809              LDR      r1,[r1,#0]
00001c  f02101c0          BIC      r1,r1,#0xc0
000020  6011              STR      r1,[r2,#0]
;;;248      CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
000022  4611              MOV      r1,r2
000024  6809              LDR      r1,[r1,#0]
000026  6882              LDR      r2,[r0,#8]
000028  4311              ORRS     r1,r1,r2
00002a  4a12              LDR      r2,|L13.116|
00002c  6011              STR      r1,[r2,#0]
;;;249    
;;;250      /* select Key size (used only with AES algorithm) */
;;;251      if ((CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_ECB) &&
00002e  6841              LDR      r1,[r0,#4]
000030  b199              CBZ      r1,|L13.90|
;;;252          (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_CBC) &&
000032  6841              LDR      r1,[r0,#4]
000034  2908              CMP      r1,#8
000036  d010              BEQ      |L13.90|
;;;253          (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_ECB) &&
000038  6841              LDR      r1,[r0,#4]
00003a  2910              CMP      r1,#0x10
00003c  d00d              BEQ      |L13.90|
;;;254          (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_CBC))
00003e  6841              LDR      r1,[r0,#4]
000040  2918              CMP      r1,#0x18
000042  d00a              BEQ      |L13.90|
;;;255      {
;;;256        assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
;;;257        CRYP->CR &= ~CRYP_CR_KEYSIZE;
000044  4611              MOV      r1,r2
000046  6809              LDR      r1,[r1,#0]
000048  f4217140          BIC      r1,r1,#0x300
00004c  6011              STR      r1,[r2,#0]
;;;258        CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
00004e  4611              MOV      r1,r2
000050  6809              LDR      r1,[r1,#0]
000052  68c2              LDR      r2,[r0,#0xc]
000054  4311              ORRS     r1,r1,r2
000056  4a07              LDR      r2,|L13.116|
000058  6011              STR      r1,[r2,#0]
                  |L13.90|
;;;259                                                      configured once the key has 
;;;260                                                      been prepared */
;;;261      }
;;;262    
;;;263      /* Select data Direction */ 
;;;264      CRYP->CR &= ~CRYP_CR_ALGODIR;
00005a  4906              LDR      r1,|L13.116|
00005c  6809              LDR      r1,[r1,#0]
00005e  f0210104          BIC      r1,r1,#4
000062  4a04              LDR      r2,|L13.116|
000064  6011              STR      r1,[r2,#0]
;;;265      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
000066  4611              MOV      r1,r2
000068  6809              LDR      r1,[r1,#0]
00006a  6802              LDR      r2,[r0,#0]
00006c  4311              ORRS     r1,r1,r2
00006e  4a01              LDR      r2,|L13.116|
000070  6011              STR      r1,[r2,#0]
;;;266    }
000072  4770              BX       lr
;;;267    
                          ENDP

                  |L13.116|
                          DCD      0x50060000
                  |L13.120|
                          DCD      0xfff7ffc7

                          AREA ||i.CRYP_KeyInit||, CODE, READONLY, ALIGN=2

                  CRYP_KeyInit PROC
;;;295      */
;;;296    void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
000000  4a08              LDR      r2,|L14.36|
;;;297    {
;;;298      /* Key Initialisation */
;;;299      CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
000002  6801              LDR      r1,[r0,#0]
000004  6211              STR      r1,[r2,#0x20]
;;;300      CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
000006  6841              LDR      r1,[r0,#4]
000008  6251              STR      r1,[r2,#0x24]
;;;301      CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
00000a  6881              LDR      r1,[r0,#8]
00000c  6291              STR      r1,[r2,#0x28]
;;;302      CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
00000e  68c1              LDR      r1,[r0,#0xc]
000010  62d1              STR      r1,[r2,#0x2c]
;;;303      CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
000012  6901              LDR      r1,[r0,#0x10]
000014  6311              STR      r1,[r2,#0x30]
;;;304      CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
000016  6941              LDR      r1,[r0,#0x14]
000018  6351              STR      r1,[r2,#0x34]
;;;305      CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
00001a  6981              LDR      r1,[r0,#0x18]
00001c  6391              STR      r1,[r2,#0x38]
;;;306      CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
00001e  69c1              LDR      r1,[r0,#0x1c]
000020  63d1              STR      r1,[r2,#0x3c]
;;;307    }
000022  4770              BX       lr
;;;308    
                          ENDP

                  |L14.36|
                          DCD      0x50060000

                          AREA ||i.CRYP_KeyStructInit||, CODE, READONLY, ALIGN=1

                  CRYP_KeyStructInit PROC
;;;314      */
;;;315    void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
000000  2100              MOVS     r1,#0
;;;316    {
;;;317      CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
000002  6001              STR      r1,[r0,#0]
;;;318      CRYP_KeyInitStruct->CRYP_Key0Right = 0;
000004  6041              STR      r1,[r0,#4]
;;;319      CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
000006  6081              STR      r1,[r0,#8]
;;;320      CRYP_KeyInitStruct->CRYP_Key1Right = 0;
000008  60c1              STR      r1,[r0,#0xc]
;;;321      CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
00000a  6101              STR      r1,[r0,#0x10]
;;;322      CRYP_KeyInitStruct->CRYP_Key2Right = 0;
00000c  6141              STR      r1,[r0,#0x14]
;;;323      CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
00000e  6181              STR      r1,[r0,#0x18]
;;;324      CRYP_KeyInitStruct->CRYP_Key3Right = 0;
000010  61c1              STR      r1,[r0,#0x1c]
;;;325    }
000012  4770              BX       lr
;;;326    /**
                          ENDP


                          AREA ||i.CRYP_PhaseConfig||, CODE, READONLY, ALIGN=2

                  CRYP_PhaseConfig PROC
;;;365      */
;;;366    void CRYP_PhaseConfig(uint32_t CRYP_Phase)
000000  4601              MOV      r1,r0
;;;367    { uint32_t tempcr = 0;
000002  2000              MOVS     r0,#0
;;;368    
;;;369      /* Check the parameter */
;;;370      assert_param(IS_CRYP_PHASE(CRYP_Phase));
;;;371    
;;;372      /* Get the CR register */
;;;373      tempcr = CRYP->CR;
000004  4a03              LDR      r2,|L16.20|
000006  6810              LDR      r0,[r2,#0]
;;;374      
;;;375      /* Reset the phase configuration bits: GCMP_CCMPH */
;;;376      tempcr &= (uint32_t)(~CRYP_CR_GCM_CCMPH);
000008  f4203040          BIC      r0,r0,#0x30000
;;;377      /* Set the selected phase */
;;;378      tempcr |= (uint32_t)CRYP_Phase;
00000c  4308              ORRS     r0,r0,r1
;;;379    
;;;380      /* Set the CR register */ 
;;;381      CRYP->CR = tempcr;    
00000e  6010              STR      r0,[r2,#0]
;;;382    }
000010  4770              BX       lr
;;;383    
                          ENDP

000012  0000              DCW      0x0000
                  |L16.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_RestoreContext||, CODE, READONLY, ALIGN=2

                  CRYP_RestoreContext PROC
;;;601      */
;;;602    void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
000000  4a23              LDR      r2,|L17.144|
;;;603    {
;;;604    
;;;605      /* Configure the processor with the saved configuration */
;;;606      CRYP->CR = CRYP_ContextRestore->CR_CurrentConfig;
000002  6801              LDR      r1,[r0,#0]
000004  6011              STR      r1,[r2,#0]
;;;607    
;;;608      /* restore The key value */
;;;609      CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
000006  6941              LDR      r1,[r0,#0x14]
000008  6211              STR      r1,[r2,#0x20]
;;;610      CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
00000a  6981              LDR      r1,[r0,#0x18]
00000c  6251              STR      r1,[r2,#0x24]
;;;611      CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
00000e  69c1              LDR      r1,[r0,#0x1c]
000010  6291              STR      r1,[r2,#0x28]
;;;612      CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
000012  6a01              LDR      r1,[r0,#0x20]
000014  62d1              STR      r1,[r2,#0x2c]
;;;613      CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
000016  6a41              LDR      r1,[r0,#0x24]
000018  6311              STR      r1,[r2,#0x30]
;;;614      CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  6351              STR      r1,[r2,#0x34]
;;;615      CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
00001e  6ac1              LDR      r1,[r0,#0x2c]
000020  6391              STR      r1,[r2,#0x38]
;;;616      CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
000022  6b01              LDR      r1,[r0,#0x30]
000024  63d1              STR      r1,[r2,#0x3c]
;;;617    
;;;618      /* and the initialization vectors. */
;;;619      CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
000026  6841              LDR      r1,[r0,#4]
000028  6411              STR      r1,[r2,#0x40]
;;;620      CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
00002a  6881              LDR      r1,[r0,#8]
00002c  6451              STR      r1,[r2,#0x44]
;;;621      CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
00002e  68c1              LDR      r1,[r0,#0xc]
000030  6491              STR      r1,[r2,#0x48]
;;;622      CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
000032  6901              LDR      r1,[r0,#0x10]
000034  64d1              STR      r1,[r2,#0x4c]
;;;623    
;;;624      /* Restore the content of context swap registers */
;;;625      CRYP->CSGCMCCM0R = CRYP_ContextRestore->CRYP_CSGCMCCMR[0];
000036  6b41              LDR      r1,[r0,#0x34]
000038  6511              STR      r1,[r2,#0x50]
;;;626      CRYP->CSGCMCCM1R = CRYP_ContextRestore->CRYP_CSGCMCCMR[1];
00003a  6b81              LDR      r1,[r0,#0x38]
00003c  6551              STR      r1,[r2,#0x54]
;;;627      CRYP->CSGCMCCM2R = CRYP_ContextRestore->CRYP_CSGCMCCMR[2];
00003e  6bc1              LDR      r1,[r0,#0x3c]
000040  6591              STR      r1,[r2,#0x58]
;;;628      CRYP->CSGCMCCM3R = CRYP_ContextRestore->CRYP_CSGCMCCMR[3];
000042  6c01              LDR      r1,[r0,#0x40]
000044  65d1              STR      r1,[r2,#0x5c]
;;;629      CRYP->CSGCMCCM4R = CRYP_ContextRestore->CRYP_CSGCMCCMR[4];
000046  6c41              LDR      r1,[r0,#0x44]
000048  6611              STR      r1,[r2,#0x60]
;;;630      CRYP->CSGCMCCM5R = CRYP_ContextRestore->CRYP_CSGCMCCMR[5];
00004a  6c81              LDR      r1,[r0,#0x48]
00004c  6651              STR      r1,[r2,#0x64]
;;;631      CRYP->CSGCMCCM6R = CRYP_ContextRestore->CRYP_CSGCMCCMR[6];
00004e  6cc1              LDR      r1,[r0,#0x4c]
000050  6691              STR      r1,[r2,#0x68]
;;;632      CRYP->CSGCMCCM7R = CRYP_ContextRestore->CRYP_CSGCMCCMR[7];
000052  6d01              LDR      r1,[r0,#0x50]
000054  66d1              STR      r1,[r2,#0x6c]
;;;633      
;;;634      CRYP->CSGCM0R = CRYP_ContextRestore->CRYP_CSGCMR[0];
000056  6d41              LDR      r1,[r0,#0x54]
000058  6711              STR      r1,[r2,#0x70]
;;;635      CRYP->CSGCM1R = CRYP_ContextRestore->CRYP_CSGCMR[1];
00005a  6d81              LDR      r1,[r0,#0x58]
00005c  6751              STR      r1,[r2,#0x74]
;;;636      CRYP->CSGCM2R = CRYP_ContextRestore->CRYP_CSGCMR[2];
00005e  6dc1              LDR      r1,[r0,#0x5c]
000060  6791              STR      r1,[r2,#0x78]
;;;637      CRYP->CSGCM3R = CRYP_ContextRestore->CRYP_CSGCMR[3];
000062  6e01              LDR      r1,[r0,#0x60]
000064  67d1              STR      r1,[r2,#0x7c]
;;;638      CRYP->CSGCM4R = CRYP_ContextRestore->CRYP_CSGCMR[4];
000066  4a0a              LDR      r2,|L17.144|
000068  3280              ADDS     r2,r2,#0x80
00006a  6e41              LDR      r1,[r0,#0x64]
00006c  6011              STR      r1,[r2,#0]
;;;639      CRYP->CSGCM5R = CRYP_ContextRestore->CRYP_CSGCMR[5];
00006e  4a08              LDR      r2,|L17.144|
000070  6e81              LDR      r1,[r0,#0x68]
000072  f8c21084          STR      r1,[r2,#0x84]
;;;640      CRYP->CSGCM6R = CRYP_ContextRestore->CRYP_CSGCMR[6];
000076  6ec1              LDR      r1,[r0,#0x6c]
000078  f8c21088          STR      r1,[r2,#0x88]
;;;641      CRYP->CSGCM7R = CRYP_ContextRestore->CRYP_CSGCMR[7];
00007c  6f01              LDR      r1,[r0,#0x70]
00007e  f8c2108c          STR      r1,[r2,#0x8c]
;;;642      
;;;643      /* Enable the cryptographic processor */
;;;644      CRYP->CR |= CRYP_CR_CRYPEN;
000082  4611              MOV      r1,r2
000084  6809              LDR      r1,[r1,#0]
000086  f4414100          ORR      r1,r1,#0x8000
00008a  6011              STR      r1,[r2,#0]
;;;645    }
00008c  4770              BX       lr
;;;646    /**
                          ENDP

00008e  0000              DCW      0x0000
                  |L17.144|
                          DCD      0x50060000

                          AREA ||i.CRYP_SaveContext||, CODE, READONLY, ALIGN=2

                  CRYP_SaveContext PROC
;;;496      */
;;;497    ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
000000  b578              PUSH     {r3-r6,lr}
;;;498                                 CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
;;;499    {
000002  4602              MOV      r2,r0
;;;500      __IO uint32_t timeout = 0;
000004  2500              MOVS     r5,#0
000006  9500              STR      r5,[sp,#0]
;;;501      uint32_t ckeckmask = 0, bitstatus;    
000008  2300              MOVS     r3,#0
;;;502      ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;503    
;;;504      /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
;;;505      CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
00000c  4d3c              LDR      r5,|L18.256|
00000e  692d              LDR      r5,[r5,#0x10]
000010  f0250501          BIC      r5,r5,#1
000014  4e3a              LDR      r6,|L18.256|
000016  6135              STR      r5,[r6,#0x10]
;;;506        
;;;507      /* Wait until both the IN and OUT FIFOs are empty  
;;;508        (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
;;;509         BUSY bit is cleared. */
;;;510    
;;;511      if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
000018  4635              MOV      r5,r6
00001a  682d              LDR      r5,[r5,#0]
00001c  f0050508          AND      r5,r5,#8
000020  b10d              CBZ      r5,|L18.38|
;;;512      { 
;;;513        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
000022  2311              MOVS     r3,#0x11
000024  e000              B        |L18.40|
                  |L18.38|
;;;514      }
;;;515      else /* AES or DES */
;;;516      {
;;;517        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
000026  2315              MOVS     r3,#0x15
                  |L18.40|
;;;518      }           
;;;519       
;;;520      do 
000028  bf00              NOP      
                  |L18.42|
;;;521      {
;;;522        bitstatus = CRYP->SR & ckeckmask;
00002a  4d35              LDR      r5,|L18.256|
00002c  686d              LDR      r5,[r5,#4]
00002e  ea050403          AND      r4,r5,r3
;;;523        timeout++;
000032  9d00              LDR      r5,[sp,#0]
000034  1c6d              ADDS     r5,r5,#1
000036  9500              STR      r5,[sp,#0]
;;;524      }
;;;525      while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
000038  f64f76ff          MOV      r6,#0xffff
00003c  9d00              LDR      r5,[sp,#0]
00003e  42b5              CMP      r5,r6
000040  d001              BEQ      |L18.70|
000042  2c01              CMP      r4,#1
000044  d1f1              BNE      |L18.42|
                  |L18.70|
;;;526         
;;;527      if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
000046  4d2e              LDR      r5,|L18.256|
000048  686d              LDR      r5,[r5,#4]
00004a  401d              ANDS     r5,r5,r3
00004c  2d01              CMP      r5,#1
00004e  d001              BEQ      |L18.84|
;;;528      {
;;;529        status = ERROR;
000050  2000              MOVS     r0,#0
000052  e054              B        |L18.254|
                  |L18.84|
;;;530      }
;;;531      else
;;;532      {      
;;;533        /* Stop DMA transfers on the OUT FIFO by 
;;;534           - writing the DOEN bit to 0 in the CRYP_DMACR register 
;;;535           - and clear the CRYPEN bit. */
;;;536    
;;;537        CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
000054  4d2a              LDR      r5,|L18.256|
000056  692d              LDR      r5,[r5,#0x10]
000058  f0250502          BIC      r5,r5,#2
00005c  4e28              LDR      r6,|L18.256|
00005e  6135              STR      r5,[r6,#0x10]
;;;538        CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
000060  4635              MOV      r5,r6
000062  682d              LDR      r5,[r5,#0]
000064  f4254500          BIC      r5,r5,#0x8000
000068  6035              STR      r5,[r6,#0]
;;;539    
;;;540        /* Save the current configuration (bit 19, bit[17:16] and bits [9:2] in the CRYP_CR register) */
;;;541        CRYP_ContextSave->CR_CurrentConfig  = CRYP->CR & (CRYP_CR_GCM_CCMPH |
00006a  4635              MOV      r5,r6
00006c  682d              LDR      r5,[r5,#0]
00006e  4e25              LDR      r6,|L18.260|
000070  4035              ANDS     r5,r5,r6
000072  6015              STR      r5,[r2,#0]
;;;542                                                          CRYP_CR_KEYSIZE  |
;;;543                                                          CRYP_CR_DATATYPE |
;;;544                                                          CRYP_CR_ALGOMODE |
;;;545                                                          CRYP_CR_ALGODIR);
;;;546    
;;;547        /* and, if not in ECB mode, the initialization vectors. */
;;;548        CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
000074  4d22              LDR      r5,|L18.256|
000076  6c2d              LDR      r5,[r5,#0x40]
000078  6055              STR      r5,[r2,#4]
;;;549        CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
00007a  4d21              LDR      r5,|L18.256|
00007c  6c6d              LDR      r5,[r5,#0x44]
00007e  6095              STR      r5,[r2,#8]
;;;550        CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
000080  4d1f              LDR      r5,|L18.256|
000082  6cad              LDR      r5,[r5,#0x48]
000084  60d5              STR      r5,[r2,#0xc]
;;;551        CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
000086  4d1e              LDR      r5,|L18.256|
000088  6ced              LDR      r5,[r5,#0x4c]
00008a  6115              STR      r5,[r2,#0x10]
;;;552    
;;;553        /* save The key value */
;;;554        CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
00008c  680d              LDR      r5,[r1,#0]
00008e  6155              STR      r5,[r2,#0x14]
;;;555        CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
000090  684d              LDR      r5,[r1,#4]
000092  6195              STR      r5,[r2,#0x18]
;;;556        CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
000094  688d              LDR      r5,[r1,#8]
000096  61d5              STR      r5,[r2,#0x1c]
;;;557        CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
000098  68cd              LDR      r5,[r1,#0xc]
00009a  6215              STR      r5,[r2,#0x20]
;;;558        CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
00009c  690d              LDR      r5,[r1,#0x10]
00009e  6255              STR      r5,[r2,#0x24]
;;;559        CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
0000a0  694d              LDR      r5,[r1,#0x14]
0000a2  6295              STR      r5,[r2,#0x28]
;;;560        CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
0000a4  698d              LDR      r5,[r1,#0x18]
0000a6  62d5              STR      r5,[r2,#0x2c]
;;;561        CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
0000a8  69cd              LDR      r5,[r1,#0x1c]
0000aa  6315              STR      r5,[r2,#0x30]
;;;562    
;;;563        /* Save the content of context swap registers */
;;;564        CRYP_ContextSave->CRYP_CSGCMCCMR[0] = CRYP->CSGCMCCM0R;
0000ac  4d14              LDR      r5,|L18.256|
0000ae  6d2d              LDR      r5,[r5,#0x50]
0000b0  6355              STR      r5,[r2,#0x34]
;;;565        CRYP_ContextSave->CRYP_CSGCMCCMR[1] = CRYP->CSGCMCCM1R;
0000b2  4d13              LDR      r5,|L18.256|
0000b4  6d6e              LDR      r6,[r5,#0x54]
0000b6  6396              STR      r6,[r2,#0x38]
;;;566        CRYP_ContextSave->CRYP_CSGCMCCMR[2] = CRYP->CSGCMCCM2R;
0000b8  6dae              LDR      r6,[r5,#0x58]
0000ba  63d6              STR      r6,[r2,#0x3c]
;;;567        CRYP_ContextSave->CRYP_CSGCMCCMR[3] = CRYP->CSGCMCCM3R;
0000bc  6dee              LDR      r6,[r5,#0x5c]
0000be  6416              STR      r6,[r2,#0x40]
;;;568        CRYP_ContextSave->CRYP_CSGCMCCMR[4] = CRYP->CSGCMCCM4R;
0000c0  6e2e              LDR      r6,[r5,#0x60]
0000c2  6456              STR      r6,[r2,#0x44]
;;;569        CRYP_ContextSave->CRYP_CSGCMCCMR[5] = CRYP->CSGCMCCM5R;
0000c4  6e6e              LDR      r6,[r5,#0x64]
0000c6  6496              STR      r6,[r2,#0x48]
;;;570        CRYP_ContextSave->CRYP_CSGCMCCMR[6] = CRYP->CSGCMCCM6R;
0000c8  6eae              LDR      r6,[r5,#0x68]
0000ca  64d6              STR      r6,[r2,#0x4c]
;;;571        CRYP_ContextSave->CRYP_CSGCMCCMR[7] = CRYP->CSGCMCCM7R;
0000cc  6eee              LDR      r6,[r5,#0x6c]
0000ce  6516              STR      r6,[r2,#0x50]
;;;572        
;;;573        CRYP_ContextSave->CRYP_CSGCMR[0] = CRYP->CSGCM0R;
0000d0  6f2d              LDR      r5,[r5,#0x70]
0000d2  6555              STR      r5,[r2,#0x54]
;;;574        CRYP_ContextSave->CRYP_CSGCMR[1] = CRYP->CSGCM1R;
0000d4  4d0a              LDR      r5,|L18.256|
0000d6  6f6e              LDR      r6,[r5,#0x74]
0000d8  6596              STR      r6,[r2,#0x58]
;;;575        CRYP_ContextSave->CRYP_CSGCMR[2] = CRYP->CSGCM2R;
0000da  6fae              LDR      r6,[r5,#0x78]
0000dc  65d6              STR      r6,[r2,#0x5c]
;;;576        CRYP_ContextSave->CRYP_CSGCMR[3] = CRYP->CSGCM3R;
0000de  6fee              LDR      r6,[r5,#0x7c]
0000e0  6616              STR      r6,[r2,#0x60]
;;;577        CRYP_ContextSave->CRYP_CSGCMR[4] = CRYP->CSGCM4R;
0000e2  4d07              LDR      r5,|L18.256|
0000e4  3580              ADDS     r5,r5,#0x80
0000e6  682e              LDR      r6,[r5,#0]
0000e8  6656              STR      r6,[r2,#0x64]
;;;578        CRYP_ContextSave->CRYP_CSGCMR[5] = CRYP->CSGCM5R;
0000ea  1d2d              ADDS     r5,r5,#4
0000ec  682e              LDR      r6,[r5,#0]
0000ee  6696              STR      r6,[r2,#0x68]
;;;579        CRYP_ContextSave->CRYP_CSGCMR[6] = CRYP->CSGCM6R;
0000f0  1d2d              ADDS     r5,r5,#4
0000f2  682e              LDR      r6,[r5,#0]
0000f4  66d6              STR      r6,[r2,#0x6c]
;;;580        CRYP_ContextSave->CRYP_CSGCMR[7] = CRYP->CSGCM7R;
0000f6  1d2d              ADDS     r5,r5,#4
0000f8  682e              LDR      r6,[r5,#0]
0000fa  6716              STR      r6,[r2,#0x70]
;;;581        
;;;582       /* When needed, save the DMA status (pointers for IN and OUT messages, 
;;;583          number of remaining bytes, etc.) */
;;;584         
;;;585        status = SUCCESS;
0000fc  2001              MOVS     r0,#1
                  |L18.254|
;;;586      }
;;;587    
;;;588       return status;
;;;589    }
0000fe  bd78              POP      {r3-r6,pc}
;;;590    
                          ENDP

                  |L18.256|
                          DCD      0x50060000
                  |L18.260|
                          DCD      0x000b03fc

                          AREA ||i.CRYP_StructInit||, CODE, READONLY, ALIGN=1

                  CRYP_StructInit PROC
;;;273      */
;;;274    void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
000000  2100              MOVS     r1,#0
;;;275    {
;;;276      /* Initialize the CRYP_AlgoDir member */
;;;277      CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
000002  6001              STR      r1,[r0,#0]
;;;278    
;;;279      /* initialize the CRYP_AlgoMode member */
;;;280      CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
000004  6041              STR      r1,[r0,#4]
;;;281    
;;;282      /* initialize the CRYP_DataType member */
;;;283      CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
000006  6081              STR      r1,[r0,#8]
;;;284      
;;;285      /* Initialize the CRYP_KeySize member */
;;;286      CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
000008  60c1              STR      r1,[r0,#0xc]
;;;287    }
00000a  4770              BX       lr
;;;288    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_cryp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_cryp_c_459f21d3____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___16_stm32f4xx_cryp_c_459f21d3____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_cryp_c_459f21d3____REVSH|
#line 153
|__asm___16_stm32f4xx_cryp_c_459f21d3____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_cryp_c_459f21d3____RRX|
#line 328
|__asm___16_stm32f4xx_cryp_c_459f21d3____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
