; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_dma2d.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_dma2d.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_dma2d.crf ..\FWLIB\src\stm32f4xx_dma2d.c]
                          THUMB

                          AREA ||i.DMA2D_AbortTransfer||, CODE, READONLY, ALIGN=2

                  DMA2D_AbortTransfer PROC
;;;259    
;;;260    void DMA2D_AbortTransfer(void)
000000  4803              LDR      r0,|L1.16|
;;;261    {
;;;262        /* Start DMA2D transfer by setting START bit */
;;;263        DMA2D->CR |= (uint32_t)DMA2D_CR_ABORT;
000002  6800              LDR      r0,[r0,#0]
000004  f0400004          ORR      r0,r0,#4
000008  4901              LDR      r1,|L1.16|
00000a  6008              STR      r0,[r1,#0]
;;;264    
;;;265    }
00000c  4770              BX       lr
;;;266    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_BGConfig||, CODE, READONLY, ALIGN=2

                  DMA2D_BGConfig PROC
;;;394      */
;;;395    void DMA2D_BGConfig(DMA2D_BG_InitTypeDef* DMA2D_BG_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;396    {
;;;397    
;;;398      uint32_t bg_clutcolormode = 0;
000002  2100              MOVS     r1,#0
;;;399      uint32_t bg_clutsize = 0;
000004  2200              MOVS     r2,#0
;;;400      uint32_t bg_alpha_mode = 0;
000006  2300              MOVS     r3,#0
;;;401      uint32_t bg_alphavalue = 0;
000008  2400              MOVS     r4,#0
;;;402      uint32_t bg_colorgreen = 0;
00000a  2500              MOVS     r5,#0
;;;403      uint32_t bg_colorred = 0;
00000c  2600              MOVS     r6,#0
;;;404    
;;;405      assert_param(IS_DMA2D_BGO(DMA2D_BG_InitStruct->DMA2D_BGO));
;;;406      assert_param(IS_DMA2D_BGCM(DMA2D_BG_InitStruct->DMA2D_BGCM));
;;;407      assert_param(IS_DMA2D_BG_CLUT_CM(DMA2D_BG_InitStruct->DMA2D_BG_CLUT_CM));
;;;408      assert_param(IS_DMA2D_BG_CLUT_SIZE(DMA2D_BG_InitStruct->DMA2D_BG_CLUT_SIZE));
;;;409      assert_param(IS_DMA2D_BG_ALPHA_MODE(DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_MODE));
;;;410      assert_param(IS_DMA2D_BG_ALPHA_VALUE(DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_VALUE));
;;;411      assert_param(IS_DMA2D_BGC_BLUE(DMA2D_BG_InitStruct->DMA2D_BGC_BLUE));
;;;412      assert_param(IS_DMA2D_BGC_GREEN(DMA2D_BG_InitStruct->DMA2D_BGC_GREEN));
;;;413      assert_param(IS_DMA2D_BGC_RED(DMA2D_BG_InitStruct->DMA2D_BGC_RED));
;;;414    
;;;415      /* Configures the BG memory address */
;;;416      DMA2D->BGMAR = (DMA2D_BG_InitStruct->DMA2D_BGMA);
00000e  f8dfc0a0          LDR      r12,|L2.176|
000012  6807              LDR      r7,[r0,#0]
000014  f8cc7014          STR      r7,[r12,#0x14]
;;;417    
;;;418      /* Configures the BG offset */
;;;419      DMA2D->BGOR &= ~(uint32_t)DMA2D_BGOR_LO;
000018  4667              MOV      r7,r12
00001a  69bf              LDR      r7,[r7,#0x18]
00001c  f36f070d          BFC      r7,#0,#14
000020  f8cc7018          STR      r7,[r12,#0x18]
;;;420      DMA2D->BGOR |= (DMA2D_BG_InitStruct->DMA2D_BGO);
000024  4667              MOV      r7,r12
000026  69bf              LDR      r7,[r7,#0x18]
000028  f8d0c004          LDR      r12,[r0,#4]
00002c  ea47070c          ORR      r7,r7,r12
000030  f8dfc07c          LDR      r12,|L2.176|
000034  f8cc7018          STR      r7,[r12,#0x18]
;;;421    
;;;422      /* Configures background Pixel Format Convertor */
;;;423      DMA2D->BGPFCCR &= (uint32_t)PFCCR_MASK;
000038  4667              MOV      r7,r12
00003a  6a7f              LDR      r7,[r7,#0x24]
00003c  f8dfc074          LDR      r12,|L2.180|
000040  ea07070c          AND      r7,r7,r12
000044  f8dfc068          LDR      r12,|L2.176|
000048  f8cc7024          STR      r7,[r12,#0x24]
;;;424      bg_clutcolormode = DMA2D_BG_InitStruct->DMA2D_BG_CLUT_CM << 4;
00004c  68c7              LDR      r7,[r0,#0xc]
00004e  0139              LSLS     r1,r7,#4
;;;425      bg_clutsize = DMA2D_BG_InitStruct->DMA2D_BG_CLUT_SIZE << 8;
000050  6907              LDR      r7,[r0,#0x10]
000052  023a              LSLS     r2,r7,#8
;;;426      bg_alpha_mode = DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_MODE << 16;
000054  8a87              LDRH     r7,[r0,#0x14]
000056  043b              LSLS     r3,r7,#16
;;;427      bg_alphavalue = DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_VALUE << 24;
000058  7e07              LDRB     r7,[r0,#0x18]
00005a  063c              LSLS     r4,r7,#24
;;;428      DMA2D->BGPFCCR |= (DMA2D_BG_InitStruct->DMA2D_BGCM | bg_clutcolormode | bg_clutsize | \
00005c  4667              MOV      r7,r12
00005e  f8d7c024          LDR      r12,[r7,#0x24]
000062  6887              LDR      r7,[r0,#8]
000064  430f              ORRS     r7,r7,r1
000066  4317              ORRS     r7,r7,r2
000068  431f              ORRS     r7,r7,r3
00006a  4327              ORRS     r7,r7,r4
00006c  ea4c0c07          ORR      r12,r12,r7
000070  4f0f              LDR      r7,|L2.176|
000072  f8c7c024          STR      r12,[r7,#0x24]
;;;429                        bg_alpha_mode | bg_alphavalue);
;;;430    
;;;431      /* Configures background color */
;;;432      DMA2D->BGCOLR &= ~(DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | DMA2D_BGCOLR_RED);
000076  6abf              LDR      r7,[r7,#0x28]
000078  f007477f          AND      r7,r7,#0xff000000
00007c  f8dfc030          LDR      r12,|L2.176|
000080  f8cc7028          STR      r7,[r12,#0x28]
;;;433      bg_colorgreen = DMA2D_BG_InitStruct->DMA2D_BGC_GREEN << 8;
000084  6a07              LDR      r7,[r0,#0x20]
000086  023d              LSLS     r5,r7,#8
;;;434      bg_colorred = DMA2D_BG_InitStruct->DMA2D_BGC_RED << 16;
000088  8c87              LDRH     r7,[r0,#0x24]
00008a  043e              LSLS     r6,r7,#16
;;;435      DMA2D->BGCOLR |= (DMA2D_BG_InitStruct->DMA2D_BGC_BLUE | bg_colorgreen | bg_colorred);
00008c  4667              MOV      r7,r12
00008e  f8d7c028          LDR      r12,[r7,#0x28]
000092  69c7              LDR      r7,[r0,#0x1c]
000094  432f              ORRS     r7,r7,r5
000096  4337              ORRS     r7,r7,r6
000098  ea4c0c07          ORR      r12,r12,r7
00009c  4f04              LDR      r7,|L2.176|
00009e  f8c7c028          STR      r12,[r7,#0x28]
;;;436      
;;;437      /* Configures background CLUT memory address */
;;;438      DMA2D->BGCMAR = DMA2D_BG_InitStruct->DMA2D_BGCMAR;
0000a2  f8dfc00c          LDR      r12,|L2.176|
0000a6  6a87              LDR      r7,[r0,#0x28]
0000a8  f8cc7030          STR      r7,[r12,#0x30]
;;;439    
;;;440    }
0000ac  bdf0              POP      {r4-r7,pc}
;;;441    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L2.176|
                          DCD      0x4002b000
                  |L2.180|
                          DCD      0x00fc00c0

                          AREA ||i.DMA2D_BGStart||, CODE, READONLY, ALIGN=2

                  DMA2D_BGStart PROC
;;;514      
;;;515    void DMA2D_BGStart(FunctionalState NewState) 
000000  b130              CBZ      r0,|L3.16|
;;;516    {
;;;517      /* Check the parameters */
;;;518      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;519      
;;;520      if (NewState != DISABLE)
;;;521      {
;;;522        /* Start the automatic loading of the CLUT */
;;;523        DMA2D->BGPFCCR |= DMA2D_BGPFCCR_START;
000002  4907              LDR      r1,|L3.32|
000004  6a49              LDR      r1,[r1,#0x24]
000006  f0410120          ORR      r1,r1,#0x20
00000a  4a05              LDR      r2,|L3.32|
00000c  6251              STR      r1,[r2,#0x24]
00000e  e005              B        |L3.28|
                  |L3.16|
;;;524      }
;;;525      else
;;;526      {
;;;527        /* abort the transfer */
;;;528        DMA2D->BGPFCCR &= (uint32_t)~DMA2D_BGPFCCR_START;
000010  4903              LDR      r1,|L3.32|
000012  6a49              LDR      r1,[r1,#0x24]
000014  f0210120          BIC      r1,r1,#0x20
000018  4a01              LDR      r2,|L3.32|
00001a  6251              STR      r1,[r2,#0x24]
                  |L3.28|
;;;529      }
;;;530    }
00001c  4770              BX       lr
;;;531    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_BG_StructInit||, CODE, READONLY, ALIGN=1

                  DMA2D_BG_StructInit PROC
;;;447      */
;;;448    void DMA2D_BG_StructInit(DMA2D_BG_InitTypeDef* DMA2D_BG_InitStruct)
000000  2100              MOVS     r1,#0
;;;449    {
;;;450      /*!< Initialize the DMA2D background memory address */
;;;451      DMA2D_BG_InitStruct->DMA2D_BGMA = 0x00;
000002  6001              STR      r1,[r0,#0]
;;;452    
;;;453      /*!< Initialize the DMA2D background offset */
;;;454      DMA2D_BG_InitStruct->DMA2D_BGO = 0x00;
000004  6041              STR      r1,[r0,#4]
;;;455    
;;;456      /*!< Initialize the DMA2D background color mode */
;;;457      DMA2D_BG_InitStruct->DMA2D_BGCM = CM_ARGB8888;
000006  6081              STR      r1,[r0,#8]
;;;458    
;;;459      /*!< Initialize the DMA2D background CLUT color mode */
;;;460      DMA2D_BG_InitStruct->DMA2D_BG_CLUT_CM = CLUT_CM_ARGB8888;
000008  60c1              STR      r1,[r0,#0xc]
;;;461    
;;;462      /*!< Initialize the DMA2D background CLUT size */
;;;463      DMA2D_BG_InitStruct->DMA2D_BG_CLUT_SIZE = 0x00;
00000a  6101              STR      r1,[r0,#0x10]
;;;464    
;;;465      /*!< Initialize the DMA2D background alpha mode */
;;;466      DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_MODE = NO_MODIF_ALPHA_VALUE;
00000c  6141              STR      r1,[r0,#0x14]
;;;467    
;;;468      /*!< Initialize the DMA2D background alpha value */
;;;469      DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_VALUE = 0x00;
00000e  6181              STR      r1,[r0,#0x18]
;;;470    
;;;471      /*!< Initialize the DMA2D background blue value */
;;;472      DMA2D_BG_InitStruct->DMA2D_BGC_BLUE = 0x00;
000010  61c1              STR      r1,[r0,#0x1c]
;;;473    
;;;474      /*!< Initialize the DMA2D background green value */
;;;475      DMA2D_BG_InitStruct->DMA2D_BGC_GREEN = 0x00;
000012  6201              STR      r1,[r0,#0x20]
;;;476    
;;;477      /*!< Initialize the DMA2D background red value */
;;;478      DMA2D_BG_InitStruct->DMA2D_BGC_RED = 0x00;
000014  6241              STR      r1,[r0,#0x24]
;;;479    
;;;480      /*!< Initialize the DMA2D background CLUT memory address */
;;;481      DMA2D_BG_InitStruct->DMA2D_BGCMAR = 0x00;
000016  6281              STR      r1,[r0,#0x28]
;;;482    }
000018  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i.DMA2D_ClearFlag||, CODE, READONLY, ALIGN=2

                  DMA2D_ClearFlag PROC
;;;696      */
;;;697    void DMA2D_ClearFlag(uint32_t DMA2D_FLAG)
000000  4901              LDR      r1,|L5.8|
;;;698    {
;;;699      /* Check the parameters */
;;;700      assert_param(IS_DMA2D_GET_FLAG(DMA2D_FLAG));
;;;701        
;;;702      /* Clear the corresponding DMA2D flag */
;;;703      DMA2D->IFCR = (uint32_t)DMA2D_FLAG;
000002  6088              STR      r0,[r1,#8]
;;;704    }
000004  4770              BX       lr
;;;705    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DMA2D_ClearITPendingBit PROC
;;;757      */
;;;758    void DMA2D_ClearITPendingBit(uint32_t DMA2D_IT)
000000  0a00              LSRS     r0,r0,#8
;;;759    {
;;;760      /* Check the parameters */
;;;761      assert_param(IS_DMA2D_IT(DMA2D_IT));
;;;762      DMA2D_IT = DMA2D_IT >> 8;
;;;763        
;;;764      /* Clear the corresponding DMA2D Interrupt */
;;;765      DMA2D->IFCR = (uint32_t)DMA2D_IT;
000002  4901              LDR      r1,|L6.8|
000004  6088              STR      r0,[r1,#8]
;;;766    }
000006  4770              BX       lr
;;;767    
                          ENDP

                  |L6.8|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_DeInit||, CODE, READONLY, ALIGN=1

                  DMA2D_DeInit PROC
;;;110    
;;;111    void DMA2D_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113      /* Enable DMA2D reset state */
;;;114      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA2D, ENABLE);
000002  2101              MOVS     r1,#1
000004  05c8              LSLS     r0,r1,#23
000006  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;115      /* Release DMA2D from reset state */
;;;116      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA2D, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f44f0000          MOV      r0,#0x800000
000010  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;117    }
000014  bd10              POP      {r4,pc}
;;;118    
                          ENDP


                          AREA ||i.DMA2D_DeadTimeConfig||, CODE, READONLY, ALIGN=2

                  DMA2D_DeadTimeConfig PROC
;;;537      */
;;;538    void DMA2D_DeadTimeConfig(uint32_t DMA2D_DeadTime, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;539    {
;;;540       uint32_t DeadTime;
;;;541    
;;;542      /* Check the parameters */
;;;543      assert_param(IS_DMA2D_DEAD_TIME(DMA2D_DeadTime));
;;;544      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;545    
;;;546      if (NewState != DISABLE)
000002  b179              CBZ      r1,|L8.36|
;;;547      {
;;;548        /* Enable and Configures the dead time */
;;;549        DMA2D->AMTCR &= (uint32_t)DEAD_MASK;
000004  4b0b              LDR      r3,|L8.52|
000006  6cdb              LDR      r3,[r3,#0x4c]
000008  f64f7401          MOV      r4,#0xff01
00000c  43a3              BICS     r3,r3,r4
00000e  4c09              LDR      r4,|L8.52|
000010  64e3              STR      r3,[r4,#0x4c]
;;;550        DeadTime = DMA2D_DeadTime << 8;
000012  0202              LSLS     r2,r0,#8
;;;551        DMA2D->AMTCR |= (DeadTime | DMA2D_AMTCR_EN);
000014  4623              MOV      r3,r4
000016  6cdb              LDR      r3,[r3,#0x4c]
000018  f0420401          ORR      r4,r2,#1
00001c  4323              ORRS     r3,r3,r4
00001e  4c05              LDR      r4,|L8.52|
000020  64e3              STR      r3,[r4,#0x4c]
000022  e005              B        |L8.48|
                  |L8.36|
;;;552      }
;;;553      else
;;;554      {
;;;555         DMA2D->AMTCR &= ~(uint32_t)DMA2D_AMTCR_EN;
000024  4b03              LDR      r3,|L8.52|
000026  6cdb              LDR      r3,[r3,#0x4c]
000028  f0230301          BIC      r3,r3,#1
00002c  4c01              LDR      r4,|L8.52|
00002e  64e3              STR      r3,[r4,#0x4c]
                  |L8.48|
;;;556      }
;;;557    }
000030  bd10              POP      {r4,pc}
;;;558    
                          ENDP

000032  0000              DCW      0x0000
                  |L8.52|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_FGConfig||, CODE, READONLY, ALIGN=2

                  DMA2D_FGConfig PROC
;;;297      */
;;;298    void DMA2D_FGConfig(DMA2D_FG_InitTypeDef* DMA2D_FG_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;299    {
;;;300    
;;;301      uint32_t fg_clutcolormode = 0;
000002  2100              MOVS     r1,#0
;;;302      uint32_t fg_clutsize = 0;
000004  2200              MOVS     r2,#0
;;;303      uint32_t fg_alpha_mode = 0;
000006  2300              MOVS     r3,#0
;;;304      uint32_t fg_alphavalue = 0;
000008  2400              MOVS     r4,#0
;;;305      uint32_t fg_colorgreen = 0;
00000a  2500              MOVS     r5,#0
;;;306      uint32_t fg_colorred = 0;
00000c  2600              MOVS     r6,#0
;;;307    
;;;308      assert_param(IS_DMA2D_FGO(DMA2D_FG_InitStruct->DMA2D_FGO));
;;;309      assert_param(IS_DMA2D_FGCM(DMA2D_FG_InitStruct->DMA2D_FGCM));
;;;310      assert_param(IS_DMA2D_FG_CLUT_CM(DMA2D_FG_InitStruct->DMA2D_FG_CLUT_CM));
;;;311      assert_param(IS_DMA2D_FG_CLUT_SIZE(DMA2D_FG_InitStruct->DMA2D_FG_CLUT_SIZE));
;;;312      assert_param(IS_DMA2D_FG_ALPHA_MODE(DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_MODE));
;;;313      assert_param(IS_DMA2D_FG_ALPHA_VALUE(DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_VALUE));
;;;314      assert_param(IS_DMA2D_FGC_BLUE(DMA2D_FG_InitStruct->DMA2D_FGC_BLUE));
;;;315      assert_param(IS_DMA2D_FGC_GREEN(DMA2D_FG_InitStruct->DMA2D_FGC_GREEN));
;;;316      assert_param(IS_DMA2D_FGC_RED(DMA2D_FG_InitStruct->DMA2D_FGC_RED));
;;;317    
;;;318      /* Configures the FG memory address */
;;;319      DMA2D->FGMAR = (DMA2D_FG_InitStruct->DMA2D_FGMA);
00000e  f8dfc0a0          LDR      r12,|L9.176|
000012  6807              LDR      r7,[r0,#0]
000014  f8cc700c          STR      r7,[r12,#0xc]
;;;320    
;;;321      /* Configures the FG offset */
;;;322      DMA2D->FGOR &= ~(uint32_t)DMA2D_FGOR_LO;
000018  4667              MOV      r7,r12
00001a  693f              LDR      r7,[r7,#0x10]
00001c  f36f070d          BFC      r7,#0,#14
000020  f8cc7010          STR      r7,[r12,#0x10]
;;;323      DMA2D->FGOR |= (DMA2D_FG_InitStruct->DMA2D_FGO);
000024  4667              MOV      r7,r12
000026  693f              LDR      r7,[r7,#0x10]
000028  f8d0c004          LDR      r12,[r0,#4]
00002c  ea47070c          ORR      r7,r7,r12
000030  f8dfc07c          LDR      r12,|L9.176|
000034  f8cc7010          STR      r7,[r12,#0x10]
;;;324    
;;;325      /* Configures foreground Pixel Format Convertor */
;;;326      DMA2D->FGPFCCR &= (uint32_t)PFCCR_MASK;
000038  4667              MOV      r7,r12
00003a  69ff              LDR      r7,[r7,#0x1c]
00003c  f8dfc074          LDR      r12,|L9.180|
000040  ea07070c          AND      r7,r7,r12
000044  f8dfc068          LDR      r12,|L9.176|
000048  f8cc701c          STR      r7,[r12,#0x1c]
;;;327      fg_clutcolormode = DMA2D_FG_InitStruct->DMA2D_FG_CLUT_CM << 4;
00004c  68c7              LDR      r7,[r0,#0xc]
00004e  0139              LSLS     r1,r7,#4
;;;328      fg_clutsize = DMA2D_FG_InitStruct->DMA2D_FG_CLUT_SIZE << 8;
000050  6907              LDR      r7,[r0,#0x10]
000052  023a              LSLS     r2,r7,#8
;;;329      fg_alpha_mode = DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_MODE << 16;
000054  8a87              LDRH     r7,[r0,#0x14]
000056  043b              LSLS     r3,r7,#16
;;;330      fg_alphavalue = DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_VALUE << 24;
000058  7e07              LDRB     r7,[r0,#0x18]
00005a  063c              LSLS     r4,r7,#24
;;;331      DMA2D->FGPFCCR |= (DMA2D_FG_InitStruct->DMA2D_FGCM | fg_clutcolormode | fg_clutsize | \
00005c  4667              MOV      r7,r12
00005e  f8d7c01c          LDR      r12,[r7,#0x1c]
000062  6887              LDR      r7,[r0,#8]
000064  430f              ORRS     r7,r7,r1
000066  4317              ORRS     r7,r7,r2
000068  431f              ORRS     r7,r7,r3
00006a  4327              ORRS     r7,r7,r4
00006c  ea4c0c07          ORR      r12,r12,r7
000070  4f0f              LDR      r7,|L9.176|
000072  f8c7c01c          STR      r12,[r7,#0x1c]
;;;332                        fg_alpha_mode | fg_alphavalue);
;;;333    
;;;334      /* Configures foreground color */
;;;335      DMA2D->FGCOLR &= ~(DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | DMA2D_FGCOLR_RED);
000076  6a3f              LDR      r7,[r7,#0x20]
000078  f007477f          AND      r7,r7,#0xff000000
00007c  f8dfc030          LDR      r12,|L9.176|
000080  f8cc7020          STR      r7,[r12,#0x20]
;;;336      fg_colorgreen = DMA2D_FG_InitStruct->DMA2D_FGC_GREEN << 8;
000084  6a07              LDR      r7,[r0,#0x20]
000086  023d              LSLS     r5,r7,#8
;;;337      fg_colorred = DMA2D_FG_InitStruct->DMA2D_FGC_RED << 16;
000088  8c87              LDRH     r7,[r0,#0x24]
00008a  043e              LSLS     r6,r7,#16
;;;338      DMA2D->FGCOLR |= (DMA2D_FG_InitStruct->DMA2D_FGC_BLUE | fg_colorgreen | fg_colorred);
00008c  4667              MOV      r7,r12
00008e  f8d7c020          LDR      r12,[r7,#0x20]
000092  69c7              LDR      r7,[r0,#0x1c]
000094  432f              ORRS     r7,r7,r5
000096  4337              ORRS     r7,r7,r6
000098  ea4c0c07          ORR      r12,r12,r7
00009c  4f04              LDR      r7,|L9.176|
00009e  f8c7c020          STR      r12,[r7,#0x20]
;;;339    
;;;340      /* Configures foreground CLUT memory address */
;;;341      DMA2D->FGCMAR = DMA2D_FG_InitStruct->DMA2D_FGCMAR;
0000a2  f8dfc00c          LDR      r12,|L9.176|
0000a6  6a87              LDR      r7,[r0,#0x28]
0000a8  f8cc702c          STR      r7,[r12,#0x2c]
;;;342    }
0000ac  bdf0              POP      {r4-r7,pc}
;;;343    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L9.176|
                          DCD      0x4002b000
                  |L9.180|
                          DCD      0x00fc00c0

                          AREA ||i.DMA2D_FGStart||, CODE, READONLY, ALIGN=2

                  DMA2D_FGStart PROC
;;;490    
;;;491    void DMA2D_FGStart(FunctionalState NewState) 
000000  b130              CBZ      r0,|L10.16|
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;495    
;;;496      if (NewState != DISABLE)
;;;497      {
;;;498        /* Start the automatic loading of the CLUT */
;;;499        DMA2D->FGPFCCR |= DMA2D_FGPFCCR_START;
000002  4907              LDR      r1,|L10.32|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0410120          ORR      r1,r1,#0x20
00000a  4a05              LDR      r2,|L10.32|
00000c  61d1              STR      r1,[r2,#0x1c]
00000e  e005              B        |L10.28|
                  |L10.16|
;;;500      }
;;;501      else
;;;502      {
;;;503        /* abort the transfer */
;;;504        DMA2D->FGPFCCR &= (uint32_t)~DMA2D_FGPFCCR_START;
000010  4903              LDR      r1,|L10.32|
000012  69c9              LDR      r1,[r1,#0x1c]
000014  f0210120          BIC      r1,r1,#0x20
000018  4a01              LDR      r2,|L10.32|
00001a  61d1              STR      r1,[r2,#0x1c]
                  |L10.28|
;;;505      }
;;;506    }
00001c  4770              BX       lr
;;;507    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_FG_StructInit||, CODE, READONLY, ALIGN=1

                  DMA2D_FG_StructInit PROC
;;;349      */
;;;350    void DMA2D_FG_StructInit(DMA2D_FG_InitTypeDef* DMA2D_FG_InitStruct)
000000  2100              MOVS     r1,#0
;;;351    {
;;;352      /*!< Initialize the DMA2D foreground memory address */
;;;353      DMA2D_FG_InitStruct->DMA2D_FGMA = 0x00;
000002  6001              STR      r1,[r0,#0]
;;;354    
;;;355      /*!< Initialize the DMA2D foreground offset */
;;;356      DMA2D_FG_InitStruct->DMA2D_FGO = 0x00;
000004  6041              STR      r1,[r0,#4]
;;;357    
;;;358      /*!< Initialize the DMA2D foreground color mode */
;;;359      DMA2D_FG_InitStruct->DMA2D_FGCM = CM_ARGB8888;
000006  6081              STR      r1,[r0,#8]
;;;360    
;;;361      /*!< Initialize the DMA2D foreground CLUT color mode */
;;;362      DMA2D_FG_InitStruct->DMA2D_FG_CLUT_CM = CLUT_CM_ARGB8888;
000008  60c1              STR      r1,[r0,#0xc]
;;;363    
;;;364      /*!< Initialize the DMA2D foreground CLUT size */
;;;365      DMA2D_FG_InitStruct->DMA2D_FG_CLUT_SIZE = 0x00;
00000a  6101              STR      r1,[r0,#0x10]
;;;366    
;;;367      /*!< Initialize the DMA2D foreground alpha mode */
;;;368      DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_MODE = NO_MODIF_ALPHA_VALUE;
00000c  6141              STR      r1,[r0,#0x14]
;;;369    
;;;370      /*!< Initialize the DMA2D foreground alpha value */
;;;371      DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_VALUE = 0x00;
00000e  6181              STR      r1,[r0,#0x18]
;;;372    
;;;373      /*!< Initialize the DMA2D foreground blue value */
;;;374      DMA2D_FG_InitStruct->DMA2D_FGC_BLUE = 0x00;
000010  61c1              STR      r1,[r0,#0x1c]
;;;375    
;;;376      /*!< Initialize the DMA2D foreground green value */
;;;377      DMA2D_FG_InitStruct->DMA2D_FGC_GREEN = 0x00;
000012  6201              STR      r1,[r0,#0x20]
;;;378    
;;;379      /*!< Initialize the DMA2D foreground red value */
;;;380      DMA2D_FG_InitStruct->DMA2D_FGC_RED = 0x00;
000014  6241              STR      r1,[r0,#0x24]
;;;381    
;;;382      /*!< Initialize the DMA2D foreground CLUT memory address */
;;;383      DMA2D_FG_InitStruct->DMA2D_FGCMAR = 0x00;
000016  6281              STR      r1,[r0,#0x28]
;;;384    }
000018  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.DMA2D_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DMA2D_GetFlagStatus PROC
;;;662    
;;;663    FlagStatus DMA2D_GetFlagStatus(uint32_t DMA2D_FLAG)
000000  4601              MOV      r1,r0
;;;664    {
;;;665      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;666      
;;;667      /* Check the parameters */
;;;668      assert_param(IS_DMA2D_GET_FLAG(DMA2D_FLAG));
;;;669      
;;;670      /* Check the status of the specified DMA2D flag */
;;;671      if (((DMA2D->ISR) & DMA2D_FLAG) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L12.20|
000006  6852              LDR      r2,[r2,#4]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L12.16|
;;;672      {
;;;673        /* DMA2D_FLAG is set */
;;;674        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L12.18|
                  |L12.16|
;;;675      }
;;;676      else
;;;677      {
;;;678        /* DMA2D_FLAG is reset */
;;;679        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L12.18|
;;;680      }
;;;681      /* Return the DMA2D_FLAG status */
;;;682      return bitstatus;
;;;683    }
000012  4770              BX       lr
;;;684    
                          ENDP

                  |L12.20|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_GetITStatus||, CODE, READONLY, ALIGN=2

                  DMA2D_GetITStatus PROC
;;;717      */
;;;718    ITStatus DMA2D_GetITStatus(uint32_t DMA2D_IT)
000000  4601              MOV      r1,r0
;;;719    {
;;;720      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;721      uint32_t DMA2D_IT_FLAG = DMA2D_IT >> 8;
000004  0a0a              LSRS     r2,r1,#8
;;;722      
;;;723      /* Check the parameters */
;;;724      assert_param(IS_DMA2D_IT(DMA2D_IT));
;;;725    
;;;726      if ((DMA2D->ISR & DMA2D_IT_FLAG) != (uint32_t)RESET)
000006  4b08              LDR      r3,|L13.40|
000008  685b              LDR      r3,[r3,#4]
00000a  4013              ANDS     r3,r3,r2
00000c  b10b              CBZ      r3,|L13.18|
;;;727      {
;;;728        bitstatus = SET;
00000e  2001              MOVS     r0,#1
000010  e000              B        |L13.20|
                  |L13.18|
;;;729      }
;;;730      else
;;;731      {
;;;732        bitstatus = RESET;
000012  2000              MOVS     r0,#0
                  |L13.20|
;;;733      }
;;;734      
;;;735      if (((DMA2D->CR & DMA2D_IT) != (uint32_t)RESET) && (bitstatus != (uint32_t)RESET))
000014  4b04              LDR      r3,|L13.40|
000016  681b              LDR      r3,[r3,#0]
000018  400b              ANDS     r3,r3,r1
00001a  b113              CBZ      r3,|L13.34|
00001c  b108              CBZ      r0,|L13.34|
;;;736      {
;;;737        bitstatus = SET;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L13.36|
                  |L13.34|
;;;738      }
;;;739      else
;;;740      {
;;;741        bitstatus = RESET;
000022  2000              MOVS     r0,#0
                  |L13.36|
;;;742      }
;;;743      return bitstatus;
;;;744    }
000024  4770              BX       lr
;;;745    
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_ITConfig||, CODE, READONLY, ALIGN=2

                  DMA2D_ITConfig PROC
;;;631    
;;;632    void DMA2D_ITConfig(uint32_t DMA2D_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L14.14|
;;;633    {
;;;634      /* Check the parameters */
;;;635      assert_param(IS_DMA2D_IT(DMA2D_IT));
;;;636      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;637    
;;;638      if (NewState != DISABLE)
;;;639      {
;;;640        /* Enable the selected DMA2D interrupts */
;;;641        DMA2D->CR |= DMA2D_IT;
000002  4a06              LDR      r2,|L14.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L14.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L14.24|
                  |L14.14|
;;;642      }
;;;643      else
;;;644      {
;;;645        /* Disable the selected DMA2D interrupts */
;;;646        DMA2D->CR &= (uint32_t)~DMA2D_IT;
00000e  4a03              LDR      r2,|L14.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L14.28|
000016  601a              STR      r2,[r3,#0]
                  |L14.24|
;;;647      }
;;;648    }
000018  4770              BX       lr
;;;649    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_Init||, CODE, READONLY, ALIGN=2

                  DMA2D_Init PROC
;;;127      */
;;;128    void DMA2D_Init(DMA2D_InitTypeDef* DMA2D_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;129    {
;;;130    
;;;131      uint32_t outgreen = 0;
000002  2100              MOVS     r1,#0
;;;132      uint32_t outred   = 0;
000004  2200              MOVS     r2,#0
;;;133      uint32_t outalpha = 0;
000006  2300              MOVS     r3,#0
;;;134      uint32_t pixline  = 0;
000008  2400              MOVS     r4,#0
;;;135    
;;;136      /* Check the parameters */
;;;137      assert_param(IS_DMA2D_MODE(DMA2D_InitStruct->DMA2D_Mode));
;;;138      assert_param(IS_DMA2D_CMODE(DMA2D_InitStruct->DMA2D_CMode));
;;;139      assert_param(IS_DMA2D_OGREEN(DMA2D_InitStruct->DMA2D_OutputGreen));
;;;140      assert_param(IS_DMA2D_ORED(DMA2D_InitStruct->DMA2D_OutputRed));
;;;141      assert_param(IS_DMA2D_OBLUE(DMA2D_InitStruct->DMA2D_OutputBlue));
;;;142      assert_param(IS_DMA2D_OALPHA(DMA2D_InitStruct->DMA2D_OutputAlpha));
;;;143      assert_param(IS_DMA2D_OUTPUT_OFFSET(DMA2D_InitStruct->DMA2D_OutputOffset));
;;;144      assert_param(IS_DMA2D_LINE(DMA2D_InitStruct->DMA2D_NumberOfLine));
;;;145      assert_param(IS_DMA2D_PIXEL(DMA2D_InitStruct->DMA2D_PixelPerLine));
;;;146    
;;;147      /* Configures the DMA2D operation mode */
;;;148      DMA2D->CR &= (uint32_t)CR_MASK;
00000a  4d34              LDR      r5,|L15.220|
00000c  682d              LDR      r5,[r5,#0]
00000e  4e34              LDR      r6,|L15.224|
000010  4035              ANDS     r5,r5,r6
000012  4e32              LDR      r6,|L15.220|
000014  6035              STR      r5,[r6,#0]
;;;149      DMA2D->CR |= (DMA2D_InitStruct->DMA2D_Mode);
000016  4635              MOV      r5,r6
000018  682d              LDR      r5,[r5,#0]
00001a  6806              LDR      r6,[r0,#0]
00001c  4335              ORRS     r5,r5,r6
00001e  4e2f              LDR      r6,|L15.220|
000020  6035              STR      r5,[r6,#0]
;;;150    
;;;151      /* Configures the color mode of the output image */
;;;152      DMA2D->OPFCCR &= ~(uint32_t)DMA2D_OPFCCR_CM;
000022  4635              MOV      r5,r6
000024  6b6d              LDR      r5,[r5,#0x34]
000026  f0250507          BIC      r5,r5,#7
00002a  6375              STR      r5,[r6,#0x34]
;;;153      DMA2D->OPFCCR |= (DMA2D_InitStruct->DMA2D_CMode);
00002c  4635              MOV      r5,r6
00002e  6b6d              LDR      r5,[r5,#0x34]
000030  6846              LDR      r6,[r0,#4]
000032  4335              ORRS     r5,r5,r6
000034  4e29              LDR      r6,|L15.220|
000036  6375              STR      r5,[r6,#0x34]
;;;154    
;;;155      /* Configures the output color */
;;;156    
;;;157      if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_ARGB8888)
000038  6845              LDR      r5,[r0,#4]
00003a  b935              CBNZ     r5,|L15.74|
;;;158      {
;;;159        outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 8;
00003c  68c5              LDR      r5,[r0,#0xc]
00003e  0229              LSLS     r1,r5,#8
;;;160        outred = DMA2D_InitStruct->DMA2D_OutputRed << 16;
000040  8a05              LDRH     r5,[r0,#0x10]
000042  042a              LSLS     r2,r5,#16
;;;161        outalpha = DMA2D_InitStruct->DMA2D_OutputAlpha << 24;
000044  7d05              LDRB     r5,[r0,#0x14]
000046  062b              LSLS     r3,r5,#24
000048  e021              B        |L15.142|
                  |L15.74|
;;;162      }
;;;163      else
;;;164      
;;;165        if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_RGB888)
00004a  6845              LDR      r5,[r0,#4]
00004c  2d01              CMP      r5,#1
00004e  d105              BNE      |L15.92|
;;;166        {
;;;167          outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 8;
000050  68c5              LDR      r5,[r0,#0xc]
000052  0229              LSLS     r1,r5,#8
;;;168          outred = DMA2D_InitStruct->DMA2D_OutputRed << 16;
000054  8a05              LDRH     r5,[r0,#0x10]
000056  042a              LSLS     r2,r5,#16
;;;169          outalpha = (uint32_t)0x00000000;
000058  2300              MOVS     r3,#0
00005a  e018              B        |L15.142|
                  |L15.92|
;;;170        }
;;;171         
;;;172      else
;;;173    
;;;174        if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_RGB565)
00005c  6845              LDR      r5,[r0,#4]
00005e  2d02              CMP      r5,#2
000060  d105              BNE      |L15.110|
;;;175        {
;;;176          outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 5;
000062  68c5              LDR      r5,[r0,#0xc]
000064  0169              LSLS     r1,r5,#5
;;;177          outred = DMA2D_InitStruct->DMA2D_OutputRed << 11;
000066  6905              LDR      r5,[r0,#0x10]
000068  02ea              LSLS     r2,r5,#11
;;;178          outalpha = (uint32_t)0x00000000;
00006a  2300              MOVS     r3,#0
00006c  e00f              B        |L15.142|
                  |L15.110|
;;;179        }
;;;180    
;;;181      else
;;;182    
;;;183        if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_ARGB1555)
00006e  6845              LDR      r5,[r0,#4]
000070  2d03              CMP      r5,#3
000072  d106              BNE      |L15.130|
;;;184        {  
;;;185          outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 5;
000074  68c5              LDR      r5,[r0,#0xc]
000076  0169              LSLS     r1,r5,#5
;;;186          outred = DMA2D_InitStruct->DMA2D_OutputRed << 10;
000078  6905              LDR      r5,[r0,#0x10]
00007a  02aa              LSLS     r2,r5,#10
;;;187          outalpha = DMA2D_InitStruct->DMA2D_OutputAlpha << 15;
00007c  6945              LDR      r5,[r0,#0x14]
00007e  03eb              LSLS     r3,r5,#15
000080  e005              B        |L15.142|
                  |L15.130|
;;;188        }
;;;189    
;;;190      else /* DMA2D_CMode = DMA2D_ARGB4444 */
;;;191      {
;;;192        outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 4;
000082  68c5              LDR      r5,[r0,#0xc]
000084  0129              LSLS     r1,r5,#4
;;;193        outred = DMA2D_InitStruct->DMA2D_OutputRed << 8;
000086  6905              LDR      r5,[r0,#0x10]
000088  022a              LSLS     r2,r5,#8
;;;194        outalpha = DMA2D_InitStruct->DMA2D_OutputAlpha << 12;
00008a  6945              LDR      r5,[r0,#0x14]
00008c  032b              LSLS     r3,r5,#12
                  |L15.142|
;;;195      }  
;;;196      DMA2D->OCOLR |= ((outgreen) | (outred) | (DMA2D_InitStruct->DMA2D_OutputBlue) | (outalpha));
00008e  ea410502          ORR      r5,r1,r2
000092  6886              LDR      r6,[r0,#8]
000094  4335              ORRS     r5,r5,r6
000096  431d              ORRS     r5,r5,r3
000098  4e10              LDR      r6,|L15.220|
00009a  6bb6              LDR      r6,[r6,#0x38]
00009c  4335              ORRS     r5,r5,r6
00009e  4e0f              LDR      r6,|L15.220|
0000a0  63b5              STR      r5,[r6,#0x38]
;;;197    
;;;198      /* Configures the output memory address */
;;;199      DMA2D->OMAR = (DMA2D_InitStruct->DMA2D_OutputMemoryAdd);
0000a2  6985              LDR      r5,[r0,#0x18]
0000a4  63f5              STR      r5,[r6,#0x3c]
;;;200    
;;;201      /* Configure  the line Offset */
;;;202      DMA2D->OOR &= ~(uint32_t)DMA2D_OOR_LO;
0000a6  4635              MOV      r5,r6
0000a8  6c2d              LDR      r5,[r5,#0x40]
0000aa  f36f050d          BFC      r5,#0,#14
0000ae  6435              STR      r5,[r6,#0x40]
;;;203      DMA2D->OOR |= (DMA2D_InitStruct->DMA2D_OutputOffset);
0000b0  4635              MOV      r5,r6
0000b2  6c2d              LDR      r5,[r5,#0x40]
0000b4  69c6              LDR      r6,[r0,#0x1c]
0000b6  4335              ORRS     r5,r5,r6
0000b8  4e08              LDR      r6,|L15.220|
0000ba  6435              STR      r5,[r6,#0x40]
;;;204    
;;;205      /* Configure the number of line and pixel per line */
;;;206      pixline = DMA2D_InitStruct->DMA2D_PixelPerLine << 16; 
0000bc  8c85              LDRH     r5,[r0,#0x24]
0000be  042c              LSLS     r4,r5,#16
;;;207      DMA2D->NLR &= ~(DMA2D_NLR_NL | DMA2D_NLR_PL);
0000c0  4635              MOV      r5,r6
0000c2  6c6d              LDR      r5,[r5,#0x44]
0000c4  f0054540          AND      r5,r5,#0xc0000000
0000c8  6475              STR      r5,[r6,#0x44]
;;;208      DMA2D->NLR |= ((DMA2D_InitStruct->DMA2D_NumberOfLine) | (pixline));
0000ca  4635              MOV      r5,r6
0000cc  6c6d              LDR      r5,[r5,#0x44]
0000ce  6a06              LDR      r6,[r0,#0x20]
0000d0  4326              ORRS     r6,r6,r4
0000d2  4335              ORRS     r5,r5,r6
0000d4  4e01              LDR      r6,|L15.220|
0000d6  6475              STR      r5,[r6,#0x44]
;;;209    
;;;210    /**
;;;211      * @brief  Fills each DMA2D_InitStruct member with its default value.
;;;212      * @param  DMA2D_InitStruct: pointer to a DMA2D_InitTypeDef structure which will
;;;213      *         be initialized.
;;;214      * @retval None
;;;215      */
;;;216    }
0000d8  bd70              POP      {r4-r6,pc}
;;;217    void DMA2D_StructInit(DMA2D_InitTypeDef* DMA2D_InitStruct)
                          ENDP

0000da  0000              DCW      0x0000
                  |L15.220|
                          DCD      0x4002b000
                  |L15.224|
                          DCD      0xfffce0fc

                          AREA ||i.DMA2D_LineWatermarkConfig||, CODE, READONLY, ALIGN=2

                  DMA2D_LineWatermarkConfig PROC
;;;564    
;;;565    void DMA2D_LineWatermarkConfig(uint32_t DMA2D_LWatermarkConfig)
000000  4901              LDR      r1,|L16.8|
;;;566    {
;;;567      /* Check the parameters */
;;;568      assert_param(IS_DMA2D_LineWatermark(DMA2D_LWatermarkConfig));
;;;569    
;;;570      /* Sets the Line watermark configuration */
;;;571      DMA2D->LWR = (uint32_t)DMA2D_LWatermarkConfig;
000002  6488              STR      r0,[r1,#0x48]
;;;572    }
000004  4770              BX       lr
;;;573    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_StartTransfer||, CODE, READONLY, ALIGN=2

                  DMA2D_StartTransfer PROC
;;;247    
;;;248    void DMA2D_StartTransfer(void)
000000  4803              LDR      r0,|L17.16|
;;;249    {
;;;250        /* Start DMA2D transfer by setting START bit */
;;;251        DMA2D->CR |= (uint32_t)DMA2D_CR_START;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  4901              LDR      r1,|L17.16|
00000a  6008              STR      r0,[r1,#0]
;;;252    }
00000c  4770              BX       lr
;;;253    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x4002b000

                          AREA ||i.DMA2D_StructInit||, CODE, READONLY, ALIGN=1

                  DMA2D_StructInit PROC
;;;216    }
;;;217    void DMA2D_StructInit(DMA2D_InitTypeDef* DMA2D_InitStruct)
000000  2100              MOVS     r1,#0
;;;218    {
;;;219      /* Initialize the transfer mode member */
;;;220      DMA2D_InitStruct->DMA2D_Mode = DMA2D_M2M;
000002  6001              STR      r1,[r0,#0]
;;;221    
;;;222      /* Initialize the output color mode members */
;;;223      DMA2D_InitStruct->DMA2D_CMode = DMA2D_ARGB8888;
000004  6041              STR      r1,[r0,#4]
;;;224    
;;;225      /* Initialize the alpha and RGB values */
;;;226      DMA2D_InitStruct->DMA2D_OutputGreen = 0x00;
000006  60c1              STR      r1,[r0,#0xc]
;;;227      DMA2D_InitStruct->DMA2D_OutputBlue = 0x00;
000008  6081              STR      r1,[r0,#8]
;;;228      DMA2D_InitStruct->DMA2D_OutputRed = 0x00;
00000a  6101              STR      r1,[r0,#0x10]
;;;229      DMA2D_InitStruct->DMA2D_OutputAlpha = 0x00;
00000c  6141              STR      r1,[r0,#0x14]
;;;230    
;;;231      /* Initialize the output memory address */
;;;232      DMA2D_InitStruct->DMA2D_OutputMemoryAdd = 0x00;
00000e  6181              STR      r1,[r0,#0x18]
;;;233    
;;;234      /* Initialize the output offset */
;;;235      DMA2D_InitStruct->DMA2D_OutputOffset = 0x00;
000010  61c1              STR      r1,[r0,#0x1c]
;;;236    
;;;237      /* Initialize the number of line and the number of pixel per line */
;;;238      DMA2D_InitStruct->DMA2D_NumberOfLine = 0x00;
000012  6201              STR      r1,[r0,#0x20]
;;;239      DMA2D_InitStruct->DMA2D_PixelPerLine = 0x00;
000014  6241              STR      r1,[r0,#0x24]
;;;240    }
000016  4770              BX       lr
;;;241    
                          ENDP


                          AREA ||i.DMA2D_Suspend||, CODE, READONLY, ALIGN=2

                  DMA2D_Suspend PROC
;;;272      */
;;;273    void DMA2D_Suspend(FunctionalState NewState)
000000  b130              CBZ      r0,|L19.16|
;;;274    {
;;;275      /* Check the parameters */
;;;276      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;277    
;;;278      if (NewState != DISABLE)
;;;279      {
;;;280        /* Suspend DMA2D transfer by setting STOP bit */
;;;281        DMA2D->CR |= (uint32_t)DMA2D_CR_SUSP;
000002  4907              LDR      r1,|L19.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410102          ORR      r1,r1,#2
00000a  4a05              LDR      r2,|L19.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L19.28|
                  |L19.16|
;;;282      }
;;;283      else
;;;284      {
;;;285        /* Continue DMA2D transfer by clearing STOP bit */
;;;286        DMA2D->CR &= ~(uint32_t)DMA2D_CR_SUSP;
000010  4903              LDR      r1,|L19.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210102          BIC      r1,r1,#2
000018  4a01              LDR      r2,|L19.32|
00001a  6011              STR      r1,[r2,#0]
                  |L19.28|
;;;287      }
;;;288    }
00001c  4770              BX       lr
;;;289    
                          ENDP

00001e  0000              DCW      0x0000
                  |L19.32|
                          DCD      0x4002b000

;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_dma2d.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_dma2d_c_de80eb9a____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___17_stm32f4xx_dma2d_c_de80eb9a____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_dma2d_c_de80eb9a____REVSH|
#line 153
|__asm___17_stm32f4xx_dma2d_c_de80eb9a____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_dma2d_c_de80eb9a____RRX|
#line 328
|__asm___17_stm32f4xx_dma2d_c_de80eb9a____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
