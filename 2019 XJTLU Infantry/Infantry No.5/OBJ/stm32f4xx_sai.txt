; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_sai.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_sai.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_sai.crf ..\FWLIB\src\stm32f4xx_sai.c]
                          THUMB

                          AREA ||i.SAI_BlockSynchroConfig||, CODE, READONLY, ALIGN=2

                  SAI_BlockSynchroConfig PROC
;;;629      */
;;;630    void SAI_BlockSynchroConfig(SAI_InitTypeDef* SAI_InitStruct, SAI_TypeDef* SAIx)
000000  460a              MOV      r2,r1
;;;631    {
;;;632      uint32_t tmpregisterGCR = 0U;
000002  2100              MOVS     r1,#0
;;;633    
;;;634    #if defined(STM32F446xx)  
;;;635      /* This setting must be done with both audio block (A & B) disabled         */
;;;636      switch(SAI_InitStruct->SAI_SynchroExt)
;;;637      {
;;;638      case SAI_SyncExt_Disable :
;;;639        tmpregisterGCR = 0U;
;;;640        break;
;;;641      case SAI_SyncExt_OutBlockA_Enable :
;;;642        tmpregisterGCR = SAI_GCR_SYNCOUT_0;
;;;643        break;
;;;644      case SAI_SyncExt_OutBlockB_Enable :
;;;645        tmpregisterGCR = SAI_GCR_SYNCOUT_1;
;;;646        break;
;;;647      default:
;;;648        break;
;;;649      }
;;;650    
;;;651      if(((SAI_InitStruct->SAI_Synchro) == SAI_Synchronous_Ext) && (SAIx == SAI1))
;;;652      {
;;;653        tmpregisterGCR |= SAI_GCR_SYNCIN_0;
;;;654      }
;;;655      
;;;656      if(SAIx == SAI1)
;;;657      {
;;;658       SAI1->GCR = tmpregisterGCR;
;;;659      }
;;;660      else
;;;661      {
;;;662       SAI2->GCR = tmpregisterGCR; 
;;;663      }
;;;664    
;;;665    #endif /* STM32F446xx */
;;;666    #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
;;;667        defined(STM32F469_479xx) || defined(STM32F413_423xx)
;;;668      /* This setting must be done with both audio block (A & B) disabled         */
;;;669      switch(SAI_InitStruct->SAI_SynchroExt)
000004  6983              LDR      r3,[r0,#0x18]
000006  b123              CBZ      r3,|L1.18|
000008  2b10              CMP      r3,#0x10
00000a  d004              BEQ      |L1.22|
00000c  2b20              CMP      r3,#0x20
00000e  d106              BNE      |L1.30|
000010  e003              B        |L1.26|
                  |L1.18|
;;;670      {
;;;671      case SAI_SyncExt_Disable :
;;;672        tmpregisterGCR = 0U;
000012  2100              MOVS     r1,#0
;;;673        break;
000014  e004              B        |L1.32|
                  |L1.22|
;;;674      case SAI_SyncExt_OutBlockA_Enable :
;;;675        tmpregisterGCR = SAI_GCR_SYNCOUT_0;
000016  2110              MOVS     r1,#0x10
;;;676        break;
000018  e002              B        |L1.32|
                  |L1.26|
;;;677      case SAI_SyncExt_OutBlockB_Enable :
;;;678        tmpregisterGCR = SAI_GCR_SYNCOUT_1;
00001a  2120              MOVS     r1,#0x20
;;;679        break;
00001c  e000              B        |L1.32|
                  |L1.30|
;;;680      default:
;;;681        break;
00001e  bf00              NOP      
                  |L1.32|
000020  bf00              NOP                            ;673
;;;682      }
;;;683      SAI1->GCR = tmpregisterGCR;
000022  4b01              LDR      r3,|L1.40|
000024  6019              STR      r1,[r3,#0]
;;;684    #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469_479xx || STM32F413_423xx */ 
;;;685    }
000026  4770              BX       lr
;;;686    #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469_479xx || STM32F413_423xx || STM32F446xx */
                          ENDP

                  |L1.40|
                          DCD      0x40015800

                          AREA ||i.SAI_ClearFlag||, CODE, READONLY, ALIGN=1

                  SAI_ClearFlag PROC
;;;1008     */
;;;1009   void SAI_ClearFlag(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG)
000000  6982              LDR      r2,[r0,#0x18]
;;;1010   {
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;1013     assert_param(IS_SAI_BLOCK_CLEAR_FLAG(SAI_FLAG));
;;;1014       
;;;1015     /* Clear the selected SAI Block flag */
;;;1016     SAI_Block_x->CLRFR |= SAI_FLAG;
000002  430a              ORRS     r2,r2,r1
000004  6182              STR      r2,[r0,#0x18]
;;;1017   }
000006  4770              BX       lr
;;;1018   
                          ENDP


                          AREA ||i.SAI_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  SAI_ClearITPendingBit PROC
;;;1080     */
;;;1081   void SAI_ClearITPendingBit(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT)
000000  6982              LDR      r2,[r0,#0x18]
;;;1082   {
;;;1083     /* Check the parameters */
;;;1084     assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;1085     assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
;;;1086   
;;;1087     /* Clear the selected SAI Block x interrupt pending bit */
;;;1088     SAI_Block_x->CLRFR |= SAI_IT; 
000002  430a              ORRS     r2,r2,r1
000004  6182              STR      r2,[r0,#0x18]
;;;1089   }
000006  4770              BX       lr
;;;1090   
                          ENDP


                          AREA ||i.SAI_Cmd||, CODE, READONLY, ALIGN=1

                  SAI_Cmd PROC
;;;452      */
;;;453    void SAI_Cmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;454    {
;;;455      /* Check the parameters */
;;;456      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;457      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;458      if (NewState != DISABLE)
;;;459      {
;;;460        /* Enable the selected SAI peripheral */
;;;461        SAI_Block_x->CR1 |= SAI_xCR1_SAIEN;
000002  6802              LDR      r2,[r0,#0]
000004  f4423280          ORR      r2,r2,#0x10000
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L4.20|
                  |L4.12|
;;;462      }
;;;463      else
;;;464      {
;;;465        /* Disable the selected SAI peripheral */
;;;466        SAI_Block_x->CR1 &= ~(SAI_xCR1_SAIEN);
00000c  6802              LDR      r2,[r0,#0]
00000e  f4223280          BIC      r2,r2,#0x10000
000012  6002              STR      r2,[r0,#0]
                  |L4.20|
;;;467      }
;;;468    }
000014  4770              BX       lr
;;;469    
                          ENDP


                          AREA ||i.SAI_CompandingModeConfig||, CODE, READONLY, ALIGN=1

                  SAI_CompandingModeConfig PROC
;;;532      */
;;;533    void SAI_CompandingModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_CompandingMode)
000000  6842              LDR      r2,[r0,#4]
;;;534    {
;;;535      /* Check the parameters */
;;;536      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;537      assert_param(IS_SAI_BLOCK_COMPANDING_MODE(SAI_CompandingMode));
;;;538      /* Clear Companding Mode bits */
;;;539      SAI_Block_x->CR2 &= ~(SAI_xCR2_COMP);
000002  f4224240          BIC      r2,r2,#0xc000
000006  6042              STR      r2,[r0,#4]
;;;540      /* Set new Companding Mode value */
;;;541      SAI_Block_x->CR2 |= SAI_CompandingMode;
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;542    }
00000e  4770              BX       lr
;;;543    
                          ENDP


                          AREA ||i.SAI_DMACmd||, CODE, READONLY, ALIGN=1

                  SAI_DMACmd PROC
;;;788      */
;;;789    void SAI_DMACmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
000000  b121              CBZ      r1,|L6.12|
;;;790    {
;;;791      /* Check the parameters */
;;;792      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;793      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;794      
;;;795      if (NewState != DISABLE)
;;;796      {
;;;797        /* Enable the selected SAI block mute mode */
;;;798        SAI_Block_x->CR1 |= SAI_xCR1_DMAEN;
000002  6802              LDR      r2,[r0,#0]
000004  f4423200          ORR      r2,r2,#0x20000
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L6.20|
                  |L6.12|
;;;799      }
;;;800      else
;;;801      {
;;;802        /* Disable the selected SAI SS output */
;;;803        SAI_Block_x->CR1 &= ~(SAI_xCR1_DMAEN);
00000c  6802              LDR      r2,[r0,#0]
00000e  f4223200          BIC      r2,r2,#0x20000
000012  6002              STR      r2,[r0,#0]
                  |L6.20|
;;;804      }
;;;805    }
000014  4770              BX       lr
;;;806    
                          ENDP


                          AREA ||i.SAI_DeInit||, CODE, READONLY, ALIGN=2

                  SAI_DeInit PROC
;;;184      */
;;;185    void SAI_DeInit(SAI_TypeDef* SAIx)
000000  b510              PUSH     {r4,lr}
;;;186    {
000002  4604              MOV      r4,r0
;;;187      /* Check the parameters */
;;;188      assert_param(IS_SAI_PERIPH(SAIx));
;;;189      
;;;190      if(SAIx == SAI1)
000004  4806              LDR      r0,|L7.32|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L7.28|
;;;191      {
;;;192        /* Enable SAI1 reset state */
;;;193        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0588              LSLS     r0,r1,#22
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;194        /* Release SAI1 from reset state */
;;;195        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI1, DISABLE); 
000012  2100              MOVS     r1,#0
000014  f44f0080          MOV      r0,#0x400000
000018  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L7.28|
;;;196      }
;;;197      else
;;;198      {
;;;199    #if defined(STM32F446xx)
;;;200      if(SAIx == SAI2)
;;;201        {
;;;202          /* Enable SAI2 reset state */
;;;203          RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI2, ENABLE);
;;;204          /* Release SAI2 from reset state */
;;;205          RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI2, DISABLE);   
;;;206        }
;;;207    #endif /* STM32F446xx */
;;;208      }
;;;209    }
00001c  bd10              POP      {r4,pc}
;;;210    
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0x40015800

                          AREA ||i.SAI_FlushFIFO||, CODE, READONLY, ALIGN=1

                  SAI_FlushFIFO PROC
;;;698      */
;;;699    void SAI_FlushFIFO(SAI_Block_TypeDef* SAI_Block_x)
000000  6841              LDR      r1,[r0,#4]
;;;700    {
;;;701      /* Check the parameters */
;;;702      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;703    
;;;704      /* FIFO flush */
;;;705      SAI_Block_x->CR2 |= SAI_xCR2_FFLUSH;
000002  f0410108          ORR      r1,r1,#8
000006  6041              STR      r1,[r0,#4]
;;;706    }
000008  4770              BX       lr
;;;707    
                          ENDP


                          AREA ||i.SAI_FrameInit||, CODE, READONLY, ALIGN=2

                  SAI_FrameInit PROC
;;;290      */
;;;291    void SAI_FrameInit(SAI_Block_TypeDef* SAI_Block_x, SAI_FrameInitTypeDef* SAI_FrameInitStruct)
000000  b510              PUSH     {r4,lr}
;;;292    {
;;;293      uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;294      
;;;295      /* Check the parameters */
;;;296      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;297      
;;;298      /* Check the SAI Block frame parameters */
;;;299      assert_param(IS_SAI_BLOCK_FRAME_LENGTH(SAI_FrameInitStruct->SAI_FrameLength));
;;;300      assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(SAI_FrameInitStruct->SAI_ActiveFrameLength));
;;;301      assert_param(IS_SAI_BLOCK_FS_DEFINITION(SAI_FrameInitStruct->SAI_FSDefinition));
;;;302      assert_param(IS_SAI_BLOCK_FS_POLARITY(SAI_FrameInitStruct->SAI_FSPolarity));
;;;303      assert_param(IS_SAI_BLOCK_FS_OFFSET(SAI_FrameInitStruct->SAI_FSOffset));
;;;304    
;;;305      /* SAI Block_x FRCR Configuration */
;;;306      /* Get the SAI Block_x FRCR value */
;;;307      tmpreg = SAI_Block_x->FRCR;
000004  6882              LDR      r2,[r0,#8]
;;;308      /* Clear FRL, FSALL, FSDEF, FSPOL, FSOFF bits */
;;;309      tmpreg &= FRCR_CLEAR_MASK;
000006  4b08              LDR      r3,|L9.40|
000008  401a              ANDS     r2,r2,r3
;;;310      /* Configure SAI_Block_x Frame: Frame Length, Active Frame Length, Frame Synchronization
;;;311         Definition, Frame Synchronization Polarity and Frame Synchronization Polarity */
;;;312      /* Set FRL bits according to SAI_FrameLength value         */
;;;313      /* Set FSALL bits according to SAI_ActiveFrameLength value */
;;;314      /* Set FSDEF bit according to SAI_FSDefinition value       */
;;;315      /* Set FSPOL bit according to SAI_FSPolarity value         */
;;;316      /* Set FSOFF bit according to SAI_FSOffset value           */
;;;317      tmpreg |= (uint32_t)((uint32_t)(SAI_FrameInitStruct->SAI_FrameLength - 1)  | 
00000a  680b              LDR      r3,[r1,#0]
00000c  1e5b              SUBS     r3,r3,#1
00000e  690c              LDR      r4,[r1,#0x10]
000010  4323              ORRS     r3,r3,r4
000012  688c              LDR      r4,[r1,#8]
000014  4323              ORRS     r3,r3,r4
000016  68cc              LDR      r4,[r1,#0xc]
000018  4323              ORRS     r3,r3,r4
00001a  684c              LDR      r4,[r1,#4]
00001c  1e64              SUBS     r4,r4,#1
00001e  ea432304          ORR      r3,r3,r4,LSL #8
000022  431a              ORRS     r2,r2,r3
;;;318                           SAI_FrameInitStruct->SAI_FSOffset     | 
;;;319                           SAI_FrameInitStruct->SAI_FSDefinition |    
;;;320                           SAI_FrameInitStruct->SAI_FSPolarity   |                        
;;;321                           (uint32_t)((SAI_FrameInitStruct->SAI_ActiveFrameLength - 1) << 8));
;;;322                           
;;;323      /* Write to SAI_Block_x FRCR */
;;;324      SAI_Block_x->FRCR = tmpreg;
000024  6082              STR      r2,[r0,#8]
;;;325    }
000026  bd10              POP      {r4,pc}
;;;326    
                          ENDP

                  |L9.40|
                          DCD      0xfff88000

                          AREA ||i.SAI_FrameStructInit||, CODE, READONLY, ALIGN=1

                  SAI_FrameStructInit PROC
;;;410      */
;;;411    void SAI_FrameStructInit(SAI_FrameInitTypeDef* SAI_FrameInitStruct)
000000  2108              MOVS     r1,#8
;;;412    {
;;;413      /* Reset SAI Frame init structure parameters values */
;;;414      /* Initialize the SAI_FrameLength member */
;;;415      SAI_FrameInitStruct->SAI_FrameLength = 8;
000002  6001              STR      r1,[r0,#0]
;;;416      /* Initialize the SAI_ActiveFrameLength member */
;;;417      SAI_FrameInitStruct->SAI_ActiveFrameLength = 1;
000004  2101              MOVS     r1,#1
000006  6041              STR      r1,[r0,#4]
;;;418      /* Initialize the SAI_FSDefinition member */
;;;419      SAI_FrameInitStruct->SAI_FSDefinition = SAI_FS_StartFrame;
000008  2100              MOVS     r1,#0
00000a  6081              STR      r1,[r0,#8]
;;;420      /* Initialize the SAI_FSPolarity member */
;;;421      SAI_FrameInitStruct->SAI_FSPolarity = SAI_FS_ActiveLow;
00000c  60c1              STR      r1,[r0,#0xc]
;;;422      /* Initialize the SAI_FSOffset member */
;;;423      SAI_FrameInitStruct->SAI_FSOffset = SAI_FS_FirstBit;
00000e  6101              STR      r1,[r0,#0x10]
;;;424    }
000010  4770              BX       lr
;;;425    
                          ENDP


                          AREA ||i.SAI_GetCmdStatus||, CODE, READONLY, ALIGN=1

                  SAI_GetCmdStatus PROC
;;;1102     */
;;;1103   FunctionalState SAI_GetCmdStatus(SAI_Block_TypeDef* SAI_Block_x)
000000  4601              MOV      r1,r0
;;;1104   {
;;;1105     FunctionalState state = DISABLE;
000002  2000              MOVS     r0,#0
;;;1106   
;;;1107     /* Check the parameters */
;;;1108     assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;1109     if ((SAI_Block_x->CR1 & (uint32_t)SAI_xCR1_SAIEN) != 0)
000004  680a              LDR      r2,[r1,#0]
000006  f4023280          AND      r2,r2,#0x10000
00000a  b10a              CBZ      r2,|L11.16|
;;;1110     {
;;;1111       /* The selected SAI Block x EN bit is set (audio frame transfer is ongoing) */
;;;1112       state = ENABLE;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L11.18|
                  |L11.16|
;;;1113     }
;;;1114     else
;;;1115     {
;;;1116       /* The selected SAI Block x EN bit is cleared (SAI Block is disabled and 
;;;1117           all transfers are complete) */
;;;1118       state = DISABLE;
000010  2000              MOVS     r0,#0
                  |L11.18|
;;;1119     }
;;;1120     return state;
;;;1121   }
000012  4770              BX       lr
;;;1122   
                          ENDP


                          AREA ||i.SAI_GetFIFOStatus||, CODE, READONLY, ALIGN=1

                  SAI_GetFIFOStatus PROC
;;;1135     */
;;;1136   uint32_t SAI_GetFIFOStatus(SAI_Block_TypeDef* SAI_Block_x)
000000  4601              MOV      r1,r0
;;;1137   {
;;;1138     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1139    
;;;1140     /* Check the parameters */
;;;1141     assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;1142     
;;;1143     /* Get the FIFO level bits */
;;;1144     tmpreg = (uint32_t)((SAI_Block_x->SR & SAI_xSR_FLVL));
000004  694a              LDR      r2,[r1,#0x14]
000006  f40220e0          AND      r0,r2,#0x70000
;;;1145     
;;;1146     return tmpreg;
;;;1147   }
00000a  4770              BX       lr
;;;1148   
                          ENDP


                          AREA ||i.SAI_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SAI_GetFlagStatus PROC
;;;965      */
;;;966    FlagStatus SAI_GetFlagStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG)
000000  4602              MOV      r2,r0
;;;967    {
;;;968      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;969      
;;;970      /* Check the parameters */
;;;971      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;972      assert_param(IS_SAI_BLOCK_GET_FLAG(SAI_FLAG));
;;;973      
;;;974      /* Check the status of the specified SAI flag */
;;;975      if ((SAI_Block_x->SR & SAI_FLAG) != (uint32_t)RESET)
000004  6953              LDR      r3,[r2,#0x14]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L13.14|
;;;976      {
;;;977        /* SAI_FLAG is set */
;;;978        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L13.16|
                  |L13.14|
;;;979      }
;;;980      else
;;;981      {
;;;982        /* SAI_FLAG is reset */
;;;983        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L13.16|
;;;984      }
;;;985      /* Return the SAI_FLAG status */
;;;986      return  bitstatus;
;;;987    }
000010  4770              BX       lr
;;;988    
                          ENDP


                          AREA ||i.SAI_GetITStatus||, CODE, READONLY, ALIGN=1

                  SAI_GetITStatus PROC
;;;1033     */
;;;1034   ITStatus SAI_GetITStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT)
000000  b510              PUSH     {r4,lr}
;;;1035   {
000002  4602              MOV      r2,r0
;;;1036     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1037     uint32_t  enablestatus = 0;
000006  2300              MOVS     r3,#0
;;;1038   
;;;1039     /* Check the parameters */
;;;1040     assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;1041     assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
;;;1042     
;;;1043     /* Get the SAI_IT enable bit status */
;;;1044     enablestatus = (SAI_Block_x->IMR & SAI_IT) ;
000008  6914              LDR      r4,[r2,#0x10]
00000a  ea040301          AND      r3,r4,r1
;;;1045   
;;;1046     /* Check the status of the specified SAI interrupt */
;;;1047     if (((SAI_Block_x->SR & SAI_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
00000e  6954              LDR      r4,[r2,#0x14]
000010  400c              ANDS     r4,r4,r1
000012  b114              CBZ      r4,|L14.26|
000014  b10b              CBZ      r3,|L14.26|
;;;1048     {
;;;1049       /* SAI_IT is set */
;;;1050       bitstatus = SET;
000016  2001              MOVS     r0,#1
000018  e000              B        |L14.28|
                  |L14.26|
;;;1051     }
;;;1052     else
;;;1053     {
;;;1054       /* SAI_IT is reset */
;;;1055       bitstatus = RESET;
00001a  2000              MOVS     r0,#0
                  |L14.28|
;;;1056     }
;;;1057     /* Return the SAI_IT status */
;;;1058     return bitstatus;
;;;1059   }
00001c  bd10              POP      {r4,pc}
;;;1060   
                          ENDP


                          AREA ||i.SAI_ITConfig||, CODE, READONLY, ALIGN=1

                  SAI_ITConfig PROC
;;;932      */
;;;933    void SAI_ITConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L15.10|
;;;934    { 
;;;935      /* Check the parameters */
;;;936      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;937      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;938      assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
;;;939    
;;;940      if (NewState != DISABLE)
;;;941      {
;;;942        /* Enable the selected SAI Block interrupt */
;;;943        SAI_Block_x->IMR |= SAI_IT;
000002  6903              LDR      r3,[r0,#0x10]
000004  430b              ORRS     r3,r3,r1
000006  6103              STR      r3,[r0,#0x10]
000008  e002              B        |L15.16|
                  |L15.10|
;;;944      }
;;;945      else
;;;946      {
;;;947        /* Disable the selected SAI Block interrupt */
;;;948        SAI_Block_x->IMR &= ~(SAI_IT);
00000a  6903              LDR      r3,[r0,#0x10]
00000c  438b              BICS     r3,r3,r1
00000e  6103              STR      r3,[r0,#0x10]
                  |L15.16|
;;;949      }
;;;950    }
000010  4770              BX       lr
;;;951    
                          ENDP


                          AREA ||i.SAI_Init||, CODE, READONLY, ALIGN=2

                  SAI_Init PROC
;;;222      */
;;;223    void SAI_Init(SAI_Block_TypeDef* SAI_Block_x, SAI_InitTypeDef* SAI_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;224    {
000002  4602              MOV      r2,r0
;;;225      uint32_t tmpreg = 0;
000004  2000              MOVS     r0,#0
;;;226      
;;;227      /* Check the parameters */
;;;228      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;229      
;;;230      /* Check the SAI Block parameters */
;;;231      assert_param(IS_SAI_BLOCK_MODE(SAI_InitStruct->SAI_AudioMode));
;;;232      assert_param(IS_SAI_BLOCK_PROTOCOL(SAI_InitStruct->SAI_Protocol));
;;;233      assert_param(IS_SAI_BLOCK_DATASIZE(SAI_InitStruct->SAI_DataSize));
;;;234      assert_param(IS_SAI_BLOCK_FIRST_BIT(SAI_InitStruct->SAI_FirstBit));
;;;235      assert_param(IS_SAI_BLOCK_CLOCK_STROBING(SAI_InitStruct->SAI_ClockStrobing));
;;;236      assert_param(IS_SAI_BLOCK_SYNCHRO(SAI_InitStruct->SAI_Synchro));
;;;237      assert_param(IS_SAI_BLOCK_SYNCEXT(SAI_InitStruct->SAI_SynchroExt));
;;;238      assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(SAI_InitStruct->SAI_OUTDRIV));
;;;239      assert_param(IS_SAI_BLOCK_NODIVIDER(SAI_InitStruct->SAI_NoDivider));
;;;240      assert_param(IS_SAI_BLOCK_MASTER_DIVIDER(SAI_InitStruct->SAI_MasterDivider));
;;;241      assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(SAI_InitStruct->SAI_FIFOThreshold));
;;;242    
;;;243      /* SAI Block_x CR1 Configuration */
;;;244      /* Get the SAI Block_x CR1 value */
;;;245      tmpreg = SAI_Block_x->CR1;
000006  6810              LDR      r0,[r2,#0]
;;;246      /* Clear MODE, PRTCFG, DS, LSBFIRST, CKSTR, SYNCEN, OUTDRIV, NODIV, and MCKDIV bits */
;;;247      tmpreg &= CR1_CLEAR_MASK;
000008  4b0f              LDR      r3,|L16.72|
00000a  4018              ANDS     r0,r0,r3
;;;248      /* Configure SAI_Block_x: Audio mode, Protocol, Data Size, first transmitted bit, Clock strobing 
;;;249         edge, Synchronization mode, Output drive, Master Divider and FIFO level */  
;;;250      /* Set MODE bits according to SAI_AudioMode value       */
;;;251      /* Set PRTCFG bits according to SAI_Protocol value      */
;;;252      /* Set DS bits according to SAI_DataSize value          */
;;;253      /* Set LSBFIRST bit according to SAI_FirstBit value     */
;;;254      /* Set CKSTR bit according to SAI_ClockStrobing value   */
;;;255      /* Set SYNCEN bit according to SAI_Synchro value        */
;;;256      /* Set OUTDRIV bit according to SAI_OUTDRIV value       */
;;;257      /* Set NODIV bit according to SAI_NoDivider value       */
;;;258      /* Set MCKDIV bits according to SAI_MasterDivider value */
;;;259      tmpreg |= (uint32_t)(SAI_InitStruct->SAI_AudioMode     | SAI_InitStruct->SAI_Protocol  |
00000c  e9d13400          LDRD     r3,r4,[r1,#0]
000010  4323              ORRS     r3,r3,r4
000012  688c              LDR      r4,[r1,#8]
000014  4323              ORRS     r3,r3,r4
000016  68cc              LDR      r4,[r1,#0xc]
000018  4323              ORRS     r3,r3,r4
00001a  690c              LDR      r4,[r1,#0x10]
00001c  4323              ORRS     r3,r3,r4
00001e  694c              LDR      r4,[r1,#0x14]
000020  4323              ORRS     r3,r3,r4
000022  69cc              LDR      r4,[r1,#0x1c]
000024  4323              ORRS     r3,r3,r4
000026  6a0c              LDR      r4,[r1,#0x20]
000028  4323              ORRS     r3,r3,r4
00002a  698c              LDR      r4,[r1,#0x18]
00002c  4323              ORRS     r3,r3,r4
00002e  8c8c              LDRH     r4,[r1,#0x24]
000030  ea435304          ORR      r3,r3,r4,LSL #20
000034  4318              ORRS     r0,r0,r3
;;;260                           SAI_InitStruct->SAI_DataSize      | SAI_InitStruct->SAI_FirstBit  |  
;;;261                           SAI_InitStruct->SAI_ClockStrobing | SAI_InitStruct->SAI_Synchro   |  
;;;262                           SAI_InitStruct->SAI_OUTDRIV       | SAI_InitStruct->SAI_NoDivider |
;;;263                           SAI_InitStruct->SAI_SynchroExt    | (uint32_t)((SAI_InitStruct->SAI_MasterDivider) << 20));
;;;264      /* Write to SAI_Block_x CR1 */
;;;265      SAI_Block_x->CR1 = tmpreg;
000036  6010              STR      r0,[r2,#0]
;;;266      
;;;267      /* SAI Block_x CR2 Configuration */
;;;268      /* Get the SAIBlock_x CR2 value */
;;;269      tmpreg = SAI_Block_x->CR2;
000038  6850              LDR      r0,[r2,#4]
;;;270      /* Clear FTH bits */
;;;271      tmpreg &= ~(SAI_xCR2_FTH);
00003a  f0200003          BIC      r0,r0,#3
;;;272      /* Configure the FIFO Level */
;;;273      /* Set FTH bits according to SAI_FIFOThreshold value */ 
;;;274      tmpreg |= (uint32_t)(SAI_InitStruct->SAI_FIFOThreshold);
00003e  6a8b              LDR      r3,[r1,#0x28]
000040  4318              ORRS     r0,r0,r3
;;;275      /* Write to SAI_Block_x CR2 */
;;;276      SAI_Block_x->CR2 = tmpreg;
000042  6050              STR      r0,[r2,#4]
;;;277    }
000044  bd10              POP      {r4,pc}
;;;278    
                          ENDP

000046  0000              DCW      0x0000
                  |L16.72|
                          DCD      0xff07c010

                          AREA ||i.SAI_MonoModeConfig||, CODE, READONLY, ALIGN=1

                  SAI_MonoModeConfig PROC
;;;481      */
;;;482    void SAI_MonoModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_Mono_StreoMode)
000000  6802              LDR      r2,[r0,#0]
;;;483    {
;;;484      /* Check the parameters */
;;;485      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;486      assert_param(IS_SAI_BLOCK_MONO_STREO_MODE(SAI_MonoMode));
;;;487      /* Clear MONO bit */
;;;488      SAI_Block_x->CR1 &= ~(SAI_xCR1_MONO);
000002  f4225280          BIC      r2,r2,#0x1000
000006  6002              STR      r2,[r0,#0]
;;;489      /* Set new Mono Mode value */
;;;490      SAI_Block_x->CR1 |= SAI_MonoMode;
000008  6802              LDR      r2,[r0,#0]
00000a  f4425280          ORR      r2,r2,#0x1000
00000e  6002              STR      r2,[r0,#0]
;;;491    }
000010  4770              BX       lr
;;;492    
                          ENDP


                          AREA ||i.SAI_MuteFrameCounterConfig||, CODE, READONLY, ALIGN=1

                  SAI_MuteFrameCounterConfig PROC
;;;609      */
;;;610    void SAI_MuteFrameCounterConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteCounter)
000000  6842              LDR      r2,[r0,#4]
;;;611    {
;;;612      /* Check the parameters */
;;;613      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;614      assert_param(IS_SAI_BLOCK_MUTE_COUNTER(SAI_MuteCounter));
;;;615      
;;;616      /* Clear Mute value bits */
;;;617      SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTECNT);
000002  f42252fc          BIC      r2,r2,#0x1f80
000006  6042              STR      r2,[r0,#4]
;;;618      /* Set new Mute value */
;;;619      SAI_Block_x->CR2 |= (SAI_MuteCounter << 7);
000008  6842              LDR      r2,[r0,#4]
00000a  ea4212c1          ORR      r2,r2,r1,LSL #7
00000e  6042              STR      r2,[r0,#4]
;;;620    }
000010  4770              BX       lr
;;;621    #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
                          ENDP


                          AREA ||i.SAI_MuteModeCmd||, CODE, READONLY, ALIGN=1

                  SAI_MuteModeCmd PROC
;;;556      */
;;;557    void SAI_MuteModeCmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
000000  b121              CBZ      r1,|L19.12|
;;;558    {
;;;559      /* Check the parameters */
;;;560      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;561      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;562      if (NewState != DISABLE)
;;;563      {
;;;564        /* Enable the selected SAI block mute mode */
;;;565        SAI_Block_x->CR2 |= SAI_xCR2_MUTE;
000002  6842              LDR      r2,[r0,#4]
000004  f0420220          ORR      r2,r2,#0x20
000008  6042              STR      r2,[r0,#4]
00000a  e003              B        |L19.20|
                  |L19.12|
;;;566      }
;;;567      else
;;;568      {
;;;569        /* Disable the selected SAI SS output */
;;;570        SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTE);
00000c  6842              LDR      r2,[r0,#4]
00000e  f0220220          BIC      r2,r2,#0x20
000012  6042              STR      r2,[r0,#4]
                  |L19.20|
;;;571      }
;;;572    }
000014  4770              BX       lr
;;;573    
                          ENDP


                          AREA ||i.SAI_MuteValueConfig||, CODE, READONLY, ALIGN=1

                  SAI_MuteValueConfig PROC
;;;587      */
;;;588    void SAI_MuteValueConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteValue)
000000  6842              LDR      r2,[r0,#4]
;;;589    {
;;;590      /* Check the parameters */
;;;591      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;592      assert_param(IS_SAI_BLOCK_MUTE_VALUE(SAI_MuteValue));
;;;593      
;;;594      /* Clear Mute value bits */
;;;595      SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTEVAL);
000002  f0220240          BIC      r2,r2,#0x40
000006  6042              STR      r2,[r0,#4]
;;;596      /* Set new Mute value */
;;;597      SAI_Block_x->CR2 |= SAI_MuteValue;
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;598    }
00000e  4770              BX       lr
;;;599    
                          ENDP


                          AREA ||i.SAI_ReceiveData||, CODE, READONLY, ALIGN=1

                  SAI_ReceiveData PROC
;;;740      */
;;;741    uint32_t SAI_ReceiveData(SAI_Block_TypeDef* SAI_Block_x)
000000  4601              MOV      r1,r0
;;;742    {
;;;743      /* Check the parameters */
;;;744      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;745      
;;;746      /* Return the data in the DR register */
;;;747      return SAI_Block_x->DR;
000002  69c8              LDR      r0,[r1,#0x1c]
;;;748    }
000004  4770              BX       lr
;;;749    
                          ENDP


                          AREA ||i.SAI_SendData||, CODE, READONLY, ALIGN=1

                  SAI_SendData PROC
;;;756      */
;;;757    void SAI_SendData(SAI_Block_TypeDef* SAI_Block_x, uint32_t Data)
000000  61c1              STR      r1,[r0,#0x1c]
;;;758    {
;;;759      /* Check the parameters */
;;;760      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;761      
;;;762      /* Write in the DR register the data to be sent */
;;;763      SAI_Block_x->DR = Data;
;;;764    }
000002  4770              BX       lr
;;;765    
                          ENDP


                          AREA ||i.SAI_SlotInit||, CODE, READONLY, ALIGN=1

                  SAI_SlotInit PROC
;;;338      */
;;;339    void SAI_SlotInit(SAI_Block_TypeDef* SAI_Block_x, SAI_SlotInitTypeDef* SAI_SlotInitStruct)
000000  b510              PUSH     {r4,lr}
;;;340    {
;;;341      uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;342      
;;;343      /* Check the parameters */
;;;344      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;345      
;;;346      /* Check the SAI Block Slot parameters */
;;;347      assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(SAI_SlotInitStruct->SAI_FirstBitOffset));
;;;348      assert_param(IS_SAI_BLOCK_SLOT_SIZE(SAI_SlotInitStruct->SAI_SlotSize));
;;;349      assert_param(IS_SAI_BLOCK_SLOT_NUMBER(SAI_SlotInitStruct->SAI_SlotNumber));
;;;350      assert_param(IS_SAI_SLOT_ACTIVE(SAI_SlotInitStruct->SAI_SlotActive));
;;;351    
;;;352      /* SAI Block_x SLOTR Configuration */
;;;353      /* Get the SAI Block_x SLOTR value */
;;;354      tmpreg = SAI_Block_x->SLOTR;
000004  68c2              LDR      r2,[r0,#0xc]
;;;355      /* Clear FBOFF, SLOTSZ, NBSLOT, SLOTEN bits */
;;;356      tmpreg &= SLOTR_CLEAR_MASK;
000006  f24f0320          MOV      r3,#0xf020
00000a  401a              ANDS     r2,r2,r3
;;;357      /* Configure SAI_Block_x Slot: First bit offset, Slot size, Number of Slot in  
;;;358         audio frame and slots activated in audio frame */
;;;359      /* Set FBOFF bits according to SAI_FirstBitOffset value  */
;;;360      /* Set SLOTSZ bits according to SAI_SlotSize value       */
;;;361      /* Set NBSLOT bits according to SAI_SlotNumber value     */
;;;362      /* Set SLOTEN bits according to SAI_SlotActive value     */
;;;363      tmpreg |= (uint32_t)(SAI_SlotInitStruct->SAI_FirstBitOffset | 
00000c  e9d13400          LDRD     r3,r4,[r1,#0]
000010  4323              ORRS     r3,r3,r4
000012  68cc              LDR      r4,[r1,#0xc]
000014  4323              ORRS     r3,r3,r4
000016  688c              LDR      r4,[r1,#8]
000018  1e64              SUBS     r4,r4,#1
00001a  ea432304          ORR      r3,r3,r4,LSL #8
00001e  431a              ORRS     r2,r2,r3
;;;364                           SAI_SlotInitStruct->SAI_SlotSize       | 
;;;365                           SAI_SlotInitStruct->SAI_SlotActive     |    
;;;366                           (uint32_t)((SAI_SlotInitStruct->SAI_SlotNumber - 1) <<  8));
;;;367                           
;;;368      /* Write to SAI_Block_x SLOTR */
;;;369      SAI_Block_x->SLOTR = tmpreg;
000020  60c2              STR      r2,[r0,#0xc]
;;;370    }
000022  bd10              POP      {r4,pc}
;;;371    
                          ENDP


                          AREA ||i.SAI_SlotStructInit||, CODE, READONLY, ALIGN=1

                  SAI_SlotStructInit PROC
;;;431      */
;;;432    void SAI_SlotStructInit(SAI_SlotInitTypeDef* SAI_SlotInitStruct)
000000  2100              MOVS     r1,#0
;;;433    {
;;;434      /* Reset SAI Slot init structure parameters values */
;;;435      /* Initialize the SAI_FirstBitOffset member */
;;;436      SAI_SlotInitStruct->SAI_FirstBitOffset = 0;
000002  6001              STR      r1,[r0,#0]
;;;437      /* Initialize the SAI_SlotSize member */
;;;438      SAI_SlotInitStruct->SAI_SlotSize = SAI_SlotSize_DataSize;
000004  6041              STR      r1,[r0,#4]
;;;439      /* Initialize the SAI_SlotNumber member */
;;;440      SAI_SlotInitStruct->SAI_SlotNumber = 1;
000006  2101              MOVS     r1,#1
000008  6081              STR      r1,[r0,#8]
;;;441      /* Initialize the SAI_SlotActive member */
;;;442      SAI_SlotInitStruct->SAI_SlotActive = SAI_Slot_NotActive;
00000a  2100              MOVS     r1,#0
00000c  60c1              STR      r1,[r0,#0xc]
;;;443    
;;;444    }
00000e  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.SAI_StructInit||, CODE, READONLY, ALIGN=1

                  SAI_StructInit PROC
;;;377      */
;;;378    void SAI_StructInit(SAI_InitTypeDef* SAI_InitStruct)
000000  2100              MOVS     r1,#0
;;;379    {
;;;380      /* Reset SAI init structure parameters values */
;;;381      /* Initialize the SAI_AudioMode member */
;;;382      SAI_InitStruct->SAI_AudioMode = SAI_Mode_MasterTx;
000002  6001              STR      r1,[r0,#0]
;;;383      /* Initialize the SAI_Protocol member */
;;;384      SAI_InitStruct->SAI_Protocol = SAI_Free_Protocol;
000004  6041              STR      r1,[r0,#4]
;;;385      /* Initialize the SAI_DataSize member */
;;;386      SAI_InitStruct->SAI_DataSize = SAI_DataSize_8b;
000006  2140              MOVS     r1,#0x40
000008  6081              STR      r1,[r0,#8]
;;;387      /* Initialize the SAI_FirstBit member */
;;;388      SAI_InitStruct->SAI_FirstBit = SAI_FirstBit_MSB;
00000a  2100              MOVS     r1,#0
00000c  60c1              STR      r1,[r0,#0xc]
;;;389      /* Initialize the SAI_ClockStrobing member */
;;;390      SAI_InitStruct->SAI_ClockStrobing = SAI_ClockStrobing_FallingEdge;
00000e  6101              STR      r1,[r0,#0x10]
;;;391      /* Initialize the SAI_Synchro member */
;;;392      SAI_InitStruct->SAI_Synchro = SAI_Asynchronous;
000010  6141              STR      r1,[r0,#0x14]
;;;393        /* Initialize the SAI_SynchroExt member */
;;;394      SAI_InitStruct->SAI_SynchroExt = SAI_SyncExt_Disable;
000012  6181              STR      r1,[r0,#0x18]
;;;395      /* Initialize the SAI_OUTDRIV member */
;;;396      SAI_InitStruct->SAI_OUTDRIV = SAI_OutputDrive_Disabled;
000014  61c1              STR      r1,[r0,#0x1c]
;;;397      /* Initialize the SAI_NoDivider member */
;;;398      SAI_InitStruct->SAI_NoDivider = SAI_MasterDivider_Enabled;
000016  6201              STR      r1,[r0,#0x20]
;;;399      /* Initialize the SAI_MasterDivider member */
;;;400      SAI_InitStruct->SAI_MasterDivider = 0;
000018  6241              STR      r1,[r0,#0x24]
;;;401      /* Initialize the SAI_FIFOThreshold member */
;;;402      SAI_InitStruct->SAI_FIFOThreshold = SAI_Threshold_FIFOEmpty;
00001a  6281              STR      r1,[r0,#0x28]
;;;403    }
00001c  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.SAI_TRIStateConfig||, CODE, READONLY, ALIGN=1

                  SAI_TRIStateConfig PROC
;;;504      */
;;;505    void SAI_TRIStateConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_TRIState)
000000  6802              LDR      r2,[r0,#0]
;;;506    {
;;;507      /* Check the parameters */
;;;508      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;509      assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(SAI_TRIState));
;;;510      /* Clear MONO bit */
;;;511      SAI_Block_x->CR1 &= ~(SAI_xCR1_MONO);
000002  f4225280          BIC      r2,r2,#0x1000
000006  6002              STR      r2,[r0,#0]
;;;512      /* Set new Mono Mode value */
;;;513      SAI_Block_x->CR1 |= SAI_MonoMode;  
000008  6802              LDR      r2,[r0,#0]
00000a  f4425280          ORR      r2,r2,#0x1000
00000e  6002              STR      r2,[r0,#0]
;;;514      
;;;515    }
000010  4770              BX       lr
;;;516    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_sai.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_sai_c_191626f0____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___15_stm32f4xx_sai_c_191626f0____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_sai_c_191626f0____REVSH|
#line 153
|__asm___15_stm32f4xx_sai_c_191626f0____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_sai_c_191626f0____RRX|
#line 328
|__asm___15_stm32f4xx_sai_c_191626f0____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
