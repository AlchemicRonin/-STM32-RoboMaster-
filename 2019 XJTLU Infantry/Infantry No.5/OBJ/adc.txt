; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\adc.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\adc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\adc.crf ..\AHRS\adc.c]
                          THUMB

                          AREA ||i.get_ADC||, CODE, READONLY, ALIGN=2

                  get_ADC PROC
;;;51     
;;;52     uint16_t get_ADC(uint8_t ch)
000000  b510              PUSH     {r4,lr}
;;;53     {
000002  4604              MOV      r4,r0
;;;54     
;;;55         ADC_ClearFlag(ADC1,ADC_FLAG_STRT|ADC_FLAG_OVR|ADC_FLAG_EOC);
000004  2132              MOVS     r1,#0x32
000006  480b              LDR      r0,|L1.52|
000008  f7fffffe          BL       ADC_ClearFlag
;;;56         ADC_RegularChannelConfig(ADC1, ch, 1, ADC_SampleTime_15Cycles);
00000c  2301              MOVS     r3,#1
00000e  461a              MOV      r2,r3
000010  4621              MOV      r1,r4
000012  4808              LDR      r0,|L1.52|
000014  f7fffffe          BL       ADC_RegularChannelConfig
;;;57     
;;;58         ADC_SoftwareStartConv(ADC1);
000018  4806              LDR      r0,|L1.52|
00001a  f7fffffe          BL       ADC_SoftwareStartConv
;;;59     
;;;60         while (!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC))
00001e  bf00              NOP      
                  |L1.32|
000020  2102              MOVS     r1,#2
000022  4804              LDR      r0,|L1.52|
000024  f7fffffe          BL       ADC_GetFlagStatus
000028  2800              CMP      r0,#0
00002a  d0f9              BEQ      |L1.32|
;;;61         {
;;;62             ;
;;;63         }
;;;64         return ADC_GetConversionValue(ADC1);
00002c  4801              LDR      r0,|L1.52|
00002e  f7fffffe          BL       ADC_GetConversionValue
;;;65     }
000032  bd10              POP      {r4,pc}
;;;66     u8 get_set_temp(void)
                          ENDP

                  |L1.52|
                          DCD      0x40012000

                          AREA ||i.get_set_temp||, CODE, READONLY, ALIGN=2

                  get_set_temp PROC
;;;65     }
;;;66     u8 get_set_temp(void)
000000  b510              PUSH     {r4,lr}
;;;67     {
;;;68     	temperature.temp_set = (int8_t)(get_temprate()) + 10;
000002  f7fffffe          BL       get_temprate
000006  eebd0ac0          VCVT.S32.F32 s0,s0
00000a  ee100a10          VMOV     r0,s0
00000e  b240              SXTB     r0,r0
000010  300a              ADDS     r0,r0,#0xa
000012  ee000a10          VMOV     s0,r0
000016  eeb80ac0          VCVT.F32.S32 s0,s0
00001a  481e              LDR      r0,|L2.148|
00001c  ed800a00          VSTR     s0,[r0,#0]
;;;69     	if (temperature.temp_set > (int8_t)(temperature.temp_max_set))
000020  edd00a00          VLDR     s1,[r0,#0]
000024  ed900a02          VLDR     s0,[r0,#8]
000028  eebd0ac0          VCVT.S32.F32 s0,s0
00002c  ee100a10          VMOV     r0,s0
000030  b240              SXTB     r0,r0
000032  ee000a10          VMOV     s0,r0
000036  eeb80ac0          VCVT.F32.S32 s0,s0
00003a  eef40ac0          VCMPE.F32 s1,s0
00003e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000042  dd0e              BLE      |L2.98|
;;;70     	{
;;;71     			temperature.temp_set = (int8_t)(temperature.temp_max_set);
000044  4813              LDR      r0,|L2.148|
000046  ed900a02          VLDR     s0,[r0,#8]
00004a  eebd0ac0          VCVT.S32.F32 s0,s0
00004e  ee100a10          VMOV     r0,s0
000052  b240              SXTB     r0,r0
000054  ee000a10          VMOV     s0,r0
000058  eeb80ac0          VCVT.F32.S32 s0,s0
00005c  480d              LDR      r0,|L2.148|
00005e  ed800a00          VSTR     s0,[r0,#0]
                  |L2.98|
;;;72     	}
;;;73     	if(temperature.temp_set < 0)
000062  480c              LDR      r0,|L2.148|
000064  ed900a00          VLDR     s0,[r0,#0]
000068  eeb50ac0          VCMPE.F32 s0,#0.0
00006c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000070  d203              BCS      |L2.122|
;;;74     	{
;;;75     		temperature.temp_set = 0;
000072  ed9f0a09          VLDR     s0,|L2.152|
000076  ed800a00          VSTR     s0,[r0,#0]
                  |L2.122|
;;;76     	}
;;;77     	if((int8_t)(temperature.temp_set)  == (int8_t)(0.0f))
00007a  4806              LDR      r0,|L2.148|
00007c  ed900a00          VLDR     s0,[r0,#0]
000080  eebd0ac0          VCVT.S32.F32 s0,s0
000084  ee100a10          VMOV     r0,s0
000088  b240              SXTB     r0,r0
00008a  b908              CBNZ     r0,|L2.144|
;;;78     		return 0;
00008c  2000              MOVS     r0,#0
                  |L2.142|
;;;79     	else 
;;;80     		return 1;
;;;81     	
;;;82     }
00008e  bd10              POP      {r4,pc}
                  |L2.144|
000090  2001              MOVS     r0,#1                 ;80
000092  e7fc              B        |L2.142|
                          ENDP

                  |L2.148|
                          DCD      temperature
                  |L2.152|
000098  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.get_temprate||, CODE, READONLY, ALIGN=2

                  get_temprate PROC
;;;40     
;;;41     fp32 get_temprate(void)
000000  b510              PUSH     {r4,lr}
;;;42     {
000002  ed2d8b02          VPUSH    {d8}
;;;43         uint16_t adcx = 0;
000006  2000              MOVS     r0,#0
000008  ee080a90          VMOV     s17,r0
;;;44         fp32 temperate;
;;;45         temperature_ADC_Reset();
00000c  f7fffffe          BL       temperature_ADC_Reset
;;;46         adcx = get_ADC(ADC_Channel_18);
000010  2012              MOVS     r0,#0x12
000012  f7fffffe          BL       get_ADC
000016  ee080a90          VMOV     s17,r0
;;;47         temperate = (fp32)adcx * (3.3f / 4096.0f);
00001a  eeb80a68          VCVT.F32.U32 s0,s17
00001e  eddf0a0c          VLDR     s1,|L3.80|
000022  ee200a20          VMUL.F32 s0,s0,s1
000026  eeb08a40          VMOV.F32 s16,s0
;;;48         temperate = (temperate - 0.76f) / 0.0025f + 25.0f;
00002a  ed9f0a0a          VLDR     s0,|L3.84|
00002e  ee380a40          VSUB.F32 s0,s16,s0
000032  eddf0a09          VLDR     s1,|L3.88|
000036  ee801a20          VDIV.F32 s2,s0,s1
00003a  eeb30a09          VMOV.F32 s0,#25.00000000
00003e  ee310a00          VADD.F32 s0,s2,s0
000042  eeb08a40          VMOV.F32 s16,s0
;;;49         return temperate;
000046  eeb00a48          VMOV.F32 s0,s16
;;;50     }
00004a  ecbd8b02          VPOP     {d8}
00004e  bd10              POP      {r4,pc}
;;;51     
                          ENDP

                  |L3.80|
000050  3a533333          DCFS     0x3a533333 ; 0.00080566405085846782
                  |L3.84|
000054  3f428f5c          DCFS     0x3f428f5c ; 0.75999999046325684
                  |L3.88|
000058  3b23d70a          DCFS     0x3b23d70a ; 0.0024999999441206455

                          AREA ||i.temperature_ADC_Reset||, CODE, READONLY, ALIGN=2

                  temperature_ADC_Reset PROC
;;;27     
;;;28     void temperature_ADC_Reset(void)
000000  b500              PUSH     {lr}
;;;29     {
000002  b087              SUB      sp,sp,#0x1c
;;;30         ADC_InitTypeDef ADC_InitStructure;
;;;31         ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
;;;32         ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000008  f88d0008          STRB     r0,[sp,#8]
;;;33         ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
00000c  f88d0009          STRB     r0,[sp,#9]
;;;34         ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
000010  9003              STR      r0,[sp,#0xc]
;;;35         ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000012  9005              STR      r0,[sp,#0x14]
;;;36         ADC_InitStructure.ADC_NbrOfConversion = 1;
000014  2001              MOVS     r0,#1
000016  f88d0018          STRB     r0,[sp,#0x18]
;;;37         ADC_Init(ADC1, &ADC_InitStructure);
00001a  a901              ADD      r1,sp,#4
00001c  4802              LDR      r0,|L4.40|
00001e  f7fffffe          BL       ADC_Init
;;;38     
;;;39     }
000022  b007              ADD      sp,sp,#0x1c
000024  bd00              POP      {pc}
;;;40     
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40012000

                          AREA ||i.temperature_ADC_init||, CODE, READONLY, ALIGN=2

                  temperature_ADC_init PROC
;;;5      
;;;6      void temperature_ADC_init(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;7      {
;;;8          ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;9      
;;;10         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
000002  2101              MOVS     r1,#1
000004  0208              LSLS     r0,r1,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;11     
;;;12         RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0208              LSLS     r0,r1,#8
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;13         RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f44f7080          MOV      r0,#0x100
000018  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;14     
;;;15         ADC_TempSensorVrefintCmd(ENABLE);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       ADC_TempSensorVrefintCmd
;;;16     
;;;17         ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
000022  2000              MOVS     r0,#0
000024  9000              STR      r0,[sp,#0]
;;;18         ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
000026  9003              STR      r0,[sp,#0xc]
;;;19         ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
000028  9002              STR      r0,[sp,#8]
;;;20         ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4;
00002a  f44f3080          MOV      r0,#0x10000
00002e  9001              STR      r0,[sp,#4]
;;;21         ADC_CommonInit(&ADC_CommonInitStructure);
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       ADC_CommonInit
;;;22         temperature_ADC_Reset();
000036  f7fffffe          BL       temperature_ADC_Reset
;;;23     
;;;24         ADC_RegularChannelConfig(ADC1, ADC_Channel_18, 1, ADC_SampleTime_15Cycles);
00003a  2301              MOVS     r3,#1
00003c  461a              MOV      r2,r3
00003e  2112              MOVS     r1,#0x12
000040  4803              LDR      r0,|L5.80|
000042  f7fffffe          BL       ADC_RegularChannelConfig
;;;25         ADC_Cmd(ADC1, ENABLE);
000046  2101              MOVS     r1,#1
000048  4801              LDR      r0,|L5.80|
00004a  f7fffffe          BL       ADC_Cmd
;;;26     }
00004e  bd1f              POP      {r0-r4,pc}
;;;27     
                          ENDP

                  |L5.80|
                          DCD      0x40012000

                          AREA ||.data||, DATA, ALIGN=2

                  temperature
000000  00000000          DCFS     0x00000000 ; 0
000004  00000000          DCFS     0x00000000 ; 0
000008  42200000          DCFS     0x42200000 ; 40

;*** Start embedded assembler ***

#line 1 "..\\AHRS\\adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_be4e2a6c____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___5_adc_c_be4e2a6c____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_be4e2a6c____REVSH|
#line 153
|__asm___5_adc_c_be4e2a6c____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_be4e2a6c____RRX|
#line 328
|__asm___5_adc_c_be4e2a6c____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
