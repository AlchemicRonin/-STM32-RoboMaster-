; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_fmc.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_fmc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_fmc.crf ..\FWLIB\src\stm32f4xx_fmc.c]
                          THUMB

                          AREA ||i.FMC_ClearFlag||, CODE, READONLY, ALIGN=2

                  FMC_ClearFlag PROC
;;;1349     */
;;;1350   void FMC_ClearFlag(uint32_t FMC_Bank, uint32_t FMC_FLAG)
000000  2810              CMP      r0,#0x10
;;;1351   {
;;;1352    /* Check the parameters */
;;;1353     assert_param(IS_FMC_GETFLAG_BANK(FMC_Bank));
;;;1354     assert_param(IS_FMC_CLEAR_FLAG(FMC_FLAG)) ;
;;;1355       
;;;1356     if(FMC_Bank == FMC_Bank2_NAND)
000002  d107              BNE      |L1.20|
;;;1357     {
;;;1358       FMC_Bank2->SR2 &= (~FMC_FLAG); 
000004  f04f4220          MOV      r2,#0xa0000000
000008  6e52              LDR      r2,[r2,#0x64]
00000a  438a              BICS     r2,r2,r1
00000c  f04f4320          MOV      r3,#0xa0000000
000010  665a              STR      r2,[r3,#0x64]
000012  e01e              B        |L1.82|
                  |L1.20|
;;;1359     }  
;;;1360     else if(FMC_Bank == FMC_Bank3_NAND)
000014  f5b07f80          CMP      r0,#0x100
000018  d107              BNE      |L1.42|
;;;1361     {
;;;1362       FMC_Bank3->SR3 &= (~FMC_FLAG);
00001a  4a0e              LDR      r2,|L1.84|
00001c  6812              LDR      r2,[r2,#0]
00001e  438a              BICS     r2,r2,r1
000020  f04f4320          MOV      r3,#0xa0000000
000024  f8c32084          STR      r2,[r3,#0x84]
000028  e013              B        |L1.82|
                  |L1.42|
;;;1363     }
;;;1364     else if(FMC_Bank == FMC_Bank4_PCCARD)
00002a  f5b05f80          CMP      r0,#0x1000
00002e  d108              BNE      |L1.66|
;;;1365     {
;;;1366       FMC_Bank4->SR4 &= (~FMC_FLAG);
000030  4a08              LDR      r2,|L1.84|
000032  3220              ADDS     r2,r2,#0x20
000034  6812              LDR      r2,[r2,#0]
000036  438a              BICS     r2,r2,r1
000038  f04f4320          MOV      r3,#0xa0000000
00003c  f8c320a4          STR      r2,[r3,#0xa4]
000040  e007              B        |L1.82|
                  |L1.66|
;;;1367     }
;;;1368     /* FMC_Bank5_6 SDRAM*/
;;;1369     else
;;;1370     {
;;;1371       FMC_Bank5_6->SDRTR &= (~FMC_FLAG);
000042  4a04              LDR      r2,|L1.84|
000044  32d0              ADDS     r2,r2,#0xd0
000046  6812              LDR      r2,[r2,#0]
000048  438a              BICS     r2,r2,r1
00004a  f04f4320          MOV      r3,#0xa0000000
00004e  f8c32154          STR      r2,[r3,#0x154]
                  |L1.82|
;;;1372     }
;;;1373     
;;;1374   }
000052  4770              BX       lr
;;;1375   
                          ENDP

                  |L1.84|
                          DCD      0xa0000084

                          AREA ||i.FMC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  FMC_ClearITPendingBit PROC
;;;1464     */
;;;1465   void FMC_ClearITPendingBit(uint32_t FMC_Bank, uint32_t FMC_IT)
000000  2810              CMP      r0,#0x10
;;;1466   {
;;;1467     /* Check the parameters */
;;;1468     assert_param(IS_FMC_IT_BANK(FMC_Bank));
;;;1469     assert_param(IS_FMC_IT(FMC_IT));
;;;1470       
;;;1471     if(FMC_Bank == FMC_Bank2_NAND)
000002  d108              BNE      |L2.22|
;;;1472     {
;;;1473       FMC_Bank2->SR2 &= ~(FMC_IT >> 3); 
000004  f04f4220          MOV      r2,#0xa0000000
000008  6e52              LDR      r2,[r2,#0x64]
00000a  ea2202d1          BIC      r2,r2,r1,LSR #3
00000e  f04f4320          MOV      r3,#0xa0000000
000012  665a              STR      r2,[r3,#0x64]
000014  e021              B        |L2.90|
                  |L2.22|
;;;1474     }  
;;;1475     else if(FMC_Bank == FMC_Bank3_NAND)
000016  f5b07f80          CMP      r0,#0x100
00001a  d108              BNE      |L2.46|
;;;1476     {
;;;1477       FMC_Bank3->SR3 &= ~(FMC_IT >> 3);
00001c  4a0f              LDR      r2,|L2.92|
00001e  6812              LDR      r2,[r2,#0]
000020  ea2202d1          BIC      r2,r2,r1,LSR #3
000024  f04f4320          MOV      r3,#0xa0000000
000028  f8c32084          STR      r2,[r3,#0x84]
00002c  e015              B        |L2.90|
                  |L2.46|
;;;1478     }
;;;1479     else if(FMC_Bank == FMC_Bank4_PCCARD)
00002e  f5b05f80          CMP      r0,#0x1000
000032  d109              BNE      |L2.72|
;;;1480     {
;;;1481       FMC_Bank4->SR4 &= ~(FMC_IT >> 3);
000034  4a09              LDR      r2,|L2.92|
000036  3220              ADDS     r2,r2,#0x20
000038  6812              LDR      r2,[r2,#0]
00003a  ea2202d1          BIC      r2,r2,r1,LSR #3
00003e  f04f4320          MOV      r3,#0xa0000000
000042  f8c320a4          STR      r2,[r3,#0xa4]
000046  e008              B        |L2.90|
                  |L2.72|
;;;1482     }
;;;1483     /* FMC_Bank5_6 SDRAM*/
;;;1484     else
;;;1485     {
;;;1486       FMC_Bank5_6->SDRTR |= FMC_SDRTR_CRE;
000048  4a04              LDR      r2,|L2.92|
00004a  32d0              ADDS     r2,r2,#0xd0
00004c  6812              LDR      r2,[r2,#0]
00004e  f0420201          ORR      r2,r2,#1
000052  f04f4320          MOV      r3,#0xa0000000
000056  f8c32154          STR      r2,[r3,#0x154]
                  |L2.90|
;;;1487     }
;;;1488   }
00005a  4770              BX       lr
;;;1489   
                          ENDP

                  |L2.92|
                          DCD      0xa0000084

                          AREA ||i.FMC_GetECC||, CODE, READONLY, ALIGN=2

                  FMC_GetECC PROC
;;;635      */
;;;636    uint32_t FMC_GetECC(uint32_t FMC_Bank)
000000  4601              MOV      r1,r0
;;;637    {
;;;638      uint32_t eccval = 0x00000000;
000002  2000              MOVS     r0,#0
;;;639      
;;;640      if(FMC_Bank == FMC_Bank2_NAND)
000004  2910              CMP      r1,#0x10
000006  d103              BNE      |L3.16|
;;;641      {
;;;642        /* Get the ECCR2 register value */
;;;643        eccval = FMC_Bank2->ECCR2;
000008  f04f4220          MOV      r2,#0xa0000000
00000c  6f50              LDR      r0,[r2,#0x74]
00000e  e001              B        |L3.20|
                  |L3.16|
;;;644      }
;;;645      else
;;;646      {
;;;647        /* Get the ECCR3 register value */
;;;648        eccval = FMC_Bank3->ECCR3;
000010  4a01              LDR      r2,|L3.24|
000012  6810              LDR      r0,[r2,#0]
                  |L3.20|
;;;649      }
;;;650      /* Return the error correction code value */
;;;651      return(eccval);
;;;652    }
000014  4770              BX       lr
;;;653    /**
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      0xa0000094

                          AREA ||i.FMC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FMC_GetFlagStatus PROC
;;;1293     */
;;;1294   FlagStatus FMC_GetFlagStatus(uint32_t FMC_Bank, uint32_t FMC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1295   {
000002  4602              MOV      r2,r0
;;;1296     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1297     uint32_t tmpsr = 0x00000000;
000006  2300              MOVS     r3,#0
;;;1298     
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_FMC_GETFLAG_BANK(FMC_Bank));
;;;1301     assert_param(IS_FMC_GET_FLAG(FMC_FLAG));
;;;1302     
;;;1303     if(FMC_Bank == FMC_Bank2_NAND)
000008  2a10              CMP      r2,#0x10
00000a  d103              BNE      |L4.20|
;;;1304     {
;;;1305       tmpsr = FMC_Bank2->SR2;
00000c  f04f4420          MOV      r4,#0xa0000000
000010  6e63              LDR      r3,[r4,#0x64]
000012  e00f              B        |L4.52|
                  |L4.20|
;;;1306     }  
;;;1307     else if(FMC_Bank == FMC_Bank3_NAND)
000014  f5b27f80          CMP      r2,#0x100
000018  d102              BNE      |L4.32|
;;;1308     {
;;;1309       tmpsr = FMC_Bank3->SR3;
00001a  4c0a              LDR      r4,|L4.68|
00001c  6823              LDR      r3,[r4,#0]
00001e  e009              B        |L4.52|
                  |L4.32|
;;;1310     }
;;;1311     else if(FMC_Bank == FMC_Bank4_PCCARD)
000020  f5b25f80          CMP      r2,#0x1000
000024  d103              BNE      |L4.46|
;;;1312     {
;;;1313       tmpsr = FMC_Bank4->SR4;
000026  4c07              LDR      r4,|L4.68|
000028  3420              ADDS     r4,r4,#0x20
00002a  6823              LDR      r3,[r4,#0]
00002c  e002              B        |L4.52|
                  |L4.46|
;;;1314     }
;;;1315     else 
;;;1316     {
;;;1317       tmpsr = FMC_Bank5_6->SDSR;
00002e  4c05              LDR      r4,|L4.68|
000030  34d4              ADDS     r4,r4,#0xd4
000032  6823              LDR      r3,[r4,#0]
                  |L4.52|
;;;1318     }
;;;1319     
;;;1320     /* Get the flag status */
;;;1321     if ((tmpsr & FMC_FLAG) != FMC_FLAG )
000034  ea030401          AND      r4,r3,r1
000038  428c              CMP      r4,r1
00003a  d001              BEQ      |L4.64|
;;;1322     {
;;;1323       bitstatus = RESET;
00003c  2000              MOVS     r0,#0
00003e  e000              B        |L4.66|
                  |L4.64|
;;;1324     }
;;;1325     else
;;;1326     {
;;;1327       bitstatus = SET;
000040  2001              MOVS     r0,#1
                  |L4.66|
;;;1328     }
;;;1329     /* Return the flag status */
;;;1330     return bitstatus;
;;;1331   }
000042  bd10              POP      {r4,pc}
;;;1332   
                          ENDP

                  |L4.68|
                          DCD      0xa0000084

                          AREA ||i.FMC_GetITStatus||, CODE, READONLY, ALIGN=2

                  FMC_GetITStatus PROC
;;;1392     */
;;;1393   ITStatus FMC_GetITStatus(uint32_t FMC_Bank, uint32_t FMC_IT)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1394   {
000002  4602              MOV      r2,r0
;;;1395     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1396     uint32_t tmpsr = 0x0;
000006  2300              MOVS     r3,#0
;;;1397     uint32_t tmpsr2 = 0x0;
000008  2400              MOVS     r4,#0
;;;1398     uint32_t itstatus = 0x0;
00000a  2500              MOVS     r5,#0
;;;1399     uint32_t itenable = 0x0; 
00000c  2600              MOVS     r6,#0
;;;1400     
;;;1401     /* Check the parameters */
;;;1402     assert_param(IS_FMC_IT_BANK(FMC_Bank));
;;;1403     assert_param(IS_FMC_GET_IT(FMC_IT));
;;;1404     
;;;1405     if(FMC_Bank == FMC_Bank2_NAND)
00000e  2a10              CMP      r2,#0x10
000010  d103              BNE      |L5.26|
;;;1406     {
;;;1407       tmpsr = FMC_Bank2->SR2;
000012  f04f4720          MOV      r7,#0xa0000000
000016  6e7b              LDR      r3,[r7,#0x64]
000018  e012              B        |L5.64|
                  |L5.26|
;;;1408     }  
;;;1409     else if(FMC_Bank == FMC_Bank3_NAND)
00001a  f5b27f80          CMP      r2,#0x100
00001e  d102              BNE      |L5.38|
;;;1410     {
;;;1411       tmpsr = FMC_Bank3->SR3;
000020  4f0f              LDR      r7,|L5.96|
000022  683b              LDR      r3,[r7,#0]
000024  e00c              B        |L5.64|
                  |L5.38|
;;;1412     }
;;;1413     else if(FMC_Bank == FMC_Bank4_PCCARD)
000026  f5b25f80          CMP      r2,#0x1000
00002a  d103              BNE      |L5.52|
;;;1414     {
;;;1415       tmpsr = FMC_Bank4->SR4;
00002c  4f0c              LDR      r7,|L5.96|
00002e  3720              ADDS     r7,r7,#0x20
000030  683b              LDR      r3,[r7,#0]
000032  e005              B        |L5.64|
                  |L5.52|
;;;1416     }
;;;1417     /* FMC_Bank5_6 SDRAM*/
;;;1418     else
;;;1419     {
;;;1420       tmpsr = FMC_Bank5_6->SDRTR;
000034  4f0a              LDR      r7,|L5.96|
000036  37d0              ADDS     r7,r7,#0xd0
000038  683b              LDR      r3,[r7,#0]
;;;1421       tmpsr2 = FMC_Bank5_6->SDSR;
00003a  06ff              LSLS     r7,r7,#27
00003c  f8d74158          LDR      r4,[r7,#0x158]
                  |L5.64|
;;;1422     } 
;;;1423     
;;;1424     /* get the IT enable bit status*/
;;;1425     itenable = tmpsr & FMC_IT;
000040  ea030601          AND      r6,r3,r1
;;;1426     
;;;1427     /* get the corresponding IT Flag status*/
;;;1428     if((FMC_Bank == FMC_Bank1_SDRAM) || (FMC_Bank == FMC_Bank2_SDRAM))
000044  b10a              CBZ      r2,|L5.74|
000046  2a01              CMP      r2,#1
000048  d102              BNE      |L5.80|
                  |L5.74|
;;;1429     {
;;;1430       itstatus = tmpsr2 & FMC_SDSR_RE;  
00004a  f0040501          AND      r5,r4,#1
00004e  e001              B        |L5.84|
                  |L5.80|
;;;1431     }           
;;;1432     else
;;;1433     {
;;;1434       itstatus = tmpsr & (FMC_IT >> 3);  
000050  ea0305d1          AND      r5,r3,r1,LSR #3
                  |L5.84|
;;;1435     }  
;;;1436     
;;;1437     if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
000054  b115              CBZ      r5,|L5.92|
000056  b10e              CBZ      r6,|L5.92|
;;;1438     {
;;;1439       bitstatus = SET;
000058  2001              MOVS     r0,#1
00005a  e000              B        |L5.94|
                  |L5.92|
;;;1440     }
;;;1441     else
;;;1442     {
;;;1443       bitstatus = RESET;
00005c  2000              MOVS     r0,#0
                  |L5.94|
;;;1444     }
;;;1445     return bitstatus; 
;;;1446   }
00005e  bdf0              POP      {r4-r7,pc}
;;;1447   
                          ENDP

                  |L5.96|
                          DCD      0xa0000084

                          AREA ||i.FMC_GetModeStatus||, CODE, READONLY, ALIGN=2

                  FMC_GetModeStatus PROC
;;;1108     */
;;;1109   uint32_t FMC_GetModeStatus(uint32_t SDRAM_Bank)
000000  4601              MOV      r1,r0
;;;1110   {
;;;1111     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1112     
;;;1113     /* Check the parameter */
;;;1114     assert_param(IS_FMC_SDRAM_BANK(SDRAM_Bank));
;;;1115   
;;;1116     /* Get the busy flag status */
;;;1117     if(SDRAM_Bank == FMC_Bank1_SDRAM)
000004  b921              CBNZ     r1,|L6.16|
;;;1118     {
;;;1119       tmpreg = (uint32_t)(FMC_Bank5_6->SDSR & FMC_SDSR_MODES1); 
000006  4a05              LDR      r2,|L6.28|
000008  6812              LDR      r2,[r2,#0]
00000a  f0020006          AND      r0,r2,#6
00000e  e004              B        |L6.26|
                  |L6.16|
;;;1120     }
;;;1121     else
;;;1122     {
;;;1123       tmpreg = ((uint32_t)(FMC_Bank5_6->SDSR & FMC_SDSR_MODES2) >> 2);
000010  4a02              LDR      r2,|L6.28|
000012  6812              LDR      r2,[r2,#0]
000014  f0020218          AND      r2,r2,#0x18
000018  0890              LSRS     r0,r2,#2
                  |L6.26|
;;;1124     }
;;;1125     
;;;1126     /* Return the mode status */
;;;1127     return tmpreg;
;;;1128   }
00001a  4770              BX       lr
;;;1129   
                          ENDP

                  |L6.28|
                          DCD      0xa0000158

                          AREA ||i.FMC_ITConfig||, CODE, READONLY, ALIGN=2

                  FMC_ITConfig PROC
;;;1216     */
;;;1217   void FMC_ITConfig(uint32_t FMC_Bank, uint32_t FMC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1218   {
;;;1219     assert_param(IS_FMC_IT_BANK(FMC_Bank));
;;;1220     assert_param(IS_FMC_IT(FMC_IT));	
;;;1221     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1222     
;;;1223     if (NewState != DISABLE)
000002  b34a              CBZ      r2,|L7.88|
;;;1224     {
;;;1225       /* Enable the selected FMC_Bank2 interrupts */
;;;1226       if(FMC_Bank == FMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d107              BNE      |L7.24|
;;;1227       {
;;;1228         FMC_Bank2->SR2 |= FMC_IT;
000008  f04f4320          MOV      r3,#0xa0000000
00000c  6e5b              LDR      r3,[r3,#0x64]
00000e  430b              ORRS     r3,r3,r1
000010  f04f4420          MOV      r4,#0xa0000000
000014  6663              STR      r3,[r4,#0x64]
000016  e048              B        |L7.170|
                  |L7.24|
;;;1229       }
;;;1230       /* Enable the selected FMC_Bank3 interrupts */
;;;1231       else if (FMC_Bank == FMC_Bank3_NAND)
000018  f5b07f80          CMP      r0,#0x100
00001c  d107              BNE      |L7.46|
;;;1232       {
;;;1233         FMC_Bank3->SR3 |= FMC_IT;
00001e  4b23              LDR      r3,|L7.172|
000020  681b              LDR      r3,[r3,#0]
000022  430b              ORRS     r3,r3,r1
000024  f04f4420          MOV      r4,#0xa0000000
000028  f8c43084          STR      r3,[r4,#0x84]
00002c  e03d              B        |L7.170|
                  |L7.46|
;;;1234       }
;;;1235       /* Enable the selected FMC_Bank4 interrupts */
;;;1236       else if (FMC_Bank == FMC_Bank4_PCCARD)
00002e  f5b05f80          CMP      r0,#0x1000
000032  d108              BNE      |L7.70|
;;;1237       {
;;;1238         FMC_Bank4->SR4 |= FMC_IT;    
000034  4b1d              LDR      r3,|L7.172|
000036  3320              ADDS     r3,r3,#0x20
000038  681b              LDR      r3,[r3,#0]
00003a  430b              ORRS     r3,r3,r1
00003c  f04f4420          MOV      r4,#0xa0000000
000040  f8c430a4          STR      r3,[r4,#0xa4]
000044  e031              B        |L7.170|
                  |L7.70|
;;;1239       }
;;;1240       /* Enable the selected FMC_Bank5_6 interrupt */
;;;1241       else
;;;1242       {
;;;1243         /* Enables the interrupt if the refresh error flag is set */
;;;1244         FMC_Bank5_6->SDRTR |= FMC_IT; 
000046  4b19              LDR      r3,|L7.172|
000048  33d0              ADDS     r3,r3,#0xd0
00004a  681b              LDR      r3,[r3,#0]
00004c  430b              ORRS     r3,r3,r1
00004e  f04f4420          MOV      r4,#0xa0000000
000052  f8c43154          STR      r3,[r4,#0x154]
000056  e028              B        |L7.170|
                  |L7.88|
;;;1245       }
;;;1246     }
;;;1247     else
;;;1248     {
;;;1249       /* Disable the selected FMC_Bank2 interrupts */
;;;1250       if(FMC_Bank == FMC_Bank2_NAND)
000058  2810              CMP      r0,#0x10
00005a  d107              BNE      |L7.108|
;;;1251       {
;;;1252         
;;;1253         FMC_Bank2->SR2 &= (uint32_t)~FMC_IT;
00005c  f04f4320          MOV      r3,#0xa0000000
000060  6e5b              LDR      r3,[r3,#0x64]
000062  438b              BICS     r3,r3,r1
000064  f04f4420          MOV      r4,#0xa0000000
000068  6663              STR      r3,[r4,#0x64]
00006a  e01e              B        |L7.170|
                  |L7.108|
;;;1254       }
;;;1255       /* Disable the selected FMC_Bank3 interrupts */
;;;1256       else if (FMC_Bank == FMC_Bank3_NAND)
00006c  f5b07f80          CMP      r0,#0x100
000070  d107              BNE      |L7.130|
;;;1257       {
;;;1258         FMC_Bank3->SR3 &= (uint32_t)~FMC_IT;
000072  4b0e              LDR      r3,|L7.172|
000074  681b              LDR      r3,[r3,#0]
000076  438b              BICS     r3,r3,r1
000078  f04f4420          MOV      r4,#0xa0000000
00007c  f8c43084          STR      r3,[r4,#0x84]
000080  e013              B        |L7.170|
                  |L7.130|
;;;1259       }
;;;1260       /* Disable the selected FMC_Bank4 interrupts */
;;;1261       else if(FMC_Bank == FMC_Bank4_PCCARD)
000082  f5b05f80          CMP      r0,#0x1000
000086  d108              BNE      |L7.154|
;;;1262       {
;;;1263         FMC_Bank4->SR4 &= (uint32_t)~FMC_IT;    
000088  4b08              LDR      r3,|L7.172|
00008a  3320              ADDS     r3,r3,#0x20
00008c  681b              LDR      r3,[r3,#0]
00008e  438b              BICS     r3,r3,r1
000090  f04f4420          MOV      r4,#0xa0000000
000094  f8c430a4          STR      r3,[r4,#0xa4]
000098  e007              B        |L7.170|
                  |L7.154|
;;;1264       }
;;;1265       /* Disable the selected FMC_Bank5_6 interrupt */
;;;1266       else
;;;1267       {
;;;1268         /* Disables the interrupt if the refresh error flag is not set */
;;;1269         FMC_Bank5_6->SDRTR &= (uint32_t)~FMC_IT; 
00009a  4b04              LDR      r3,|L7.172|
00009c  33d0              ADDS     r3,r3,#0xd0
00009e  681b              LDR      r3,[r3,#0]
0000a0  438b              BICS     r3,r3,r1
0000a2  f04f4420          MOV      r4,#0xa0000000
0000a6  f8c43154          STR      r3,[r4,#0x154]
                  |L7.170|
;;;1270       }
;;;1271     }
;;;1272   }
0000aa  bd10              POP      {r4,pc}
;;;1273   
                          ENDP

                  |L7.172|
                          DCD      0xa0000084

                          AREA ||i.FMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FMC_NANDCmd PROC
;;;556      */
;;;557    void FMC_NANDCmd(uint32_t FMC_Bank, FunctionalState NewState)
000000  b199              CBZ      r1,|L8.42|
;;;558    {
;;;559      assert_param(IS_FMC_NAND_BANK(FMC_Bank));
;;;560      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;561      
;;;562      if (NewState != DISABLE)
;;;563      {
;;;564        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;565        if(FMC_Bank == FMC_Bank2_NAND)
000002  2810              CMP      r0,#0x10
000004  d108              BNE      |L8.24|
;;;566        {
;;;567          FMC_Bank2->PCR2 |= PCR_PBKEN_SET;
000006  f04f4220          MOV      r2,#0xa0000000
00000a  6e12              LDR      r2,[r2,#0x60]
00000c  f0420204          ORR      r2,r2,#4
000010  f04f4320          MOV      r3,#0xa0000000
000014  661a              STR      r2,[r3,#0x60]
000016  e01b              B        |L8.80|
                  |L8.24|
;;;568        }
;;;569        else
;;;570        {
;;;571          FMC_Bank3->PCR3 |= PCR_PBKEN_SET;
000018  4a0e              LDR      r2,|L8.84|
00001a  6812              LDR      r2,[r2,#0]
00001c  f0420204          ORR      r2,r2,#4
000020  f04f4320          MOV      r3,#0xa0000000
000024  f8c32080          STR      r2,[r3,#0x80]
000028  e012              B        |L8.80|
                  |L8.42|
;;;572        }
;;;573      }
;;;574      else
;;;575      {
;;;576        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;577        if(FMC_Bank == FMC_Bank2_NAND)
00002a  2810              CMP      r0,#0x10
00002c  d108              BNE      |L8.64|
;;;578        {
;;;579          FMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
00002e  f04f4220          MOV      r2,#0xa0000000
000032  6e12              LDR      r2,[r2,#0x60]
000034  4b08              LDR      r3,|L8.88|
000036  401a              ANDS     r2,r2,r3
000038  f04f4320          MOV      r3,#0xa0000000
00003c  661a              STR      r2,[r3,#0x60]
00003e  e007              B        |L8.80|
                  |L8.64|
;;;580        }
;;;581        else
;;;582        {
;;;583          FMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
000040  4a04              LDR      r2,|L8.84|
000042  6812              LDR      r2,[r2,#0]
000044  4b04              LDR      r3,|L8.88|
000046  401a              ANDS     r2,r2,r3
000048  f04f4320          MOV      r3,#0xa0000000
00004c  f8c32080          STR      r2,[r3,#0x80]
                  |L8.80|
;;;584        }
;;;585      }
;;;586    }
000050  4770              BX       lr
;;;587    /**
                          ENDP

000052  0000              DCW      0x0000
                  |L8.84|
                          DCD      0xa0000080
                  |L8.88|
                          DCD      0x000ffffb

                          AREA ||i.FMC_NANDDeInit||, CODE, READONLY, ALIGN=2

                  FMC_NANDDeInit PROC
;;;385      */
;;;386    void FMC_NANDDeInit(uint32_t FMC_Bank)
000000  2810              CMP      r0,#0x10
;;;387    {
;;;388      /* Check the parameter */
;;;389      assert_param(IS_FMC_NAND_BANK(FMC_Bank));
;;;390      
;;;391      if(FMC_Bank == FMC_Bank2_NAND)
000002  d10a              BNE      |L9.26|
;;;392      {
;;;393        /* Set the FMC_Bank2 registers to their reset values */
;;;394        FMC_Bank2->PCR2 = 0x00000018;
000004  2118              MOVS     r1,#0x18
000006  f04f4220          MOV      r2,#0xa0000000
00000a  6611              STR      r1,[r2,#0x60]
;;;395        FMC_Bank2->SR2 = 0x00000040;
00000c  2140              MOVS     r1,#0x40
00000e  6651              STR      r1,[r2,#0x64]
;;;396        FMC_Bank2->PMEM2 = 0xFCFCFCFC;
000010  f04f31fc          MOV      r1,#0xfcfcfcfc
000014  6691              STR      r1,[r2,#0x68]
;;;397        FMC_Bank2->PATT2 = 0xFCFCFCFC;  
000016  66d1              STR      r1,[r2,#0x6c]
000018  e010              B        |L9.60|
                  |L9.26|
;;;398      }
;;;399      /* FMC_Bank3_NAND */  
;;;400      else
;;;401      {
;;;402        /* Set the FMC_Bank3 registers to their reset values */
;;;403        FMC_Bank3->PCR3 = 0x00000018;
00001a  2118              MOVS     r1,#0x18
00001c  4a08              LDR      r2,|L9.64|
00001e  6011              STR      r1,[r2,#0]
;;;404        FMC_Bank3->SR3 = 0x00000040;
000020  2140              MOVS     r1,#0x40
000022  f04f4220          MOV      r2,#0xa0000000
000026  f8c21084          STR      r1,[r2,#0x84]
;;;405        FMC_Bank3->PMEM3 = 0xFCFCFCFC;
00002a  f04f31fc          MOV      r1,#0xfcfcfcfc
00002e  4a04              LDR      r2,|L9.64|
000030  3208              ADDS     r2,r2,#8
000032  6011              STR      r1,[r2,#0]
;;;406        FMC_Bank3->PATT3 = 0xFCFCFCFC; 
000034  f04f4220          MOV      r2,#0xa0000000
000038  f8c2108c          STR      r1,[r2,#0x8c]
                  |L9.60|
;;;407      }  
;;;408    }
00003c  4770              BX       lr
;;;409    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      0xa0000080

                          AREA ||i.FMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FMC_NANDECCCmd PROC
;;;596      */
;;;597    void FMC_NANDECCCmd(uint32_t FMC_Bank, FunctionalState NewState)
000000  b199              CBZ      r1,|L10.42|
;;;598    {
;;;599      assert_param(IS_FMC_NAND_BANK(FMC_Bank));
;;;600      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;601      
;;;602      if (NewState != DISABLE)
;;;603      {
;;;604        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;605        if(FMC_Bank == FMC_Bank2_NAND)
000002  2810              CMP      r0,#0x10
000004  d108              BNE      |L10.24|
;;;606        {
;;;607          FMC_Bank2->PCR2 |= PCR_ECCEN_SET;
000006  f04f4220          MOV      r2,#0xa0000000
00000a  6e12              LDR      r2,[r2,#0x60]
00000c  f0420240          ORR      r2,r2,#0x40
000010  f04f4320          MOV      r3,#0xa0000000
000014  661a              STR      r2,[r3,#0x60]
000016  e01b              B        |L10.80|
                  |L10.24|
;;;608        }
;;;609        else
;;;610        {
;;;611          FMC_Bank3->PCR3 |= PCR_ECCEN_SET;
000018  4a0e              LDR      r2,|L10.84|
00001a  6812              LDR      r2,[r2,#0]
00001c  f0420240          ORR      r2,r2,#0x40
000020  f04f4320          MOV      r3,#0xa0000000
000024  f8c32080          STR      r2,[r3,#0x80]
000028  e012              B        |L10.80|
                  |L10.42|
;;;612        }
;;;613      }
;;;614      else
;;;615      {
;;;616        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;617        if(FMC_Bank == FMC_Bank2_NAND)
00002a  2810              CMP      r0,#0x10
00002c  d108              BNE      |L10.64|
;;;618        {
;;;619          FMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
00002e  f04f4220          MOV      r2,#0xa0000000
000032  6e12              LDR      r2,[r2,#0x60]
000034  4b08              LDR      r3,|L10.88|
000036  401a              ANDS     r2,r2,r3
000038  f04f4320          MOV      r3,#0xa0000000
00003c  661a              STR      r2,[r3,#0x60]
00003e  e007              B        |L10.80|
                  |L10.64|
;;;620        }
;;;621        else
;;;622        {
;;;623          FMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
000040  4a04              LDR      r2,|L10.84|
000042  6812              LDR      r2,[r2,#0]
000044  4b04              LDR      r3,|L10.88|
000046  401a              ANDS     r2,r2,r3
000048  f04f4320          MOV      r3,#0xa0000000
00004c  f8c32080          STR      r2,[r3,#0x80]
                  |L10.80|
;;;624        }
;;;625      }
;;;626    }
000050  4770              BX       lr
;;;627    
                          ENDP

000052  0000              DCW      0x0000
                  |L10.84|
                          DCD      0xa0000080
                  |L10.88|
                          DCD      0x000fffbf

                          AREA ||i.FMC_NANDInit||, CODE, READONLY, ALIGN=2

                  FMC_NANDInit PROC
;;;416      */
;;;417    void FMC_NANDInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;418    {
;;;419      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;420        
;;;421      /* Check the parameters */
;;;422      assert_param(IS_FMC_NAND_BANK(FMC_NANDInitStruct->FMC_Bank));
;;;423      assert_param(IS_FMC_WAIT_FEATURE(FMC_NANDInitStruct->FMC_Waitfeature));
;;;424      assert_param(IS_FMC_NAND_MEMORY_WIDTH(FMC_NANDInitStruct->FMC_MemoryDataWidth));
;;;425      assert_param(IS_FMC_ECC_STATE(FMC_NANDInitStruct->FMC_ECC));
;;;426      assert_param(IS_FMC_ECCPAGE_SIZE(FMC_NANDInitStruct->FMC_ECCPageSize));
;;;427      assert_param(IS_FMC_TCLR_TIME(FMC_NANDInitStruct->FMC_TCLRSetupTime));
;;;428      assert_param(IS_FMC_TAR_TIME(FMC_NANDInitStruct->FMC_TARSetupTime));
;;;429      assert_param(IS_FMC_SETUP_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime));
;;;430      assert_param(IS_FMC_WAIT_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime));
;;;431      assert_param(IS_FMC_HOLD_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime));
;;;432      assert_param(IS_FMC_HIZ_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime));
;;;433      assert_param(IS_FMC_SETUP_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime));
;;;434      assert_param(IS_FMC_WAIT_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime));
;;;435      assert_param(IS_FMC_HOLD_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime));
;;;436      assert_param(IS_FMC_HIZ_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime));
;;;437    
;;;438      if(FMC_NANDInitStruct->FMC_Bank == FMC_Bank2_NAND)
000008  6804              LDR      r4,[r0,#0]
00000a  2c10              CMP      r4,#0x10
00000c  d103              BNE      |L11.22|
;;;439      {
;;;440        /* Get the NAND bank 2 register value */
;;;441        tmppcr = FMC_Bank2->PCR2;
00000e  f04f4420          MOV      r4,#0xa0000000
000012  6e21              LDR      r1,[r4,#0x60]
000014  e001              B        |L11.26|
                  |L11.22|
;;;442      }
;;;443      else
;;;444      {
;;;445        /* Get the NAND bank 3 register value */
;;;446        tmppcr = FMC_Bank3->PCR3;
000016  4c2d              LDR      r4,|L11.204|
000018  6821              LDR      r1,[r4,#0]
                  |L11.26|
;;;447      }
;;;448      
;;;449      /* Clear PWAITEN, PBKEN, PTYP, PWID, ECCEN, TCLR, TAR and ECCPS bits */
;;;450      tmppcr &= ((uint32_t)~(FMC_PCR2_PWAITEN  | FMC_PCR2_PBKEN | FMC_PCR2_PTYP | \
00001a  4c2d              LDR      r4,|L11.208|
00001c  4021              ANDS     r1,r1,r4
;;;451                           FMC_PCR2_PWID | FMC_PCR2_ECCEN | FMC_PCR2_TCLR | \
;;;452                           FMC_PCR2_TAR | FMC_PCR2_ECCPS)); 
;;;453    
;;;454      /* Set the tmppcr value according to FMC_NANDInitStruct parameters */
;;;455      tmppcr |= (uint32_t)FMC_NANDInitStruct->FMC_Waitfeature |
00001e  6844              LDR      r4,[r0,#4]
000020  f0440408          ORR      r4,r4,#8
000024  6885              LDR      r5,[r0,#8]
000026  432c              ORRS     r4,r4,r5
000028  68c5              LDR      r5,[r0,#0xc]
00002a  432c              ORRS     r4,r4,r5
00002c  6905              LDR      r5,[r0,#0x10]
00002e  432c              ORRS     r4,r4,r5
000030  6945              LDR      r5,[r0,#0x14]
000032  ea442445          ORR      r4,r4,r5,LSL #9
000036  6985              LDR      r5,[r0,#0x18]
000038  ea443445          ORR      r4,r4,r5,LSL #13
00003c  4321              ORRS     r1,r1,r4
;;;456                          PCR_MEMORYTYPE_NAND |
;;;457                          FMC_NANDInitStruct->FMC_MemoryDataWidth |
;;;458                          FMC_NANDInitStruct->FMC_ECC |
;;;459                          FMC_NANDInitStruct->FMC_ECCPageSize |
;;;460                          (FMC_NANDInitStruct->FMC_TCLRSetupTime << 9 )|
;;;461                          (FMC_NANDInitStruct->FMC_TARSetupTime << 13);
;;;462        
;;;463      if(FMC_NANDInitStruct->FMC_Bank == FMC_Bank2_NAND)
00003e  6804              LDR      r4,[r0,#0]
000040  2c10              CMP      r4,#0x10
000042  d103              BNE      |L11.76|
;;;464      {
;;;465        /* Get the NAND bank 2 register value */
;;;466        tmppmem = FMC_Bank2->PMEM2;
000044  f04f4420          MOV      r4,#0xa0000000
000048  6ea2              LDR      r2,[r4,#0x68]
00004a  e002              B        |L11.82|
                  |L11.76|
;;;467      }
;;;468      else
;;;469      {
;;;470        /* Get the NAND bank 3 register value */
;;;471        tmppmem = FMC_Bank3->PMEM3;
00004c  4c1f              LDR      r4,|L11.204|
00004e  3408              ADDS     r4,r4,#8
000050  6822              LDR      r2,[r4,#0]
                  |L11.82|
;;;472      } 
;;;473      
;;;474      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;475      tmppmem &= ((uint32_t)~(FMC_PMEM2_MEMSET2  | FMC_PMEM2_MEMWAIT2 | FMC_PMEM2_MEMHOLD2 | \
000052  2200              MOVS     r2,#0
;;;476                              FMC_PMEM2_MEMHIZ2)); 
;;;477    
;;;478      /* Set tmppmem value according to FMC_CommonSpaceTimingStructure parameters */
;;;479      tmppmem |= (uint32_t)FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime |
000054  69c4              LDR      r4,[r0,#0x1c]
000056  6824              LDR      r4,[r4,#0]
000058  69c5              LDR      r5,[r0,#0x1c]
00005a  686d              LDR      r5,[r5,#4]
00005c  ea442405          ORR      r4,r4,r5,LSL #8
000060  69c5              LDR      r5,[r0,#0x1c]
000062  892d              LDRH     r5,[r5,#8]
000064  ea444405          ORR      r4,r4,r5,LSL #16
000068  69c5              LDR      r5,[r0,#0x1c]
00006a  7b2d              LDRB     r5,[r5,#0xc]
00006c  ea446405          ORR      r4,r4,r5,LSL #24
000070  4322              ORRS     r2,r2,r4
;;;480                           (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime << 8) |
;;;481                           (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime << 16)|
;;;482                           (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime << 24); 
;;;483    
;;;484      if(FMC_NANDInitStruct->FMC_Bank == FMC_Bank2_NAND)
000072  6804              LDR      r4,[r0,#0]
000074  2c10              CMP      r4,#0x10
000076  d103              BNE      |L11.128|
;;;485      {
;;;486        /* Get the NAND bank 2 register value */
;;;487        tmppatt = FMC_Bank2->PATT2;
000078  f04f4420          MOV      r4,#0xa0000000
00007c  6ee3              LDR      r3,[r4,#0x6c]
00007e  e002              B        |L11.134|
                  |L11.128|
;;;488      }
;;;489      else
;;;490      {
;;;491        /* Get the NAND bank 3 register value */
;;;492        tmppatt = FMC_Bank3->PATT3;
000080  4c12              LDR      r4,|L11.204|
000082  340c              ADDS     r4,r4,#0xc
000084  6823              LDR      r3,[r4,#0]
                  |L11.134|
;;;493      } 
;;;494      
;;;495      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;496      tmppatt &= ((uint32_t)~(FMC_PATT2_ATTSET2  | FMC_PATT2_ATTWAIT2 | FMC_PATT2_ATTHOLD2 | \
000086  2300              MOVS     r3,#0
;;;497                           FMC_PATT2_ATTHIZ2)); 
;;;498    
;;;499      /* Set tmppatt value according to FMC_AttributeSpaceTimingStructure parameters */
;;;500      tmppatt |= (uint32_t)FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime |
000088  6a04              LDR      r4,[r0,#0x20]
00008a  6824              LDR      r4,[r4,#0]
00008c  6a05              LDR      r5,[r0,#0x20]
00008e  686d              LDR      r5,[r5,#4]
000090  ea442405          ORR      r4,r4,r5,LSL #8
000094  6a05              LDR      r5,[r0,#0x20]
000096  892d              LDRH     r5,[r5,#8]
000098  ea444405          ORR      r4,r4,r5,LSL #16
00009c  6a05              LDR      r5,[r0,#0x20]
00009e  7b2d              LDRB     r5,[r5,#0xc]
0000a0  ea446405          ORR      r4,r4,r5,LSL #24
0000a4  4323              ORRS     r3,r3,r4
;;;501                          (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime << 8) |
;;;502                          (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime << 16)|
;;;503                          (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime << 24);
;;;504    
;;;505      if(FMC_NANDInitStruct->FMC_Bank == FMC_Bank2_NAND)
0000a6  6804              LDR      r4,[r0,#0]
0000a8  2c10              CMP      r4,#0x10
0000aa  d105              BNE      |L11.184|
;;;506      {
;;;507        /* FMC_Bank2_NAND registers configuration */
;;;508        FMC_Bank2->PCR2 = tmppcr;
0000ac  f04f4420          MOV      r4,#0xa0000000
0000b0  6621              STR      r1,[r4,#0x60]
;;;509        FMC_Bank2->PMEM2 = tmppmem;
0000b2  66a2              STR      r2,[r4,#0x68]
;;;510        FMC_Bank2->PATT2 = tmppatt;
0000b4  66e3              STR      r3,[r4,#0x6c]
0000b6  e008              B        |L11.202|
                  |L11.184|
;;;511      }
;;;512      else
;;;513      {
;;;514        /* FMC_Bank3_NAND registers configuration */
;;;515        FMC_Bank3->PCR3 = tmppcr;
0000b8  4c04              LDR      r4,|L11.204|
0000ba  6021              STR      r1,[r4,#0]
;;;516        FMC_Bank3->PMEM3 = tmppmem;
0000bc  f04f4420          MOV      r4,#0xa0000000
0000c0  f8c42088          STR      r2,[r4,#0x88]
;;;517        FMC_Bank3->PATT3 = tmppatt;
0000c4  4c01              LDR      r4,|L11.204|
0000c6  340c              ADDS     r4,r4,#0xc
0000c8  6023              STR      r3,[r4,#0]
                  |L11.202|
;;;518      }
;;;519    }
0000ca  bd30              POP      {r4,r5,pc}
;;;520    
                          ENDP

                  |L11.204|
                          DCD      0xa0000080
                  |L11.208|
                          DCD      0xfff00181

                          AREA ||i.FMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FMC_NANDStructInit PROC
;;;527      */
;;;528    void FMC_NANDStructInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct)
000000  2110              MOVS     r1,#0x10
;;;529    { 
;;;530      /* Reset NAND Init structure parameters values */
;;;531      FMC_NANDInitStruct->FMC_Bank = FMC_Bank2_NAND;
000002  6001              STR      r1,[r0,#0]
;;;532      FMC_NANDInitStruct->FMC_Waitfeature = FMC_Waitfeature_Disable;
000004  2100              MOVS     r1,#0
000006  6041              STR      r1,[r0,#4]
;;;533      FMC_NANDInitStruct->FMC_MemoryDataWidth = FMC_NAND_MemoryDataWidth_16b;
000008  2110              MOVS     r1,#0x10
00000a  6081              STR      r1,[r0,#8]
;;;534      FMC_NANDInitStruct->FMC_ECC = FMC_ECC_Disable;
00000c  2100              MOVS     r1,#0
00000e  60c1              STR      r1,[r0,#0xc]
;;;535      FMC_NANDInitStruct->FMC_ECCPageSize = FMC_ECCPageSize_256Bytes;
000010  6101              STR      r1,[r0,#0x10]
;;;536      FMC_NANDInitStruct->FMC_TCLRSetupTime = 0x0;
000012  6141              STR      r1,[r0,#0x14]
;;;537      FMC_NANDInitStruct->FMC_TARSetupTime = 0x0;
000014  6181              STR      r1,[r0,#0x18]
;;;538      FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime = 252;
000016  21fc              MOVS     r1,#0xfc
000018  69c2              LDR      r2,[r0,#0x1c]
00001a  6011              STR      r1,[r2,#0]
;;;539      FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime = 252;
00001c  69c2              LDR      r2,[r0,#0x1c]
00001e  6051              STR      r1,[r2,#4]
;;;540      FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime = 252;
000020  69c2              LDR      r2,[r0,#0x1c]
000022  6091              STR      r1,[r2,#8]
;;;541      FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime = 252;
000024  69c2              LDR      r2,[r0,#0x1c]
000026  60d1              STR      r1,[r2,#0xc]
;;;542      FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime = 252;
000028  6a02              LDR      r2,[r0,#0x20]
00002a  6011              STR      r1,[r2,#0]
;;;543      FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime = 252;
00002c  6a02              LDR      r2,[r0,#0x20]
00002e  6051              STR      r1,[r2,#4]
;;;544      FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime = 252;
000030  6a02              LDR      r2,[r0,#0x20]
000032  6091              STR      r1,[r2,#8]
;;;545      FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime = 252;	  
000034  6a02              LDR      r2,[r0,#0x20]
000036  60d1              STR      r1,[r2,#0xc]
;;;546    }
000038  4770              BX       lr
;;;547    
                          ENDP


                          AREA ||i.FMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAMCmd PROC
;;;312      */
;;;313    void FMC_NORSRAMCmd(uint32_t FMC_Bank, FunctionalState NewState)
000000  b151              CBZ      r1,|L13.24|
;;;314    {
;;;315      assert_param(IS_FMC_NORSRAM_BANK(FMC_Bank));
;;;316      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;317      
;;;318      if (NewState != DISABLE)
;;;319      {
;;;320        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;321        FMC_Bank1->BTCR[FMC_Bank] |= BCR_MBKEN_SET;
000002  0082              LSLS     r2,r0,#2
000004  f1a242c0          SUB      r2,r2,#0x60000000
000008  6812              LDR      r2,[r2,#0]
00000a  f0420301          ORR      r3,r2,#1
00000e  0082              LSLS     r2,r0,#2
000010  f1a242c0          SUB      r2,r2,#0x60000000
000014  6013              STR      r3,[r2,#0]
000016  e009              B        |L13.44|
                  |L13.24|
;;;322      }
;;;323      else
;;;324      {
;;;325        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;326        FMC_Bank1->BTCR[FMC_Bank] &= BCR_MBKEN_RESET;
000018  0082              LSLS     r2,r0,#2
00001a  f1a242c0          SUB      r2,r2,#0x60000000
00001e  6812              LDR      r2,[r2,#0]
000020  4b03              LDR      r3,|L13.48|
000022  401a              ANDS     r2,r2,r3
000024  0083              LSLS     r3,r0,#2
000026  f1a343c0          SUB      r3,r3,#0x60000000
00002a  601a              STR      r2,[r3,#0]
                  |L13.44|
;;;327      }
;;;328    }
00002c  4770              BX       lr
;;;329    /**
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      0x000ffffe

                          AREA ||i.FMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAMDeInit PROC
;;;135      */
;;;136    void FMC_NORSRAMDeInit(uint32_t FMC_Bank)
000000  b930              CBNZ     r0,|L14.16|
;;;137    {
;;;138      /* Check the parameter */
;;;139      assert_param(IS_FMC_NORSRAM_BANK(FMC_Bank));
;;;140      
;;;141      /* FMC_Bank1_NORSRAM1 */
;;;142      if(FMC_Bank == FMC_Bank1_NORSRAM1)
;;;143      {
;;;144        FMC_Bank1->BTCR[FMC_Bank] = 0x000030DB;    
000002  f24302db          MOV      r2,#0x30db
000006  0081              LSLS     r1,r0,#2
000008  f1a141c0          SUB      r1,r1,#0x60000000
00000c  600a              STR      r2,[r1,#0]
00000e  e005              B        |L14.28|
                  |L14.16|
;;;145      }
;;;146      /* FMC_Bank1_NORSRAM2,  FMC_Bank1_NORSRAM3 or FMC_Bank1_NORSRAM4 */
;;;147      else
;;;148      {   
;;;149        FMC_Bank1->BTCR[FMC_Bank] = 0x000030D2; 
000010  f24302d2          MOV      r2,#0x30d2
000014  0081              LSLS     r1,r0,#2
000016  f1a141c0          SUB      r1,r1,#0x60000000
00001a  600a              STR      r2,[r1,#0]
                  |L14.28|
;;;150      }
;;;151      FMC_Bank1->BTCR[FMC_Bank + 1] = 0x0FFFFFFF;
00001c  f06f4270          MVN      r2,#0xf0000000
000020  1c41              ADDS     r1,r0,#1
000022  0089              LSLS     r1,r1,#2
000024  f1a141c0          SUB      r1,r1,#0x60000000
000028  600a              STR      r2,[r1,#0]
;;;152      FMC_Bank1E->BWTR[FMC_Bank] = 0x0FFFFFFF;  
00002a  0081              LSLS     r1,r0,#2
00002c  f1a141c0          SUB      r1,r1,#0x60000000
000030  f8c12104          STR      r2,[r1,#0x104]
;;;153    }
000034  4770              BX       lr
;;;154    
                          ENDP


                          AREA ||i.FMC_NORSRAMInit||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAMInit PROC
;;;162      */
;;;163    void FMC_NORSRAMInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;164    {
;;;165      uint32_t tmpr = 0, tmpbcr = 0, tmpbwr = 0;
000002  2300              MOVS     r3,#0
000004  2100              MOVS     r1,#0
000006  2200              MOVS     r2,#0
;;;166      
;;;167      /* Check the parameters */
;;;168      assert_param(IS_FMC_NORSRAM_BANK(FMC_NORSRAMInitStruct->FMC_Bank));
;;;169      assert_param(IS_FMC_MUX(FMC_NORSRAMInitStruct->FMC_DataAddressMux));
;;;170      assert_param(IS_FMC_MEMORY(FMC_NORSRAMInitStruct->FMC_MemoryType));
;;;171      assert_param(IS_FMC_NORSRAM_MEMORY_WIDTH(FMC_NORSRAMInitStruct->FMC_MemoryDataWidth));
;;;172      assert_param(IS_FMC_BURSTMODE(FMC_NORSRAMInitStruct->FMC_BurstAccessMode));
;;;173      assert_param(IS_FMC_WAIT_POLARITY(FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity));
;;;174      assert_param(IS_FMC_WRAP_MODE(FMC_NORSRAMInitStruct->FMC_WrapMode));
;;;175      assert_param(IS_FMC_WAIT_SIGNAL_ACTIVE(FMC_NORSRAMInitStruct->FMC_WaitSignalActive));
;;;176      assert_param(IS_FMC_WRITE_OPERATION(FMC_NORSRAMInitStruct->FMC_WriteOperation));
;;;177      assert_param(IS_FMC_WAITE_SIGNAL(FMC_NORSRAMInitStruct->FMC_WaitSignal));
;;;178      assert_param(IS_FMC_EXTENDED_MODE(FMC_NORSRAMInitStruct->FMC_ExtendedMode));
;;;179      assert_param(IS_FMC_ASYNWAIT(FMC_NORSRAMInitStruct->FMC_AsynchronousWait));
;;;180      assert_param(IS_FMC_WRITE_BURST(FMC_NORSRAMInitStruct->FMC_WriteBurst));
;;;181      assert_param(IS_FMC_CONTINOUS_CLOCK(FMC_NORSRAMInitStruct->FMC_ContinousClock));  
;;;182      assert_param(IS_FMC_ADDRESS_SETUP_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressSetupTime));
;;;183      assert_param(IS_FMC_ADDRESS_HOLD_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressHoldTime));
;;;184      assert_param(IS_FMC_DATASETUP_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataSetupTime));
;;;185      assert_param(IS_FMC_TURNAROUND_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_BusTurnAroundDuration));
;;;186      assert_param(IS_FMC_CLK_DIV(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision));
;;;187      assert_param(IS_FMC_DATA_LATENCY(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataLatency));
;;;188      assert_param(IS_FMC_ACCESS_MODE(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AccessMode)); 
;;;189      
;;;190      /* Get the BTCR register value */
;;;191      tmpbcr = FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank];
000008  6804              LDR      r4,[r0,#0]
00000a  00a4              LSLS     r4,r4,#2
00000c  f1a444c0          SUB      r4,r4,#0x60000000
000010  6821              LDR      r1,[r4,#0]
;;;192     
;;;193      /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WRAPMOD, WAITCFG, WREN,
;;;194               WAITEN, EXTMOD, ASYNCWAIT, CBURSTRW and CCLKEN bits */
;;;195      tmpbcr &= ((uint32_t)~(FMC_BCR1_MBKEN   | FMC_BCR1_MUXEN    | FMC_BCR1_MTYP     | \
000012  4c4d              LDR      r4,|L15.328|
000014  4021              ANDS     r1,r1,r4
;;;196                             FMC_BCR1_MWID     | FMC_BCR1_FACCEN   | FMC_BCR1_BURSTEN  | \
;;;197                             FMC_BCR1_WAITPOL  | FMC_BCR1_WRAPMOD  | FMC_BCR1_WAITCFG  | \
;;;198                             FMC_BCR1_WREN     | FMC_BCR1_WAITEN   | FMC_BCR1_EXTMOD   | \
;;;199                             FMC_BCR1_ASYNCWAIT| FMC_BCR1_CBURSTRW | FMC_BCR1_CCLKEN));
;;;200    
;;;201      /* NOR/SRAM Bank control register configuration */ 
;;;202      tmpbcr |=  (uint32_t)FMC_NORSRAMInitStruct->FMC_DataAddressMux |
000016  e9d04501          LDRD     r4,r5,[r0,#4]
00001a  432c              ORRS     r4,r4,r5
00001c  68c5              LDR      r5,[r0,#0xc]
00001e  432c              ORRS     r4,r4,r5
000020  6905              LDR      r5,[r0,#0x10]
000022  432c              ORRS     r4,r4,r5
000024  6945              LDR      r5,[r0,#0x14]
000026  432c              ORRS     r4,r4,r5
000028  6985              LDR      r5,[r0,#0x18]
00002a  432c              ORRS     r4,r4,r5
00002c  69c5              LDR      r5,[r0,#0x1c]
00002e  432c              ORRS     r4,r4,r5
000030  6a05              LDR      r5,[r0,#0x20]
000032  432c              ORRS     r4,r4,r5
000034  6a45              LDR      r5,[r0,#0x24]
000036  432c              ORRS     r4,r4,r5
000038  6a85              LDR      r5,[r0,#0x28]
00003a  432c              ORRS     r4,r4,r5
00003c  6ac5              LDR      r5,[r0,#0x2c]
00003e  432c              ORRS     r4,r4,r5
000040  6b05              LDR      r5,[r0,#0x30]
000042  432c              ORRS     r4,r4,r5
000044  6b45              LDR      r5,[r0,#0x34]
000046  432c              ORRS     r4,r4,r5
000048  4321              ORRS     r1,r1,r4
;;;203                           FMC_NORSRAMInitStruct->FMC_MemoryType |
;;;204                           FMC_NORSRAMInitStruct->FMC_MemoryDataWidth |
;;;205                           FMC_NORSRAMInitStruct->FMC_BurstAccessMode |
;;;206                           FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity |
;;;207                           FMC_NORSRAMInitStruct->FMC_WrapMode |
;;;208                           FMC_NORSRAMInitStruct->FMC_WaitSignalActive |
;;;209                           FMC_NORSRAMInitStruct->FMC_WriteOperation |
;;;210                           FMC_NORSRAMInitStruct->FMC_WaitSignal |
;;;211                           FMC_NORSRAMInitStruct->FMC_ExtendedMode |
;;;212                           FMC_NORSRAMInitStruct->FMC_AsynchronousWait |
;;;213                           FMC_NORSRAMInitStruct->FMC_WriteBurst |
;;;214                           FMC_NORSRAMInitStruct->FMC_ContinousClock;
;;;215    
;;;216      FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank] = tmpbcr;
00004a  6804              LDR      r4,[r0,#0]
00004c  00a4              LSLS     r4,r4,#2
00004e  f1a444c0          SUB      r4,r4,#0x60000000
000052  6021              STR      r1,[r4,#0]
;;;217    
;;;218      if(FMC_NORSRAMInitStruct->FMC_MemoryType == FMC_MemoryType_NOR)
000054  6884              LDR      r4,[r0,#8]
000056  2c08              CMP      r4,#8
000058  d10b              BNE      |L15.114|
;;;219      {
;;;220        FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
00005a  6804              LDR      r4,[r0,#0]
00005c  00a4              LSLS     r4,r4,#2
00005e  f1a444c0          SUB      r4,r4,#0x60000000
000062  6824              LDR      r4,[r4,#0]
000064  f0440540          ORR      r5,r4,#0x40
000068  6804              LDR      r4,[r0,#0]
00006a  00a4              LSLS     r4,r4,#2
00006c  f1a444c0          SUB      r4,r4,#0x60000000
000070  6025              STR      r5,[r4,#0]
                  |L15.114|
;;;221      }
;;;222    
;;;223      /* Configure Continuous clock feature when bank2..4 is used */
;;;224      if((FMC_NORSRAMInitStruct->FMC_ContinousClock == FMC_CClock_SyncAsync) && (FMC_NORSRAMInitStruct->FMC_Bank != FMC_Bank1_NORSRAM1))
000072  6b44              LDR      r4,[r0,#0x34]
000074  f5b41f80          CMP      r4,#0x100000
000078  d119              BNE      |L15.174|
00007a  6804              LDR      r4,[r0,#0]
00007c  b1bc              CBZ      r4,|L15.174|
;;;225      {
;;;226        tmpr = (uint32_t)((FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1+1]) & ~(((uint32_t)0x0F) << 20));    
00007e  f04f4420          MOV      r4,#0xa0000000
000082  6864              LDR      r4,[r4,#4]
000084  f4240370          BIC      r3,r4,#0xf00000
;;;227        
;;;228        FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1]  |= FMC_NORSRAMInitStruct->FMC_ContinousClock;
000088  f04f4420          MOV      r4,#0xa0000000
00008c  6824              LDR      r4,[r4,#0]
00008e  6b45              LDR      r5,[r0,#0x34]
000090  432c              ORRS     r4,r4,r5
000092  f04f4520          MOV      r5,#0xa0000000
000096  602c              STR      r4,[r5,#0]
;;;229        FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1]  |= FMC_BurstAccessMode_Enable;
000098  462c              MOV      r4,r5
00009a  6824              LDR      r4,[r4,#0]
00009c  f4447480          ORR      r4,r4,#0x100
0000a0  602c              STR      r4,[r5,#0]
;;;230        FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1+1] = (uint32_t)(tmpr | (((FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision)-1) << 20));
0000a2  6b84              LDR      r4,[r0,#0x38]
0000a4  8a24              LDRH     r4,[r4,#0x10]
0000a6  1e64              SUBS     r4,r4,#1
0000a8  ea435404          ORR      r4,r3,r4,LSL #20
0000ac  606c              STR      r4,[r5,#4]
                  |L15.174|
;;;231      }
;;;232      
;;;233      /* NOR/SRAM Bank timing register configuration */
;;;234      FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank+1] =   
0000ae  6b84              LDR      r4,[r0,#0x38]
0000b0  6824              LDR      r4,[r4,#0]
0000b2  6b85              LDR      r5,[r0,#0x38]
0000b4  686d              LDR      r5,[r5,#4]
0000b6  ea441405          ORR      r4,r4,r5,LSL #4
0000ba  6b85              LDR      r5,[r0,#0x38]
0000bc  68ad              LDR      r5,[r5,#8]
0000be  ea442405          ORR      r4,r4,r5,LSL #8
0000c2  6b85              LDR      r5,[r0,#0x38]
0000c4  89ad              LDRH     r5,[r5,#0xc]
0000c6  ea444405          ORR      r4,r4,r5,LSL #16
0000ca  6b85              LDR      r5,[r0,#0x38]
0000cc  8a2d              LDRH     r5,[r5,#0x10]
0000ce  ea445405          ORR      r4,r4,r5,LSL #20
0000d2  6b85              LDR      r5,[r0,#0x38]
0000d4  7d2d              LDRB     r5,[r5,#0x14]
0000d6  ea446405          ORR      r4,r4,r5,LSL #24
0000da  6b85              LDR      r5,[r0,#0x38]
0000dc  69ad              LDR      r5,[r5,#0x18]
0000de  432c              ORRS     r4,r4,r5
0000e0  6805              LDR      r5,[r0,#0]
0000e2  1c6d              ADDS     r5,r5,#1
0000e4  00ad              LSLS     r5,r5,#2
0000e6  f1a545c0          SUB      r5,r5,#0x60000000
0000ea  602c              STR      r4,[r5,#0]
;;;235                (uint32_t)FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressSetupTime |
;;;236                          (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressHoldTime << 4) |
;;;237                          (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataSetupTime << 8) |
;;;238                          (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_BusTurnAroundDuration << 16) |
;;;239                          (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision << 20) |
;;;240                          (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataLatency << 24) |
;;;241                          FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AccessMode;
;;;242         
;;;243      /* NOR/SRAM Bank timing register for write configuration, if extended mode is used */
;;;244      if(FMC_NORSRAMInitStruct->FMC_ExtendedMode == FMC_ExtendedMode_Enable)
0000ec  6a84              LDR      r4,[r0,#0x28]
0000ee  f5b44f80          CMP      r4,#0x4000
0000f2  d120              BNE      |L15.310|
;;;245      {
;;;246        assert_param(IS_FMC_ADDRESS_SETUP_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressSetupTime));
;;;247        assert_param(IS_FMC_ADDRESS_HOLD_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressHoldTime));
;;;248        assert_param(IS_FMC_DATASETUP_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataSetupTime));
;;;249        assert_param(IS_FMC_TURNAROUND_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_BusTurnAroundDuration));
;;;250        assert_param(IS_FMC_ACCESS_MODE(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AccessMode));
;;;251        
;;;252        /* Get the BWTR register value */
;;;253        tmpbwr = FMC_Bank1E->BWTR[FMC_NORSRAMInitStruct->FMC_Bank];
0000f4  6804              LDR      r4,[r0,#0]
0000f6  00a4              LSLS     r4,r4,#2
0000f8  f1a444c0          SUB      r4,r4,#0x60000000
0000fc  f8d42104          LDR      r2,[r4,#0x104]
;;;254    
;;;255        /* Clear ADDSET, ADDHLD, DATAST, BUSTURN and ACCMOD bits */
;;;256        tmpbwr &= ((uint32_t)~(FMC_BWTR1_ADDSET  | FMC_BWTR1_ADDHLD | FMC_BWTR1_DATAST | \
000100  4c12              LDR      r4,|L15.332|
000102  4022              ANDS     r2,r2,r4
;;;257                               FMC_BWTR1_BUSTURN | FMC_BWTR1_ACCMOD));
;;;258        
;;;259        tmpbwr |= (uint32_t)(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressSetupTime |
000104  6bc4              LDR      r4,[r0,#0x3c]
000106  6824              LDR      r4,[r4,#0]
000108  6bc5              LDR      r5,[r0,#0x3c]
00010a  686d              LDR      r5,[r5,#4]
00010c  ea441405          ORR      r4,r4,r5,LSL #4
000110  6bc5              LDR      r5,[r0,#0x3c]
000112  68ad              LDR      r5,[r5,#8]
000114  ea442405          ORR      r4,r4,r5,LSL #8
000118  6bc5              LDR      r5,[r0,#0x3c]
00011a  89ad              LDRH     r5,[r5,#0xc]
00011c  ea444405          ORR      r4,r4,r5,LSL #16
000120  6bc5              LDR      r5,[r0,#0x3c]
000122  69ad              LDR      r5,[r5,#0x18]
000124  432c              ORRS     r4,r4,r5
000126  4322              ORRS     r2,r2,r4
;;;260                            (FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressHoldTime << 4)|
;;;261                            (FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataSetupTime << 8) |
;;;262                            (FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_BusTurnAroundDuration << 16) |
;;;263                             FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AccessMode);
;;;264    
;;;265        FMC_Bank1E->BWTR[FMC_NORSRAMInitStruct->FMC_Bank] = tmpbwr;
000128  6804              LDR      r4,[r0,#0]
00012a  00a4              LSLS     r4,r4,#2
00012c  f1a444c0          SUB      r4,r4,#0x60000000
000130  f8c42104          STR      r2,[r4,#0x104]
000134  e007              B        |L15.326|
                  |L15.310|
;;;266      }
;;;267      else
;;;268      {
;;;269        FMC_Bank1E->BWTR[FMC_NORSRAMInitStruct->FMC_Bank] = 0x0FFFFFFF;
000136  f06f4570          MVN      r5,#0xf0000000
00013a  6804              LDR      r4,[r0,#0]
00013c  00a4              LSLS     r4,r4,#2
00013e  f1a444c0          SUB      r4,r4,#0x60000000
000142  f8c45104          STR      r5,[r4,#0x104]
                  |L15.326|
;;;270      }
;;;271      
;;;272    }
000146  bd30              POP      {r4,r5,pc}
;;;273    
                          ENDP

                  |L15.328|
                          DCD      0xffe70080
                  |L15.332|
                          DCD      0xcff00000

                          AREA ||i.FMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAMStructInit PROC
;;;279      */
;;;280    void FMC_NORSRAMStructInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct)
000000  2100              MOVS     r1,#0
;;;281    {  
;;;282      /* Reset NOR/SRAM Init structure parameters values */
;;;283      FMC_NORSRAMInitStruct->FMC_Bank = FMC_Bank1_NORSRAM1;
000002  6001              STR      r1,[r0,#0]
;;;284      FMC_NORSRAMInitStruct->FMC_DataAddressMux = FMC_DataAddressMux_Enable;
000004  2102              MOVS     r1,#2
000006  6041              STR      r1,[r0,#4]
;;;285      FMC_NORSRAMInitStruct->FMC_MemoryType = FMC_MemoryType_SRAM;
000008  2100              MOVS     r1,#0
00000a  6081              STR      r1,[r0,#8]
;;;286      FMC_NORSRAMInitStruct->FMC_MemoryDataWidth = FMC_NORSRAM_MemoryDataWidth_16b;
00000c  2110              MOVS     r1,#0x10
00000e  60c1              STR      r1,[r0,#0xc]
;;;287      FMC_NORSRAMInitStruct->FMC_BurstAccessMode = FMC_BurstAccessMode_Disable;
000010  2100              MOVS     r1,#0
000012  6101              STR      r1,[r0,#0x10]
;;;288      FMC_NORSRAMInitStruct->FMC_AsynchronousWait = FMC_AsynchronousWait_Disable;
000014  62c1              STR      r1,[r0,#0x2c]
;;;289      FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity = FMC_WaitSignalPolarity_Low;
000016  6141              STR      r1,[r0,#0x14]
;;;290      FMC_NORSRAMInitStruct->FMC_WrapMode = FMC_WrapMode_Disable;
000018  6181              STR      r1,[r0,#0x18]
;;;291      FMC_NORSRAMInitStruct->FMC_WaitSignalActive = FMC_WaitSignalActive_BeforeWaitState;
00001a  61c1              STR      r1,[r0,#0x1c]
;;;292      FMC_NORSRAMInitStruct->FMC_WriteOperation = FMC_WriteOperation_Enable;
00001c  f44f5180          MOV      r1,#0x1000
000020  6201              STR      r1,[r0,#0x20]
;;;293      FMC_NORSRAMInitStruct->FMC_WaitSignal = FMC_WaitSignal_Enable;
000022  0049              LSLS     r1,r1,#1
000024  6241              STR      r1,[r0,#0x24]
;;;294      FMC_NORSRAMInitStruct->FMC_ExtendedMode = FMC_ExtendedMode_Disable;
000026  2100              MOVS     r1,#0
000028  6281              STR      r1,[r0,#0x28]
;;;295      FMC_NORSRAMInitStruct->FMC_WriteBurst = FMC_WriteBurst_Disable;
00002a  6301              STR      r1,[r0,#0x30]
;;;296      FMC_NORSRAMInitStruct->FMC_ContinousClock = FMC_CClock_SyncOnly;
00002c  6341              STR      r1,[r0,#0x34]
;;;297      
;;;298      FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct = (FMC_NORSRAMTimingInitTypeDef*)((uint32_t)&FMC_DefaultTimingStruct);
00002e  4902              LDR      r1,|L16.56|
000030  6381              STR      r1,[r0,#0x38]
;;;299      FMC_NORSRAMInitStruct->FMC_WriteTimingStruct = (FMC_NORSRAMTimingInitTypeDef*)((uint32_t)&FMC_DefaultTimingStruct);
000032  63c1              STR      r1,[r0,#0x3c]
;;;300    }
000034  4770              BX       lr
;;;301    
                          ENDP

000036  0000              DCW      0x0000
                  |L16.56|
                          DCD      FMC_DefaultTimingStruct

                          AREA ||i.FMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FMC_PCCARDCmd PROC
;;;833      */
;;;834    void FMC_PCCARDCmd(FunctionalState NewState)
000000  b140              CBZ      r0,|L17.20|
;;;835    {
;;;836      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;837      
;;;838      if (NewState != DISABLE)
;;;839      {
;;;840        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;841        FMC_Bank4->PCR4 |= PCR_PBKEN_SET;
000002  4909              LDR      r1,|L17.40|
000004  6809              LDR      r1,[r1,#0]
000006  f0410104          ORR      r1,r1,#4
00000a  f04f4220          MOV      r2,#0xa0000000
00000e  f8c210a0          STR      r1,[r2,#0xa0]
000012  e007              B        |L17.36|
                  |L17.20|
;;;842      }
;;;843      else
;;;844      {
;;;845        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;846        FMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
000014  4904              LDR      r1,|L17.40|
000016  6809              LDR      r1,[r1,#0]
000018  4a04              LDR      r2,|L17.44|
00001a  4011              ANDS     r1,r1,r2
00001c  f04f4220          MOV      r2,#0xa0000000
000020  f8c210a0          STR      r1,[r2,#0xa0]
                  |L17.36|
;;;847      }
;;;848    }
000024  4770              BX       lr
;;;849    
                          ENDP

000026  0000              DCW      0x0000
                  |L17.40|
                          DCD      0xa00000a0
                  |L17.44|
                          DCD      0x000ffffb

                          AREA ||i.FMC_PCCARDDeInit||, CODE, READONLY, ALIGN=2

                  FMC_PCCARDDeInit PROC
;;;699      */
;;;700    void FMC_PCCARDDeInit(void)
000000  2018              MOVS     r0,#0x18
;;;701    {
;;;702      /* Set the FMC_Bank4 registers to their reset values */
;;;703      FMC_Bank4->PCR4 = 0x00000018; 
000002  4908              LDR      r1,|L18.36|
000004  6008              STR      r0,[r1,#0]
;;;704      FMC_Bank4->SR4 = 0x00000000;	
000006  2000              MOVS     r0,#0
000008  0609              LSLS     r1,r1,#24
00000a  f8c100a4          STR      r0,[r1,#0xa4]
;;;705      FMC_Bank4->PMEM4 = 0xFCFCFCFC;
00000e  f04f30fc          MOV      r0,#0xfcfcfcfc
000012  4904              LDR      r1,|L18.36|
000014  3108              ADDS     r1,r1,#8
000016  6008              STR      r0,[r1,#0]
;;;706      FMC_Bank4->PATT4 = 0xFCFCFCFC;
000018  1d09              ADDS     r1,r1,#4
00001a  6008              STR      r0,[r1,#0]
;;;707      FMC_Bank4->PIO4 = 0xFCFCFCFC;
00001c  1d09              ADDS     r1,r1,#4
00001e  6008              STR      r0,[r1,#0]
;;;708    }
000020  4770              BX       lr
;;;709    
                          ENDP

000022  0000              DCW      0x0000
                  |L18.36|
                          DCD      0xa00000a0

                          AREA ||i.FMC_PCCARDInit||, CODE, READONLY, ALIGN=2

                  FMC_PCCARDInit PROC
;;;716      */
;;;717    void FMC_PCCARDInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;718    {
;;;719      /* temporary registers */
;;;720      uint32_t tmppcr = 0, tmpmem = 0, tmppatt = 0, tmppio = 0;
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;721      
;;;722      /* Check the parameters */
;;;723      assert_param(IS_FMC_WAIT_FEATURE(FMC_PCCARDInitStruct->FMC_Waitfeature));
;;;724      assert_param(IS_FMC_TCLR_TIME(FMC_PCCARDInitStruct->FMC_TCLRSetupTime));
;;;725      assert_param(IS_FMC_TAR_TIME(FMC_PCCARDInitStruct->FMC_TARSetupTime));
;;;726     
;;;727      assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime));
;;;728      assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime));
;;;729      assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime));
;;;730      assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime));
;;;731      
;;;732      assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime));
;;;733      assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime));
;;;734      assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime));
;;;735      assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime));
;;;736      assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime));
;;;737      assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime));
;;;738      assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime));
;;;739      assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime));
;;;740      
;;;741      /* Get PCCARD control register value */
;;;742      tmppcr = FMC_Bank4->PCR4;
00000a  4d2c              LDR      r5,|L19.188|
00000c  6829              LDR      r1,[r5,#0]
;;;743      
;;;744      /* Clear TAR, TCLR, PWAITEN and PWID bits */
;;;745      tmppcr &= ((uint32_t)~(FMC_PCR4_TAR  | FMC_PCR4_TCLR | FMC_PCR4_PWAITEN | \
00000e  4d2c              LDR      r5,|L19.192|
000010  4029              ANDS     r1,r1,r5
;;;746                             FMC_PCR4_PWID));
;;;747    
;;;748      /* Set the PCR4 register value according to FMC_PCCARDInitStruct parameters */
;;;749      tmppcr |= (uint32_t)FMC_PCCARDInitStruct->FMC_Waitfeature |
000012  6805              LDR      r5,[r0,#0]
000014  f0450510          ORR      r5,r5,#0x10
000018  6846              LDR      r6,[r0,#4]
00001a  ea452546          ORR      r5,r5,r6,LSL #9
00001e  6886              LDR      r6,[r0,#8]
000020  ea453546          ORR      r5,r5,r6,LSL #13
000024  4329              ORRS     r1,r1,r5
;;;750                          FMC_NAND_MemoryDataWidth_16b |  
;;;751                          (FMC_PCCARDInitStruct->FMC_TCLRSetupTime << 9) |
;;;752                          (FMC_PCCARDInitStruct->FMC_TARSetupTime << 13);
;;;753    
;;;754      FMC_Bank4->PCR4 = tmppcr;
000026  f04f4520          MOV      r5,#0xa0000000
00002a  f8c510a0          STR      r1,[r5,#0xa0]
;;;755    
;;;756      /* Get PCCARD common space timing register value */
;;;757      tmpmem = FMC_Bank4->PMEM4;
00002e  4d23              LDR      r5,|L19.188|
000030  3508              ADDS     r5,r5,#8
000032  682a              LDR      r2,[r5,#0]
;;;758      
;;;759      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;760      tmpmem &= ((uint32_t)~(FMC_PMEM4_MEMSET4  | FMC_PMEM4_MEMWAIT4 | FMC_PMEM4_MEMHOLD4 | \
000034  2200              MOVS     r2,#0
;;;761                             FMC_PMEM4_MEMHIZ4));
;;;762    
;;;763      /* Set PMEM4 register value according to FMC_CommonSpaceTimingStructure parameters */
;;;764      tmpmem |= (uint32_t)FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime |
000036  68c5              LDR      r5,[r0,#0xc]
000038  682d              LDR      r5,[r5,#0]
00003a  68c6              LDR      r6,[r0,#0xc]
00003c  6876              LDR      r6,[r6,#4]
00003e  ea452506          ORR      r5,r5,r6,LSL #8
000042  68c6              LDR      r6,[r0,#0xc]
000044  8936              LDRH     r6,[r6,#8]
000046  ea454506          ORR      r5,r5,r6,LSL #16
00004a  68c6              LDR      r6,[r0,#0xc]
00004c  7b36              LDRB     r6,[r6,#0xc]
00004e  ea456506          ORR      r5,r5,r6,LSL #24
000052  432a              ORRS     r2,r2,r5
;;;765                          (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime << 8) |
;;;766                          (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime << 16)|
;;;767                          (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime << 24); 
;;;768    
;;;769      FMC_Bank4->PMEM4 = tmpmem; 
000054  f04f4520          MOV      r5,#0xa0000000
000058  f8c520a8          STR      r2,[r5,#0xa8]
;;;770    
;;;771      /* Get PCCARD timing parameters */
;;;772      tmppatt = FMC_Bank4->PATT4;
00005c  4d17              LDR      r5,|L19.188|
00005e  350c              ADDS     r5,r5,#0xc
000060  682b              LDR      r3,[r5,#0]
;;;773      
;;;774      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;775      tmppatt &= ((uint32_t)~(FMC_PATT4_ATTSET4  | FMC_PATT4_ATTWAIT4 | FMC_PATT4_ATTHOLD4 | \
000062  2300              MOVS     r3,#0
;;;776                              FMC_PATT4_ATTHIZ4));
;;;777    
;;;778      /* Set PATT4 register value according to FMC_AttributeSpaceTimingStructure parameters */
;;;779      tmppatt |= (uint32_t)FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime |
000064  6905              LDR      r5,[r0,#0x10]
000066  682d              LDR      r5,[r5,#0]
000068  6906              LDR      r6,[r0,#0x10]
00006a  6876              LDR      r6,[r6,#4]
00006c  ea452506          ORR      r5,r5,r6,LSL #8
000070  6906              LDR      r6,[r0,#0x10]
000072  8936              LDRH     r6,[r6,#8]
000074  ea454506          ORR      r5,r5,r6,LSL #16
000078  6906              LDR      r6,[r0,#0x10]
00007a  7b36              LDRB     r6,[r6,#0xc]
00007c  ea456506          ORR      r5,r5,r6,LSL #24
000080  432b              ORRS     r3,r3,r5
;;;780                           (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime << 8) |
;;;781                           (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime << 16)|
;;;782                           (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime << 24);	
;;;783    
;;;784      FMC_Bank4->PATT4 = tmppatt;
000082  f04f4520          MOV      r5,#0xa0000000
000086  f8c530ac          STR      r3,[r5,#0xac]
;;;785    
;;;786      /* Get FMC_PCCARD device timing parameters */
;;;787      tmppio = FMC_Bank4->PIO4;
00008a  4d0c              LDR      r5,|L19.188|
00008c  3510              ADDS     r5,r5,#0x10
00008e  682c              LDR      r4,[r5,#0]
;;;788    
;;;789      /* Clear IOSET4, IOWAIT4, IOHOLD4 and IOHIZ4 bits */
;;;790      tmppio &= ((uint32_t)~(FMC_PIO4_IOSET4  | FMC_PIO4_IOWAIT4 | FMC_PIO4_IOHOLD4 | \
000090  2400              MOVS     r4,#0
;;;791                             FMC_PIO4_IOHIZ4));
;;;792    
;;;793      /* Set PIO4 register value according to FMC_IOSpaceTimingStructure parameters */
;;;794      tmppio |= (uint32_t)FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime |
000092  6945              LDR      r5,[r0,#0x14]
000094  682d              LDR      r5,[r5,#0]
000096  6946              LDR      r6,[r0,#0x14]
000098  6876              LDR      r6,[r6,#4]
00009a  ea452506          ORR      r5,r5,r6,LSL #8
00009e  6946              LDR      r6,[r0,#0x14]
0000a0  8936              LDRH     r6,[r6,#8]
0000a2  ea454506          ORR      r5,r5,r6,LSL #16
0000a6  6946              LDR      r6,[r0,#0x14]
0000a8  7b36              LDRB     r6,[r6,#0xc]
0000aa  ea456506          ORR      r5,r5,r6,LSL #24
0000ae  432c              ORRS     r4,r4,r5
;;;795                          (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime << 8) |
;;;796                          (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime << 16)|
;;;797                          (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime << 24);             
;;;798      
;;;799      FMC_Bank4->PIO4 = tmppio;
0000b0  f04f4520          MOV      r5,#0xa0000000
0000b4  f8c540b0          STR      r4,[r5,#0xb0]
;;;800    }
0000b8  bd70              POP      {r4-r6,pc}
;;;801    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L19.188|
                          DCD      0xa00000a0
                  |L19.192|
                          DCD      0xfffe01cd

                          AREA ||i.FMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FMC_PCCARDStructInit PROC
;;;807      */
;;;808    void FMC_PCCARDStructInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;809    {
;;;810      /* Reset PCCARD Init structure parameters values */
;;;811      FMC_PCCARDInitStruct->FMC_Waitfeature = FMC_Waitfeature_Disable;
000002  6001              STR      r1,[r0,#0]
;;;812      FMC_PCCARDInitStruct->FMC_TCLRSetupTime = 0;
000004  6041              STR      r1,[r0,#4]
;;;813      FMC_PCCARDInitStruct->FMC_TARSetupTime = 0;
000006  6081              STR      r1,[r0,#8]
;;;814      FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime = 252;
000008  21fc              MOVS     r1,#0xfc
00000a  68c2              LDR      r2,[r0,#0xc]
00000c  6011              STR      r1,[r2,#0]
;;;815      FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime = 252;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  6051              STR      r1,[r2,#4]
;;;816      FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime = 252;
000012  68c2              LDR      r2,[r0,#0xc]
000014  6091              STR      r1,[r2,#8]
;;;817      FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime = 252;
000016  68c2              LDR      r2,[r0,#0xc]
000018  60d1              STR      r1,[r2,#0xc]
;;;818      FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime = 252;
00001a  6902              LDR      r2,[r0,#0x10]
00001c  6011              STR      r1,[r2,#0]
;;;819      FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime = 252;
00001e  6902              LDR      r2,[r0,#0x10]
000020  6051              STR      r1,[r2,#4]
;;;820      FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime = 252;
000022  6902              LDR      r2,[r0,#0x10]
000024  6091              STR      r1,[r2,#8]
;;;821      FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime = 252;	
000026  6902              LDR      r2,[r0,#0x10]
000028  60d1              STR      r1,[r2,#0xc]
;;;822      FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime = 252;
00002a  6942              LDR      r2,[r0,#0x14]
00002c  6011              STR      r1,[r2,#0]
;;;823      FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime = 252;
00002e  6942              LDR      r2,[r0,#0x14]
000030  6051              STR      r1,[r2,#4]
;;;824      FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime = 252;
000032  6942              LDR      r2,[r0,#0x14]
000034  6091              STR      r1,[r2,#8]
;;;825      FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime = 252;
000036  6942              LDR      r2,[r0,#0x14]
000038  60d1              STR      r1,[r2,#0xc]
;;;826    }
00003a  4770              BX       lr
;;;827    
                          ENDP


                          AREA ||i.FMC_SDRAMCmdConfig||, CODE, READONLY, ALIGN=2

                  FMC_SDRAMCmdConfig PROC
;;;1082     */
;;;1083   void FMC_SDRAMCmdConfig(FMC_SDRAMCommandTypeDef* FMC_SDRAMCommandStruct)
000000  2100              MOVS     r1,#0
;;;1084   {
;;;1085     uint32_t tmpr = 0x0;
;;;1086       
;;;1087     /* check parameters */
;;;1088     assert_param(IS_FMC_COMMAND_MODE(FMC_SDRAMCommandStruct->FMC_CommandMode));
;;;1089     assert_param(IS_FMC_COMMAND_TARGET(FMC_SDRAMCommandStruct->FMC_CommandTarget));
;;;1090     assert_param(IS_FMC_AUTOREFRESH_NUMBER(FMC_SDRAMCommandStruct->FMC_AutoRefreshNumber));
;;;1091     assert_param(IS_FMC_MODE_REGISTER(FMC_SDRAMCommandStruct->FMC_ModeRegisterDefinition));
;;;1092     
;;;1093     tmpr =   (uint32_t)(FMC_SDRAMCommandStruct->FMC_CommandMode |
000002  e9d02300          LDRD     r2,r3,[r0,#0]
000006  431a              ORRS     r2,r2,r3
000008  6883              LDR      r3,[r0,#8]
00000a  1e5b              SUBS     r3,r3,#1
00000c  ea421243          ORR      r2,r2,r3,LSL #5
000010  68c3              LDR      r3,[r0,#0xc]
000012  ea422143          ORR      r1,r2,r3,LSL #9
;;;1094                         FMC_SDRAMCommandStruct->FMC_CommandTarget |
;;;1095                        (((FMC_SDRAMCommandStruct->FMC_AutoRefreshNumber)-1)<<5) |
;;;1096                        ((FMC_SDRAMCommandStruct->FMC_ModeRegisterDefinition)<<9));
;;;1097     
;;;1098     FMC_Bank5_6->SDCMR = tmpr;
000016  4a01              LDR      r2,|L21.28|
000018  6011              STR      r1,[r2,#0]
;;;1099   
;;;1100   }
00001a  4770              BX       lr
;;;1101   
                          ENDP

                  |L21.28|
                          DCD      0xa0000150

                          AREA ||i.FMC_SDRAMDeInit||, CODE, READONLY, ALIGN=2

                  FMC_SDRAMDeInit PROC
;;;905      */
;;;906    void FMC_SDRAMDeInit(uint32_t FMC_Bank)
000000  f44f7234          MOV      r2,#0x2d0
;;;907    {
;;;908      /* Check the parameter */
;;;909      assert_param(IS_FMC_SDRAM_BANK(FMC_Bank));
;;;910      
;;;911      FMC_Bank5_6->SDCR[FMC_Bank] = 0x000002D0;
000004  0081              LSLS     r1,r0,#2
000006  f1a141c0          SUB      r1,r1,#0x60000000
00000a  f8c12140          STR      r2,[r1,#0x140]
;;;912      FMC_Bank5_6->SDTR[FMC_Bank] = 0x0FFFFFFF;    
00000e  f06f4270          MVN      r2,#0xf0000000
000012  4907              LDR      r1,|L22.48|
000014  f8412020          STR      r2,[r1,r0,LSL #2]
;;;913      FMC_Bank5_6->SDCMR = 0x00000000;
000018  2100              MOVS     r1,#0
00001a  4a05              LDR      r2,|L22.48|
00001c  3208              ADDS     r2,r2,#8
00001e  6011              STR      r1,[r2,#0]
;;;914      FMC_Bank5_6->SDRTR = 0x00000000;
000020  0652              LSLS     r2,r2,#25
000022  f8c21154          STR      r1,[r2,#0x154]
;;;915      FMC_Bank5_6->SDSR = 0x00000000; 
000026  4a02              LDR      r2,|L22.48|
000028  3210              ADDS     r2,r2,#0x10
00002a  6011              STR      r1,[r2,#0]
;;;916    }  
00002c  4770              BX       lr
;;;917    
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      0xa0000148

                          AREA ||i.FMC_SDRAMInit||, CODE, READONLY, ALIGN=2

                  FMC_SDRAMInit PROC
;;;925      */
;;;926    void FMC_SDRAMInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;927    { 
;;;928      /* temporary registers */
;;;929      uint32_t tmpr1 = 0, tmpr2 = 0, tmpr3 = 0, tmpr4 = 0;
000002  2200              MOVS     r2,#0
000004  2100              MOVS     r1,#0
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;930      
;;;931      /* Check the parameters */
;;;932      
;;;933      /* Control parameters */
;;;934      assert_param(IS_FMC_SDRAM_BANK(FMC_SDRAMInitStruct->FMC_Bank));
;;;935      assert_param(IS_FMC_COLUMNBITS_NUMBER(FMC_SDRAMInitStruct->FMC_ColumnBitsNumber)); 
;;;936      assert_param(IS_FMC_ROWBITS_NUMBER(FMC_SDRAMInitStruct->FMC_RowBitsNumber));
;;;937      assert_param(IS_FMC_SDMEMORY_WIDTH(FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth));
;;;938      assert_param(IS_FMC_INTERNALBANK_NUMBER(FMC_SDRAMInitStruct->FMC_InternalBankNumber)); 
;;;939      assert_param(IS_FMC_CAS_LATENCY(FMC_SDRAMInitStruct->FMC_CASLatency));
;;;940      assert_param(IS_FMC_WRITE_PROTECTION(FMC_SDRAMInitStruct->FMC_WriteProtection));
;;;941      assert_param(IS_FMC_SDCLOCK_PERIOD(FMC_SDRAMInitStruct->FMC_SDClockPeriod));
;;;942      assert_param(IS_FMC_READ_BURST(FMC_SDRAMInitStruct->FMC_ReadBurst));
;;;943      assert_param(IS_FMC_READPIPE_DELAY(FMC_SDRAMInitStruct->FMC_ReadPipeDelay));   
;;;944      
;;;945      /* Timing parameters */
;;;946      assert_param(IS_FMC_LOADTOACTIVE_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)); 
;;;947      assert_param(IS_FMC_EXITSELFREFRESH_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay));
;;;948      assert_param(IS_FMC_SELFREFRESH_TIME(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime));
;;;949      assert_param(IS_FMC_ROWCYCLE_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay));
;;;950      assert_param(IS_FMC_WRITE_RECOVERY_TIME(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)); 
;;;951      assert_param(IS_FMC_RP_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)); 
;;;952      assert_param(IS_FMC_RCD_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay));    
;;;953      
;;;954      /* Get SDRAM register value */
;;;955      tmpr1 = FMC_Bank5_6->SDCR[FMC_SDRAMInitStruct->FMC_Bank];
00000a  6805              LDR      r5,[r0,#0]
00000c  00ad              LSLS     r5,r5,#2
00000e  f1a545c0          SUB      r5,r5,#0x60000000
000012  f8d52140          LDR      r2,[r5,#0x140]
;;;956    
;;;957      /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
;;;958      tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
000016  f36f020e          BFC      r2,#0,#15
;;;959                            FMC_SDCR1_NB | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
;;;960                            FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
;;;961    
;;;962      /* SDRAM bank control register configuration */ 
;;;963      tmpr1 |=   (uint32_t)FMC_SDRAMInitStruct->FMC_ColumnBitsNumber |
00001a  e9d05601          LDRD     r5,r6,[r0,#4]
00001e  4335              ORRS     r5,r5,r6
000020  68c6              LDR      r6,[r0,#0xc]
000022  4335              ORRS     r5,r5,r6
000024  6906              LDR      r6,[r0,#0x10]
000026  4335              ORRS     r5,r5,r6
000028  6946              LDR      r6,[r0,#0x14]
00002a  4335              ORRS     r5,r5,r6
00002c  6986              LDR      r6,[r0,#0x18]
00002e  4335              ORRS     r5,r5,r6
000030  69c6              LDR      r6,[r0,#0x1c]
000032  4335              ORRS     r5,r5,r6
000034  6a06              LDR      r6,[r0,#0x20]
000036  4335              ORRS     r5,r5,r6
000038  6a46              LDR      r6,[r0,#0x24]
00003a  4335              ORRS     r5,r5,r6
00003c  432a              ORRS     r2,r2,r5
;;;964                           FMC_SDRAMInitStruct->FMC_RowBitsNumber |
;;;965                           FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth |
;;;966                           FMC_SDRAMInitStruct->FMC_InternalBankNumber |           
;;;967                           FMC_SDRAMInitStruct->FMC_CASLatency |
;;;968                           FMC_SDRAMInitStruct->FMC_WriteProtection |
;;;969                           FMC_SDRAMInitStruct->FMC_SDClockPeriod |
;;;970                           FMC_SDRAMInitStruct->FMC_ReadBurst | 
;;;971                           FMC_SDRAMInitStruct->FMC_ReadPipeDelay;
;;;972                
;;;973      if(FMC_SDRAMInitStruct->FMC_Bank == FMC_Bank1_SDRAM )
00003e  6805              LDR      r5,[r0,#0]
000040  b935              CBNZ     r5,|L23.80|
;;;974      {
;;;975        FMC_Bank5_6->SDCR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr1;
000042  6805              LDR      r5,[r0,#0]
000044  00ad              LSLS     r5,r5,#2
000046  f1a545c0          SUB      r5,r5,#0x60000000
00004a  f8c52140          STR      r2,[r5,#0x140]
00004e  e011              B        |L23.116|
                  |L23.80|
;;;976      }
;;;977      else   /* SDCR2 "don't care" bits configuration */
;;;978      {
;;;979        /* Get SDCR register value */
;;;980        tmpr3 = FMC_Bank5_6->SDCR[FMC_Bank1_SDRAM];
000050  4d3b              LDR      r5,|L23.320|
000052  682b              LDR      r3,[r5,#0]
;;;981    
;;;982        /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
;;;983        tmpr3 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
000054  f36f030e          BFC      r3,#0,#15
;;;984                              FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
;;;985                              FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
;;;986    
;;;987        tmpr3 |= (uint32_t)FMC_SDRAMInitStruct->FMC_SDClockPeriod |
000058  e9d05607          LDRD     r5,r6,[r0,#0x1c]
00005c  4335              ORRS     r5,r5,r6
00005e  6a46              LDR      r6,[r0,#0x24]
000060  4335              ORRS     r5,r5,r6
000062  432b              ORRS     r3,r3,r5
;;;988                           FMC_SDRAMInitStruct->FMC_ReadBurst | 
;;;989                           FMC_SDRAMInitStruct->FMC_ReadPipeDelay;
;;;990        
;;;991        FMC_Bank5_6->SDCR[FMC_Bank1_SDRAM] = tmpr3;
000064  4d36              LDR      r5,|L23.320|
000066  602b              STR      r3,[r5,#0]
;;;992        FMC_Bank5_6->SDCR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr1;
000068  6805              LDR      r5,[r0,#0]
00006a  00ad              LSLS     r5,r5,#2
00006c  f1a545c0          SUB      r5,r5,#0x60000000
000070  f8c52140          STR      r2,[r5,#0x140]
                  |L23.116|
;;;993      }
;;;994      /* SDRAM bank timing register configuration */
;;;995      if(FMC_SDRAMInitStruct->FMC_Bank == FMC_Bank1_SDRAM )
000074  6805              LDR      r5,[r0,#0]
000076  bb75              CBNZ     r5,|L23.214|
;;;996      {
;;;997        /* Get SDTR register value */
;;;998        tmpr2 = FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank];
000078  4d31              LDR      r5,|L23.320|
00007a  3508              ADDS     r5,r5,#8
00007c  6806              LDR      r6,[r0,#0]
00007e  f8551026          LDR      r1,[r5,r6,LSL #2]
;;;999    
;;;1000       /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
;;;1001       tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
000082  f0014170          AND      r1,r1,#0xf0000000
;;;1002                             FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
;;;1003                             FMC_SDTR1_TRCD));
;;;1004   
;;;1005       tmpr2 |=   (uint32_t)((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)-1) |
000086  6a85              LDR      r5,[r0,#0x28]
000088  682d              LDR      r5,[r5,#0]
00008a  1e6d              SUBS     r5,r5,#1
00008c  6a86              LDR      r6,[r0,#0x28]
00008e  6876              LDR      r6,[r6,#4]
000090  1e76              SUBS     r6,r6,#1
000092  ea451606          ORR      r6,r5,r6,LSL #4
000096  6a85              LDR      r5,[r0,#0x28]
000098  68ad              LDR      r5,[r5,#8]
00009a  1e6d              SUBS     r5,r5,#1
00009c  ea462605          ORR      r6,r6,r5,LSL #8
0000a0  6a85              LDR      r5,[r0,#0x28]
0000a2  68ed              LDR      r5,[r5,#0xc]
0000a4  1e6d              SUBS     r5,r5,#1
0000a6  ea463605          ORR      r6,r6,r5,LSL #12
0000aa  6a85              LDR      r5,[r0,#0x28]
0000ac  8a2d              LDRH     r5,[r5,#0x10]
0000ae  1e6d              SUBS     r5,r5,#1
0000b0  ea464605          ORR      r6,r6,r5,LSL #16
0000b4  6a85              LDR      r5,[r0,#0x28]
0000b6  8aad              LDRH     r5,[r5,#0x14]
0000b8  1e6d              SUBS     r5,r5,#1
0000ba  ea465605          ORR      r6,r6,r5,LSL #20
0000be  6a85              LDR      r5,[r0,#0x28]
0000c0  7e2d              LDRB     r5,[r5,#0x18]
0000c2  1e6d              SUBS     r5,r5,#1
0000c4  ea466505          ORR      r5,r6,r5,LSL #24
0000c8  4329              ORRS     r1,r1,r5
;;;1006                             (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay)-1) << 4) |
;;;1007                             (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime)-1) << 8) |
;;;1008                             (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay)-1) << 12) |
;;;1009                             (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)-1) << 16) |
;;;1010                             (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)-1) << 20) |
;;;1011                             (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay)-1) << 24);
;;;1012               
;;;1013               FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr2;
0000ca  4d1d              LDR      r5,|L23.320|
0000cc  3508              ADDS     r5,r5,#8
0000ce  6806              LDR      r6,[r0,#0]
0000d0  f8451026          STR      r1,[r5,r6,LSL #2]
0000d4  e032              B        |L23.316|
                  |L23.214|
0000d6  e7ff              B        |L23.216|
                  |L23.216|
;;;1014     }
;;;1015     else   /* SDTR "don't care bits configuration */
;;;1016     {
;;;1017       /* Get SDTR register value */
;;;1018       tmpr2 = FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank];
0000d8  4d19              LDR      r5,|L23.320|
0000da  3508              ADDS     r5,r5,#8
0000dc  6806              LDR      r6,[r0,#0]
0000de  f8551026          LDR      r1,[r5,r6,LSL #2]
;;;1019   
;;;1020       /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
;;;1021       tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
0000e2  f0014170          AND      r1,r1,#0xf0000000
;;;1022                             FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
;;;1023                             FMC_SDTR1_TRCD));
;;;1024   
;;;1025       tmpr2 |=   (uint32_t)((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)-1) |
0000e6  6a85              LDR      r5,[r0,#0x28]
0000e8  682d              LDR      r5,[r5,#0]
0000ea  1e6d              SUBS     r5,r5,#1
0000ec  6a86              LDR      r6,[r0,#0x28]
0000ee  6876              LDR      r6,[r6,#4]
0000f0  1e76              SUBS     r6,r6,#1
0000f2  ea451606          ORR      r6,r5,r6,LSL #4
0000f6  6a85              LDR      r5,[r0,#0x28]
0000f8  68ad              LDR      r5,[r5,#8]
0000fa  1e6d              SUBS     r5,r5,#1
0000fc  ea462605          ORR      r6,r6,r5,LSL #8
000100  6a85              LDR      r5,[r0,#0x28]
000102  8a2d              LDRH     r5,[r5,#0x10]
000104  1e6d              SUBS     r5,r5,#1
000106  ea464505          ORR      r5,r6,r5,LSL #16
00010a  4329              ORRS     r1,r1,r5
;;;1026                             (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay)-1) << 4) |
;;;1027                             (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime)-1) << 8) |
;;;1028                             (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)-1) << 16);
;;;1029       
;;;1030       /* Get SDTR register value */
;;;1031       tmpr4 = FMC_Bank5_6->SDTR[FMC_Bank1_SDRAM];
00010c  4d0c              LDR      r5,|L23.320|
00010e  3508              ADDS     r5,r5,#8
000110  682c              LDR      r4,[r5,#0]
;;;1032   
;;;1033       /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
;;;1034       tmpr4 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
000112  f0044470          AND      r4,r4,#0xf0000000
;;;1035                             FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
;;;1036                             FMC_SDTR1_TRCD));
;;;1037   
;;;1038       tmpr4 |=   (uint32_t)(((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay)-1) << 12) |
000116  6a85              LDR      r5,[r0,#0x28]
000118  68ed              LDR      r5,[r5,#0xc]
00011a  1e6d              SUBS     r5,r5,#1
00011c  032e              LSLS     r6,r5,#12
00011e  6a85              LDR      r5,[r0,#0x28]
000120  8aad              LDRH     r5,[r5,#0x14]
000122  1e6d              SUBS     r5,r5,#1
000124  ea465505          ORR      r5,r6,r5,LSL #20
000128  432c              ORRS     r4,r4,r5
;;;1039                             (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)-1) << 20);
;;;1040               
;;;1041               FMC_Bank5_6->SDTR[FMC_Bank1_SDRAM] = tmpr4;
00012a  f04f4520          MOV      r5,#0xa0000000
00012e  f8c54148          STR      r4,[r5,#0x148]
;;;1042               FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr2;
000132  4d03              LDR      r5,|L23.320|
000134  3508              ADDS     r5,r5,#8
000136  6806              LDR      r6,[r0,#0]
000138  f8451026          STR      r1,[r5,r6,LSL #2]
                  |L23.316|
;;;1043     }
;;;1044     
;;;1045   }
00013c  bd70              POP      {r4-r6,pc}
;;;1046   
                          ENDP

00013e  0000              DCW      0x0000
                  |L23.320|
                          DCD      0xa0000140

                          AREA ||i.FMC_SDRAMStructInit||, CODE, READONLY, ALIGN=1

                  FMC_SDRAMStructInit PROC
;;;1052     */
;;;1053   void FMC_SDRAMStructInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct)  
000000  2100              MOVS     r1,#0
;;;1054   {  
;;;1055     /* Reset SDRAM Init structure parameters values */
;;;1056     FMC_SDRAMInitStruct->FMC_Bank = FMC_Bank1_SDRAM;
000002  6001              STR      r1,[r0,#0]
;;;1057     FMC_SDRAMInitStruct->FMC_ColumnBitsNumber = FMC_ColumnBits_Number_8b;
000004  6041              STR      r1,[r0,#4]
;;;1058     FMC_SDRAMInitStruct->FMC_RowBitsNumber = FMC_RowBits_Number_11b; 
000006  6081              STR      r1,[r0,#8]
;;;1059     FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth = FMC_SDMemory_Width_16b;
000008  2110              MOVS     r1,#0x10
00000a  60c1              STR      r1,[r0,#0xc]
;;;1060     FMC_SDRAMInitStruct->FMC_InternalBankNumber = FMC_InternalBank_Number_4; 
00000c  2140              MOVS     r1,#0x40
00000e  6101              STR      r1,[r0,#0x10]
;;;1061     FMC_SDRAMInitStruct->FMC_CASLatency = FMC_CAS_Latency_1;  
000010  2180              MOVS     r1,#0x80
000012  6141              STR      r1,[r0,#0x14]
;;;1062     FMC_SDRAMInitStruct->FMC_WriteProtection = FMC_Write_Protection_Enable;
000014  0089              LSLS     r1,r1,#2
000016  6181              STR      r1,[r0,#0x18]
;;;1063     FMC_SDRAMInitStruct->FMC_SDClockPeriod = FMC_SDClock_Disable;
000018  2100              MOVS     r1,#0
00001a  61c1              STR      r1,[r0,#0x1c]
;;;1064     FMC_SDRAMInitStruct->FMC_ReadBurst = FMC_Read_Burst_Disable;
00001c  6201              STR      r1,[r0,#0x20]
;;;1065     FMC_SDRAMInitStruct->FMC_ReadPipeDelay = FMC_ReadPipe_Delay_0; 
00001e  6241              STR      r1,[r0,#0x24]
;;;1066      
;;;1067     FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay = 16;
000020  2110              MOVS     r1,#0x10
000022  6a82              LDR      r2,[r0,#0x28]
000024  6011              STR      r1,[r2,#0]
;;;1068     FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay = 16;
000026  6a82              LDR      r2,[r0,#0x28]
000028  6051              STR      r1,[r2,#4]
;;;1069     FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime = 16;
00002a  6a82              LDR      r2,[r0,#0x28]
00002c  6091              STR      r1,[r2,#8]
;;;1070     FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay = 16;
00002e  6a82              LDR      r2,[r0,#0x28]
000030  60d1              STR      r1,[r2,#0xc]
;;;1071     FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime = 16;
000032  6a82              LDR      r2,[r0,#0x28]
000034  6111              STR      r1,[r2,#0x10]
;;;1072     FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay = 16;
000036  6a82              LDR      r2,[r0,#0x28]
000038  6151              STR      r1,[r2,#0x14]
;;;1073     FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay = 16;
00003a  6a82              LDR      r2,[r0,#0x28]
00003c  6191              STR      r1,[r2,#0x18]
;;;1074     
;;;1075   }
00003e  4770              BX       lr
;;;1076   
                          ENDP


                          AREA ||i.FMC_SDRAMWriteProtectionConfig||, CODE, READONLY, ALIGN=1

                  FMC_SDRAMWriteProtectionConfig PROC
;;;1164     */
;;;1165   void FMC_SDRAMWriteProtectionConfig(uint32_t SDRAM_Bank, FunctionalState NewState)
000000  b161              CBZ      r1,|L25.28|
;;;1166   {
;;;1167     /* Check the parameter */
;;;1168     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1169     assert_param(IS_FMC_SDRAM_BANK(SDRAM_Bank));
;;;1170     
;;;1171     if (NewState != DISABLE)
;;;1172     {
;;;1173       FMC_Bank5_6->SDCR[SDRAM_Bank] |= FMC_Write_Protection_Enable;    
000002  0082              LSLS     r2,r0,#2
000004  f1a242c0          SUB      r2,r2,#0x60000000
000008  f8d22140          LDR      r2,[r2,#0x140]
00000c  f4427300          ORR      r3,r2,#0x200
000010  0082              LSLS     r2,r0,#2
000012  f1a242c0          SUB      r2,r2,#0x60000000
000016  f8c23140          STR      r3,[r2,#0x140]
00001a  e00c              B        |L25.54|
                  |L25.28|
;;;1174     }
;;;1175     else
;;;1176     {
;;;1177       FMC_Bank5_6->SDCR[SDRAM_Bank] &= SDCR_WriteProtection_RESET;
00001c  0082              LSLS     r2,r0,#2
00001e  f1a242c0          SUB      r2,r2,#0x60000000
000022  f8d22140          LDR      r2,[r2,#0x140]
000026  f64753ff          MOV      r3,#0x7dff
00002a  401a              ANDS     r2,r2,r3
00002c  0083              LSLS     r3,r0,#2
00002e  f1a343c0          SUB      r3,r3,#0x60000000
000032  f8c32140          STR      r2,[r3,#0x140]
                  |L25.54|
;;;1178     } 
;;;1179     
;;;1180   }
000036  4770              BX       lr
;;;1181   
                          ENDP


                          AREA ||i.FMC_SetAutoRefresh_Number||, CODE, READONLY, ALIGN=2

                  FMC_SetAutoRefresh_Number PROC
;;;1148     */
;;;1149   void FMC_SetAutoRefresh_Number(uint32_t FMC_Number)
000000  4904              LDR      r1,|L26.20|
;;;1150   {
;;;1151     /* check the parameters */
;;;1152     assert_param(IS_FMC_AUTOREFRESH_NUMBER(FMC_Number));
;;;1153     
;;;1154     FMC_Bank5_6->SDCMR |= (FMC_Number << 5);   
000002  6809              LDR      r1,[r1,#0]
000004  ea411140          ORR      r1,r1,r0,LSL #5
000008  f04f4220          MOV      r2,#0xa0000000
00000c  f8c21150          STR      r1,[r2,#0x150]
;;;1155   }
000010  4770              BX       lr
;;;1156   
                          ENDP

000012  0000              DCW      0x0000
                  |L26.20|
                          DCD      0xa0000150

                          AREA ||i.FMC_SetRefreshCount||, CODE, READONLY, ALIGN=2

                  FMC_SetRefreshCount PROC
;;;1134     */
;;;1135   void FMC_SetRefreshCount(uint32_t FMC_Count)
000000  4904              LDR      r1,|L27.20|
;;;1136   {
;;;1137     /* check the parameters */
;;;1138     assert_param(IS_FMC_REFRESH_COUNT(FMC_Count));
;;;1139     
;;;1140     FMC_Bank5_6->SDRTR |= (FMC_Count<<1);
000002  6809              LDR      r1,[r1,#0]
000004  ea410140          ORR      r1,r1,r0,LSL #1
000008  f04f4220          MOV      r2,#0xa0000000
00000c  f8c21154          STR      r1,[r2,#0x154]
;;;1141      
;;;1142   }
000010  4770              BX       lr
;;;1143   
                          ENDP

000012  0000              DCW      0x0000
                  |L27.20|
                          DCD      0xa0000154

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  FMC_DefaultTimingStruct
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x000000ff
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_fmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_fmc_c_cedc13fd____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___15_stm32f4xx_fmc_c_cedc13fd____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_fmc_c_cedc13fd____REVSH|
#line 153
|__asm___15_stm32f4xx_fmc_c_cedc13fd____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_fmc_c_cedc13fd____RRX|
#line 328
|__asm___15_stm32f4xx_fmc_c_cedc13fd____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
