; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_hash.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_hash.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_hash.crf ..\FWLIB\src\stm32f4xx_hash.c]
                          THUMB

                          AREA ||i.HASH_AutoStartDigest||, CODE, READONLY, ALIGN=2

                  HASH_AutoStartDigest PROC
;;;464      */
;;;465    void HASH_AutoStartDigest(FunctionalState NewState)
000000  b130              CBZ      r0,|L1.16|
;;;466    {
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;469    
;;;470      if (NewState != DISABLE)
;;;471      {
;;;472        /* Enable the auto start of the final message digest at the end of DMA transfer */
;;;473        HASH->CR &= ~HASH_CR_MDMAT;
000002  4907              LDR      r1,|L1.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4215100          BIC      r1,r1,#0x2000
00000a  4a05              LDR      r2,|L1.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L1.28|
                  |L1.16|
;;;474      }
;;;475      else
;;;476      {
;;;477        /* Disable the auto start of the final message digest at the end of DMA transfer */
;;;478        HASH->CR |= HASH_CR_MDMAT;
000010  4903              LDR      r1,|L1.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4415100          ORR      r1,r1,#0x2000
000018  4a01              LDR      r2,|L1.32|
00001a  6011              STR      r1,[r2,#0]
                  |L1.28|
;;;479      }
;;;480    }
00001c  4770              BX       lr
;;;481      
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0x50060400

                          AREA ||i.HASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  HASH_ClearFlag PROC
;;;650      */
;;;651    void HASH_ClearFlag(uint32_t HASH_FLAG)
000000  43c1              MVNS     r1,r0
;;;652    {
;;;653      /* Check the parameters */
;;;654      assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
;;;655      
;;;656      /* Clear the selected HASH flags */
;;;657      HASH->SR = ~(uint32_t)HASH_FLAG;
000002  4a01              LDR      r2,|L2.8|
000004  6011              STR      r1,[r2,#0]
;;;658    }
000006  4770              BX       lr
;;;659    /**
                          ENDP

                  |L2.8|
                          DCD      0x50060424

                          AREA ||i.HASH_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  HASH_ClearITPendingBit PROC
;;;700      */
;;;701    void HASH_ClearITPendingBit(uint32_t HASH_IT)
000000  43c1              MVNS     r1,r0
;;;702    {
;;;703      /* Check the parameters */
;;;704      assert_param(IS_HASH_IT(HASH_IT));
;;;705    
;;;706      /* Clear the selected HASH interrupt pending bit */
;;;707      HASH->SR = (uint32_t)(~HASH_IT);
000002  4a01              LDR      r2,|L3.8|
000004  6011              STR      r1,[r2,#0]
;;;708    }
000006  4770              BX       lr
;;;709    
                          ENDP

                  |L3.8|
                          DCD      0x50060424

                          AREA ||i.HASH_DMACmd||, CODE, READONLY, ALIGN=2

                  HASH_DMACmd PROC
;;;488      */
;;;489    void HASH_DMACmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L4.16|
;;;490    {
;;;491      /* Check the parameters */
;;;492      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;493    
;;;494      if (NewState != DISABLE)
;;;495      {
;;;496        /* Enable the HASH DMA request */
;;;497        HASH->CR |= HASH_CR_DMAE;
000002  4907              LDR      r1,|L4.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410108          ORR      r1,r1,#8
00000a  4a05              LDR      r2,|L4.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L4.28|
                  |L4.16|
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Disable the HASH DMA request */
;;;502        HASH->CR &= ~HASH_CR_DMAE;
000010  4903              LDR      r1,|L4.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210108          BIC      r1,r1,#8
000018  4a01              LDR      r2,|L4.32|
00001a  6011              STR      r1,[r2,#0]
                  |L4.28|
;;;503      }
;;;504    }
00001c  4770              BX       lr
;;;505    /**
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x50060400

                          AREA ||i.HASH_DataIn||, CODE, READONLY, ALIGN=2

                  HASH_DataIn PROC
;;;305      */
;;;306    void HASH_DataIn(uint32_t Data)
000000  4901              LDR      r1,|L5.8|
;;;307    {
;;;308      /* Write in the DIN register a new data */
;;;309      HASH->DIN = Data;
000002  6008              STR      r0,[r1,#0]
;;;310    }
000004  4770              BX       lr
;;;311    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x50060404

                          AREA ||i.HASH_DeInit||, CODE, READONLY, ALIGN=1

                  HASH_DeInit PROC
;;;170      */
;;;171    void HASH_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173      /* Enable HASH reset state */
;;;174      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
000002  2101              MOVS     r1,#1
000004  2020              MOVS     r0,#0x20
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;175      /* Release HASH from reset state */
;;;176      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  2020              MOVS     r0,#0x20
00000e  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;177    }
000012  bd10              POP      {r4,pc}
;;;178    
                          ENDP


                          AREA ||i.HASH_GetDigest||, CODE, READONLY, ALIGN=2

                  HASH_GetDigest PROC
;;;334      */
;;;335    void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
000000  490f              LDR      r1,|L7.64|
;;;336    {
;;;337      /* Get the data field */
;;;338      HASH_MessageDigest->Data[0] = HASH->HR[0];
000002  6809              LDR      r1,[r1,#0]
000004  6001              STR      r1,[r0,#0]
;;;339      HASH_MessageDigest->Data[1] = HASH->HR[1];
000006  490e              LDR      r1,|L7.64|
000008  390c              SUBS     r1,r1,#0xc
00000a  6909              LDR      r1,[r1,#0x10]
00000c  6041              STR      r1,[r0,#4]
;;;340      HASH_MessageDigest->Data[2] = HASH->HR[2];
00000e  490c              LDR      r1,|L7.64|
000010  390c              SUBS     r1,r1,#0xc
000012  6949              LDR      r1,[r1,#0x14]
000014  6081              STR      r1,[r0,#8]
;;;341      HASH_MessageDigest->Data[3] = HASH->HR[3];
000016  490a              LDR      r1,|L7.64|
000018  390c              SUBS     r1,r1,#0xc
00001a  6989              LDR      r1,[r1,#0x18]
00001c  60c1              STR      r1,[r0,#0xc]
;;;342      HASH_MessageDigest->Data[4] = HASH->HR[4];
00001e  4908              LDR      r1,|L7.64|
000020  390c              SUBS     r1,r1,#0xc
000022  69c9              LDR      r1,[r1,#0x1c]
000024  6101              STR      r1,[r0,#0x10]
;;;343      HASH_MessageDigest->Data[5] = HASH_DIGEST->HR[5];
000026  4907              LDR      r1,|L7.68|
000028  6809              LDR      r1,[r1,#0]
00002a  6141              STR      r1,[r0,#0x14]
;;;344      HASH_MessageDigest->Data[6] = HASH_DIGEST->HR[6];
00002c  4905              LDR      r1,|L7.68|
00002e  1d09              ADDS     r1,r1,#4
000030  6809              LDR      r1,[r1,#0]
000032  6181              STR      r1,[r0,#0x18]
;;;345      HASH_MessageDigest->Data[7] = HASH_DIGEST->HR[7];
000034  4903              LDR      r1,|L7.68|
000036  3108              ADDS     r1,r1,#8
000038  6809              LDR      r1,[r1,#0]
00003a  61c1              STR      r1,[r0,#0x1c]
;;;346    }
00003c  4770              BX       lr
;;;347    
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      0x5006040c
                  |L7.68|
                          DCD      0x50060724

                          AREA ||i.HASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  HASH_GetFlagStatus PROC
;;;609      */
;;;610    FlagStatus HASH_GetFlagStatus(uint32_t HASH_FLAG)
000000  4601              MOV      r1,r0
;;;611    {
;;;612      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;613      uint32_t tempreg = 0;
000004  2200              MOVS     r2,#0
;;;614    
;;;615      /* Check the parameters */
;;;616      assert_param(IS_HASH_GET_FLAG(HASH_FLAG));
;;;617    
;;;618      /* check if the FLAG is in CR register */
;;;619      if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint32_t)RESET ) 
000006  f4015380          AND      r3,r1,#0x1000
00000a  b113              CBZ      r3,|L8.18|
;;;620      {
;;;621        tempreg = HASH->CR;
00000c  4b06              LDR      r3,|L8.40|
00000e  681a              LDR      r2,[r3,#0]
000010  e002              B        |L8.24|
                  |L8.18|
;;;622      }
;;;623      else /* The FLAG is in SR register */
;;;624      {
;;;625        tempreg = HASH->SR;
000012  4b05              LDR      r3,|L8.40|
000014  3324              ADDS     r3,r3,#0x24
000016  681a              LDR      r2,[r3,#0]
                  |L8.24|
;;;626      }
;;;627    
;;;628      /* Check the status of the specified HASH flag */
;;;629      if ((tempreg & HASH_FLAG) != (uint32_t)RESET)
000018  ea020301          AND      r3,r2,r1
00001c  b10b              CBZ      r3,|L8.34|
;;;630      {
;;;631        /* HASH is set */
;;;632        bitstatus = SET;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L8.36|
                  |L8.34|
;;;633      }
;;;634      else
;;;635      {
;;;636        /* HASH_FLAG is reset */
;;;637        bitstatus = RESET;
000022  2000              MOVS     r0,#0
                  |L8.36|
;;;638      }
;;;639    
;;;640      /* Return the HASH_FLAG status */
;;;641      return  bitstatus;
;;;642    }
000024  4770              BX       lr
;;;643    /**
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      0x50060400

                          AREA ||i.HASH_GetITStatus||, CODE, READONLY, ALIGN=2

                  HASH_GetITStatus PROC
;;;666      */
;;;667    ITStatus HASH_GetITStatus(uint32_t HASH_IT)
000000  4601              MOV      r1,r0
;;;668    {
;;;669      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;670      uint32_t tmpreg = 0;
000004  2200              MOVS     r2,#0
;;;671    
;;;672      /* Check the parameters */
;;;673      assert_param(IS_HASH_GET_IT(HASH_IT));  
;;;674    
;;;675    
;;;676      /* Check the status of the specified HASH interrupt */
;;;677      tmpreg =  HASH->SR;
000006  4b05              LDR      r3,|L9.28|
000008  681a              LDR      r2,[r3,#0]
;;;678    
;;;679      if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
00000a  1f1b              SUBS     r3,r3,#4
00000c  681b              LDR      r3,[r3,#0]
00000e  4013              ANDS     r3,r3,r2
000010  400b              ANDS     r3,r3,r1
000012  b10b              CBZ      r3,|L9.24|
;;;680      {
;;;681        /* HASH_IT is set */
;;;682        bitstatus = SET;
000014  2001              MOVS     r0,#1
000016  e000              B        |L9.26|
                  |L9.24|
;;;683      }
;;;684      else
;;;685      {
;;;686        /* HASH_IT is reset */
;;;687        bitstatus = RESET;
000018  2000              MOVS     r0,#0
                  |L9.26|
;;;688      }
;;;689      /* Return the HASH_IT status */
;;;690      return bitstatus;
;;;691    }
00001a  4770              BX       lr
;;;692    
                          ENDP

                  |L9.28|
                          DCD      0x50060424

                          AREA ||i.HASH_GetInFIFOWordsNbr||, CODE, READONLY, ALIGN=2

                  HASH_GetInFIFOWordsNbr PROC
;;;316      */
;;;317    uint8_t HASH_GetInFIFOWordsNbr(void)
000000  4802              LDR      r0,|L10.12|
;;;318    {
;;;319      /* Return the value of NBW bits */
;;;320      return ((HASH->CR & HASH_CR_NBW) >> 8);
000002  6800              LDR      r0,[r0,#0]
000004  f3c02003          UBFX     r0,r0,#8,#4
;;;321    }
000008  4770              BX       lr
;;;322    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x50060400

                          AREA ||i.HASH_ITConfig||, CODE, READONLY, ALIGN=2

                  HASH_ITConfig PROC
;;;580      */
;;;581    void HASH_ITConfig(uint32_t HASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L11.14|
;;;582    {
;;;583      /* Check the parameters */
;;;584      assert_param(IS_HASH_IT(HASH_IT));
;;;585      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;586    
;;;587      if (NewState != DISABLE)
;;;588      {
;;;589        /* Enable the selected HASH interrupt */
;;;590        HASH->IMR |= HASH_IT;
000002  4a06              LDR      r2,|L11.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L11.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L11.24|
                  |L11.14|
;;;591      }
;;;592      else
;;;593      {
;;;594        /* Disable the selected HASH interrupt */
;;;595        HASH->IMR &= (uint32_t)(~HASH_IT);
00000e  4a03              LDR      r2,|L11.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L11.28|
000016  601a              STR      r2,[r3,#0]
                  |L11.24|
;;;596      }
;;;597    }
000018  4770              BX       lr
;;;598    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x50060420

                          AREA ||i.HASH_Init||, CODE, READONLY, ALIGN=2

                  HASH_Init PROC
;;;190      */
;;;191    void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
000000  4912              LDR      r1,|L12.76|
;;;192    {
;;;193      /* Check the parameters */
;;;194      assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
;;;195      assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
;;;196      assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
;;;197      
;;;198      /* Configure the Algorithm used, algorithm mode and the datatype */
;;;199      HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
000002  6809              LDR      r1,[r1,#0]
000004  4a12              LDR      r2,|L12.80|
000006  4011              ANDS     r1,r1,r2
000008  4a10              LDR      r2,|L12.76|
00000a  6011              STR      r1,[r2,#0]
;;;200      HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
00000c  6882              LDR      r2,[r0,#8]
00000e  6801              LDR      r1,[r0,#0]
000010  4311              ORRS     r1,r1,r2
000012  6842              LDR      r2,[r0,#4]
000014  4311              ORRS     r1,r1,r2
000016  4a0d              LDR      r2,|L12.76|
000018  6812              LDR      r2,[r2,#0]
00001a  4311              ORRS     r1,r1,r2
00001c  4a0b              LDR      r2,|L12.76|
00001e  6011              STR      r1,[r2,#0]
;;;201                   HASH_InitStruct->HASH_DataType | \
;;;202                   HASH_InitStruct->HASH_AlgoMode);
;;;203      
;;;204      /* if algorithm mode is HMAC, set the Key */  
;;;205      if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
000020  6841              LDR      r1,[r0,#4]
000022  2940              CMP      r1,#0x40
000024  d10a              BNE      |L12.60|
;;;206      {
;;;207        assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
;;;208        HASH->CR &= ~HASH_CR_LKEY;
000026  4611              MOV      r1,r2
000028  6809              LDR      r1,[r1,#0]
00002a  f4213180          BIC      r1,r1,#0x10000
00002e  6011              STR      r1,[r2,#0]
;;;209        HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
000030  4611              MOV      r1,r2
000032  6809              LDR      r1,[r1,#0]
000034  68c2              LDR      r2,[r0,#0xc]
000036  4311              ORRS     r1,r1,r2
000038  4a04              LDR      r2,|L12.76|
00003a  6011              STR      r1,[r2,#0]
                  |L12.60|
;;;210      }
;;;211    
;;;212      /* Reset the HASH processor core, so that the HASH will be ready to compute 
;;;213         the message digest of a new message */
;;;214      HASH->CR |= HASH_CR_INIT;  
00003c  4903              LDR      r1,|L12.76|
00003e  6809              LDR      r1,[r1,#0]
000040  f0410104          ORR      r1,r1,#4
000044  4a01              LDR      r2,|L12.76|
000046  6011              STR      r1,[r2,#0]
;;;215    }
000048  4770              BX       lr
;;;216    
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      0x50060400
                  |L12.80|
                          DCD      0xfffbff0f

                          AREA ||i.HASH_Reset||, CODE, READONLY, ALIGN=2

                  HASH_Reset PROC
;;;248      */
;;;249    void HASH_Reset(void)
000000  4803              LDR      r0,|L13.16|
;;;250    {
;;;251      /* Reset the HASH processor core */
;;;252      HASH->CR |= HASH_CR_INIT;
000002  6800              LDR      r0,[r0,#0]
000004  f0400004          ORR      r0,r0,#4
000008  4901              LDR      r1,|L13.16|
00000a  6008              STR      r0,[r1,#0]
;;;253    }
00000c  4770              BX       lr
;;;254    /**
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      0x50060400

                          AREA ||i.HASH_RestoreContext||, CODE, READONLY, ALIGN=2

                  HASH_RestoreContext PROC
;;;417      */
;;;418    void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
000000  2100              MOVS     r1,#0
;;;419    {
;;;420      uint8_t i = 0;
;;;421      
;;;422      /* restore context registers */
;;;423      HASH->IMR = HASH_ContextRestore->HASH_IMR;   
000002  4b0f              LDR      r3,|L14.64|
000004  6802              LDR      r2,[r0,#0]
000006  601a              STR      r2,[r3,#0]
;;;424      HASH->STR = HASH_ContextRestore->HASH_STR;     
000008  4b0d              LDR      r3,|L14.64|
00000a  3b18              SUBS     r3,r3,#0x18
00000c  6842              LDR      r2,[r0,#4]
00000e  601a              STR      r2,[r3,#0]
;;;425      HASH->CR = HASH_ContextRestore->HASH_CR;
000010  4b0b              LDR      r3,|L14.64|
000012  3b20              SUBS     r3,r3,#0x20
000014  6882              LDR      r2,[r0,#8]
000016  601a              STR      r2,[r3,#0]
;;;426      
;;;427      /* Initialize the hash processor */
;;;428      HASH->CR |= HASH_CR_INIT; 
000018  461a              MOV      r2,r3
00001a  6812              LDR      r2,[r2,#0]
00001c  f0420204          ORR      r2,r2,#4
000020  601a              STR      r2,[r3,#0]
;;;429      
;;;430       /* continue restoring context registers */     
;;;431      for(i=0; i<=53;i++)
000022  bf00              NOP      
000024  e009              B        |L14.58|
                  |L14.38|
;;;432      {
;;;433         HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
000026  f100020c          ADD      r2,r0,#0xc
00002a  f8523021          LDR      r3,[r2,r1,LSL #2]
00002e  4a04              LDR      r2,|L14.64|
000030  32d8              ADDS     r2,r2,#0xd8
000032  f8423021          STR      r3,[r2,r1,LSL #2]
000036  1c4a              ADDS     r2,r1,#1              ;431
000038  b2d1              UXTB     r1,r2                 ;431
                  |L14.58|
00003a  2935              CMP      r1,#0x35              ;431
00003c  ddf3              BLE      |L14.38|
;;;434      }   
;;;435    }
00003e  4770              BX       lr
;;;436    /**
                          ENDP

                  |L14.64|
                          DCD      0x50060420

                          AREA ||i.HASH_SaveContext||, CODE, READONLY, ALIGN=2

                  HASH_SaveContext PROC
;;;395      */
;;;396    void HASH_SaveContext(HASH_Context* HASH_ContextSave)
000000  2100              MOVS     r1,#0
;;;397    {
;;;398      uint8_t i = 0;
;;;399      
;;;400      /* save context registers */
;;;401      HASH_ContextSave->HASH_IMR = HASH->IMR;  
000002  4a0d              LDR      r2,|L15.56|
000004  6812              LDR      r2,[r2,#0]
000006  6002              STR      r2,[r0,#0]
;;;402      HASH_ContextSave->HASH_STR = HASH->STR;      
000008  4a0b              LDR      r2,|L15.56|
00000a  3a18              SUBS     r2,r2,#0x18
00000c  6812              LDR      r2,[r2,#0]
00000e  6042              STR      r2,[r0,#4]
;;;403      HASH_ContextSave->HASH_CR  = HASH->CR;     
000010  4a09              LDR      r2,|L15.56|
000012  3a20              SUBS     r2,r2,#0x20
000014  6812              LDR      r2,[r2,#0]
000016  6082              STR      r2,[r0,#8]
;;;404      for(i=0; i<=53;i++)
000018  bf00              NOP      
00001a  e009              B        |L15.48|
                  |L15.28|
;;;405      {
;;;406         HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
00001c  4a06              LDR      r2,|L15.56|
00001e  32d8              ADDS     r2,r2,#0xd8
000020  f8523021          LDR      r3,[r2,r1,LSL #2]
000024  f100020c          ADD      r2,r0,#0xc
000028  f8423021          STR      r3,[r2,r1,LSL #2]
00002c  1c4a              ADDS     r2,r1,#1              ;404
00002e  b2d1              UXTB     r1,r2                 ;404
                  |L15.48|
000030  2935              CMP      r1,#0x35              ;404
000032  ddf3              BLE      |L15.28|
;;;407      }   
;;;408    }
000034  4770              BX       lr
;;;409    
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      0x50060420

                          AREA ||i.HASH_SetLastWordValidBitsNbr||, CODE, READONLY, ALIGN=2

                  HASH_SetLastWordValidBitsNbr PROC
;;;290      */
;;;291    void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber)
000000  4905              LDR      r1,|L16.24|
;;;292    {
;;;293      /* Check the parameters */
;;;294      assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
;;;295      
;;;296      /* Configure the Number of valid bits in last word of the message */
;;;297      HASH->STR &= ~(HASH_STR_NBW);
000002  6809              LDR      r1,[r1,#0]
000004  f021011f          BIC      r1,r1,#0x1f
000008  4a03              LDR      r2,|L16.24|
00000a  6011              STR      r1,[r2,#0]
;;;298      HASH->STR |= ValidNumber;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;299    }
000014  4770              BX       lr
;;;300    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0x50060408

                          AREA ||i.HASH_StartDigest||, CODE, READONLY, ALIGN=2

                  HASH_StartDigest PROC
;;;352      */
;;;353    void HASH_StartDigest(void)
000000  4803              LDR      r0,|L17.16|
;;;354    {
;;;355      /* Start the Digest calculation */
;;;356      HASH->STR |= HASH_STR_DCAL;
000002  6800              LDR      r0,[r0,#0]
000004  f4407080          ORR      r0,r0,#0x100
000008  4901              LDR      r1,|L17.16|
00000a  6008              STR      r0,[r1,#0]
;;;357    }
00000c  4770              BX       lr
;;;358    /**
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x50060408

                          AREA ||i.HASH_StructInit||, CODE, READONLY, ALIGN=1

                  HASH_StructInit PROC
;;;224      */
;;;225    void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
000000  2100              MOVS     r1,#0
;;;226    {
;;;227      /* Initialize the HASH_AlgoSelection member */
;;;228      HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
000002  6001              STR      r1,[r0,#0]
;;;229    
;;;230      /* Initialize the HASH_AlgoMode member */
;;;231      HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
000004  6041              STR      r1,[r0,#4]
;;;232    
;;;233      /* Initialize the HASH_DataType member */
;;;234      HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
000006  6081              STR      r1,[r0,#8]
;;;235    
;;;236      /* Initialize the HASH_HMACKeyType member */
;;;237      HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
000008  60c1              STR      r1,[r0,#0xc]
;;;238    }
00000a  4770              BX       lr
;;;239    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_hash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_hash_c_90573c7c____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___16_stm32f4xx_hash_c_90573c7c____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_hash_c_90573c7c____REVSH|
#line 153
|__asm___16_stm32f4xx_hash_c_90573c7c____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_hash_c_90573c7c____RRX|
#line 328
|__asm___16_stm32f4xx_hash_c_90573c7c____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
