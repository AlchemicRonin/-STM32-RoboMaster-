; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\cloudmotor.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\cloudmotor.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\cloudmotor.crf ..\HAL\cloudmotor.c]
                          THUMB

                          AREA ||i.Set_CloudMotor_Current||, CODE, READONLY, ALIGN=2

                  Set_CloudMotor_Current PROC
;;;121    
;;;122    void Set_CloudMotor_Current(int16_t gimbal_yaw_iq, int16_t gimbal_pitch_iq)//云台电机电流发送函数//CAN1发送函数
000000  b530              PUSH     {r4,r5,lr}
;;;123    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;124        CanTxMsg tx_message;    
;;;125        tx_message.StdId = 0x1FF;
000008  f24010ff          MOV      r0,#0x1ff
00000c  9000              STR      r0,[sp,#0]
;;;126        tx_message.IDE = CAN_Id_Standard;
00000e  2000              MOVS     r0,#0
000010  f88d0008          STRB     r0,[sp,#8]
;;;127        tx_message.RTR = CAN_RTR_Data;
000014  f88d0009          STRB     r0,[sp,#9]
;;;128        tx_message.DLC = 0x08;
000018  2008              MOVS     r0,#8
00001a  f88d000a          STRB     r0,[sp,#0xa]
;;;129        
;;;130        tx_message.Data[0] = (unsigned char)(gimbal_yaw_iq >> 8);
00001e  0a20              LSRS     r0,r4,#8
000020  f88d000b          STRB     r0,[sp,#0xb]
;;;131        tx_message.Data[1] = (unsigned char)gimbal_yaw_iq;
000024  b2e1              UXTB     r1,r4
000026  f88d100c          STRB     r1,[sp,#0xc]
;;;132        tx_message.Data[2] = (unsigned char)(gimbal_pitch_iq >> 8);
00002a  0a29              LSRS     r1,r5,#8
00002c  f88d100d          STRB     r1,[sp,#0xd]
;;;133        tx_message.Data[3] = (unsigned char)gimbal_pitch_iq;
000030  b2e9              UXTB     r1,r5
000032  f88d100e          STRB     r1,[sp,#0xe]
;;;134    		tx_message.Data[4] = 0x00;
000036  2100              MOVS     r1,#0
000038  f88d100f          STRB     r1,[sp,#0xf]
;;;135        tx_message.Data[5] = 0x00;
00003c  f88d1010          STRB     r1,[sp,#0x10]
;;;136        tx_message.Data[6] = 0x00;
000040  f88d1011          STRB     r1,[sp,#0x11]
;;;137        tx_message.Data[7] = 0x00;
000044  f88d1012          STRB     r1,[sp,#0x12]
;;;138        CAN_Transmit(CAN1,&tx_message);
000048  4669              MOV      r1,sp
00004a  4802              LDR      r0,|L1.84|
00004c  f7fffffe          BL       CAN_Transmit
;;;139    }
000050  b005              ADD      sp,sp,#0x14
000052  bd30              POP      {r4,r5,pc}
;;;140    
                          ENDP

                  |L1.84|
                          DCD      0x40006400

                          AREA ||i.angle_init||, CODE, READONLY, ALIGN=2

                  angle_init PROC
;;;29     //云台电机pid参数初始化
;;;30     void angle_init(struct Angle *angle)//根据MPU位置改
000000  2100              MOVS     r1,#0
;;;31     {
;;;32     	angle->back_flag = 0;//标志位初始化
000002  6201              STR      r1,[r0,#0x20]
;;;33     	t_angle.pitch_first = real_angle.pitch;
000004  4924              LDR      r1,|L2.152|
000006  ed910a05          VLDR     s0,[r1,#0x14]
00000a  4924              LDR      r1,|L2.156|
00000c  ed810a0d          VSTR     s0,[r1,#0x34]
;;;34     	t_angle.yaw_first = real_angle.yaw;
000010  4921              LDR      r1,|L2.152|
000012  ed910a04          VLDR     s0,[r1,#0x10]
000016  4921              LDR      r1,|L2.156|
000018  ed810a0e          VSTR     s0,[r1,#0x38]
;;;35     	GMPitchEncoder.init_angle = GMPitchEncoder.ecd_angle;
00001c  4920              LDR      r1,|L2.160|
00001e  ed910a11          VLDR     s0,[r1,#0x44]
000022  ed810a12          VSTR     s0,[r1,#0x48]
;;;36     	GMYawEncoder.init_angle = GMYawEncoder.ecd_angle;
000026  491f              LDR      r1,|L2.164|
000028  ed910a11          VLDR     s0,[r1,#0x44]
00002c  ed810a12          VSTR     s0,[r1,#0x48]
;;;37     	angle->yaw_set = real_angle.yaw;
000030  4919              LDR      r1,|L2.152|
000032  ed910a04          VLDR     s0,[r1,#0x10]
000036  ed800a02          VSTR     s0,[r0,#8]
;;;38     	angle->pitch_set = real_angle.pitch;//读取真实值		//限位//编码器值位置值转换成mpu角度值
00003a  ed910a05          VLDR     s0,[r1,#0x14]
00003e  ed800a03          VSTR     s0,[r0,#0xc]
;;;39     	angle->pitch_target = PITCH_MECHANICAL_CENTRE + (angle->pitch_first - GMPitchEncoder.init_angle);
000042  ed900a0d          VLDR     s0,[r0,#0x34]
000046  4916              LDR      r1,|L2.160|
000048  edd10a12          VLDR     s1,[r1,#0x48]
00004c  ee300a60          VSUB.F32 s0,s0,s1
000050  eddf0a15          VLDR     s1,|L2.168|
000054  ee300a20          VADD.F32 s0,s0,s1
000058  ed800a01          VSTR     s0,[r0,#4]
;;;40     	angle->yaw_target = YAW_MECHANICAL_CENTRE + (angle->yaw_first - GMYawEncoder.init_angle);
00005c  ed900a0e          VLDR     s0,[r0,#0x38]
000060  4910              LDR      r1,|L2.164|
000062  edd10a12          VLDR     s1,[r1,#0x48]
000066  ee300a60          VSUB.F32 s0,s0,s1
00006a  eddf0a10          VLDR     s1,|L2.172|
00006e  ee300a20          VADD.F32 s0,s0,s1
000072  ed800a00          VSTR     s0,[r0,#0]
;;;41     	
;;;42     	chassis_set.YAW_CENTRE = YAW_MECHANICAL_CENTRE;
000076  ed9f0a0d          VLDR     s0,|L2.172|
00007a  490d              LDR      r1,|L2.176|
00007c  ed810a0a          VSTR     s0,[r1,#0x28]
;;;43     	chassis_set.YAW_CENTRE_Init = YAW_MECHANICAL_CENTRE;
000080  ed9f0a0a          VLDR     s0,|L2.172|
000084  ed810a0b          VSTR     s0,[r1,#0x2c]
;;;44     	chassis_set.chassis_cmd_slow_set_follow.input = chassis_set.chassis_cmd_slow_set_follow.out = YAW_MECHANICAL_CENTRE;
000088  ed9f0a08          VLDR     s0,|L2.172|
00008c  ed810a1d          VSTR     s0,[r1,#0x74]
000090  ed810a1c          VSTR     s0,[r1,#0x70]
;;;45     	
;;;46     }
000094  4770              BX       lr
;;;47     //uint64_t presstime = 0;
                          ENDP

000096  0000              DCW      0x0000
                  |L2.152|
                          DCD      real_angle
                  |L2.156|
                          DCD      t_angle
                  |L2.160|
                          DCD      GMPitchEncoder
                  |L2.164|
                          DCD      GMYawEncoder
                  |L2.168|
0000a8  c2c80000          DCFS     0xc2c80000 ; -100
                  |L2.172|
0000ac  c2ee999a          DCFS     0xc2ee999a ; -119.30000305175781
                  |L2.176|
                          DCD      chassis_set

                          AREA ||i.angle_out_update||, CODE, READONLY, ALIGN=2

                  angle_out_update PROC
;;;102    //云台电机更新输出电流值
;;;103    void angle_out_update(struct Angle *angle)
000000  b510              PUSH     {r4,lr}
;;;104    {
000002  4604              MOV      r4,r0
;;;105    	//设定值更新
;;;106    	angle_set_update(angle);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       angle_set_update
;;;107    	
;;;108    	//pid计算输出值
;;;109    	out[YAW_ANGLE] = Calculate_Current_Value(&pid[YAW_ANGLE], angle->yaw_set, real_angle.yaw);		
00000a  4831              LDR      r0,|L3.208|
00000c  ed901a04          VLDR     s2,[r0,#0x10]
000010  eef00a41          VMOV.F32 s1,s2
000014  ed941a02          VLDR     s2,[r4,#8]
000018  eeb00a41          VMOV.F32 s0,s2
00001c  482d              LDR      r0,|L3.212|
00001e  f7fffffe          BL       Calculate_Current_Value
000022  482d              LDR      r0,|L3.216|
000024  ed800a06          VSTR     s0,[r0,#0x18]
;;;110    	out[YAW_SPEED] = Calculate_Current_Value(&pid[YAW_SPEED], out[YAW_ANGLE], real_angle.gz);
000028  4829              LDR      r0,|L3.208|
00002a  ed901a09          VLDR     s2,[r0,#0x24]
00002e  eef00a41          VMOV.F32 s1,s2
000032  4829              LDR      r0,|L3.216|
000034  ed901a06          VLDR     s2,[r0,#0x18]
000038  eeb00a41          VMOV.F32 s0,s2
00003c  4825              LDR      r0,|L3.212|
00003e  304c              ADDS     r0,r0,#0x4c
000040  f7fffffe          BL       Calculate_Current_Value
000044  4824              LDR      r0,|L3.216|
000046  ed800a07          VSTR     s0,[r0,#0x1c]
;;;111    	
;;;112    	out[PITCH_ANGLE] = Calculate_Current_Value(&pid[PITCH_ANGLE], angle->pitch_set, real_angle.pitch);
00004a  4821              LDR      r0,|L3.208|
00004c  ed901a05          VLDR     s2,[r0,#0x14]
000050  eef00a41          VMOV.F32 s1,s2
000054  ed941a03          VLDR     s2,[r4,#0xc]
000058  eeb00a41          VMOV.F32 s0,s2
00005c  481d              LDR      r0,|L3.212|
00005e  3898              SUBS     r0,r0,#0x98
000060  f7fffffe          BL       Calculate_Current_Value
000064  481c              LDR      r0,|L3.216|
000066  ed800a04          VSTR     s0,[r0,#0x10]
;;;113    	out[PITCH_SPEED] = Calculate_Current_Value(&pid[PITCH_SPEED], out[PITCH_ANGLE], real_angle.gx);
00006a  4819              LDR      r0,|L3.208|
00006c  ed901a07          VLDR     s2,[r0,#0x1c]
000070  eef00a41          VMOV.F32 s1,s2
000074  4818              LDR      r0,|L3.216|
000076  ed901a04          VLDR     s2,[r0,#0x10]
00007a  eeb00a41          VMOV.F32 s0,s2
00007e  4815              LDR      r0,|L3.212|
000080  384c              SUBS     r0,r0,#0x4c
000082  f7fffffe          BL       Calculate_Current_Value
000086  4814              LDR      r0,|L3.216|
000088  ed800a05          VSTR     s0,[r0,#0x14]
;;;114    	
;;;115    	if(rc.off_line_flag == 0)
00008c  4813              LDR      r0,|L3.220|
00008e  e9d01010          LDRD     r1,r0,[r0,#0x40]
000092  2300              MOVS     r3,#0
000094  4059              EORS     r1,r1,r3
000096  4058              EORS     r0,r0,r3
000098  4301              ORRS     r1,r1,r0
00009a  d113              BNE      |L3.196|
;;;116    		Set_CloudMotor_Current((int16_t)(out[YAW_SPEED]),-(int16_t)(out[PITCH_SPEED]));
00009c  4a0e              LDR      r2,|L3.216|
00009e  ed920a05          VLDR     s0,[r2,#0x14]
0000a2  eebd0ac0          VCVT.S32.F32 s0,s0
0000a6  ee102a10          VMOV     r2,s0
0000aa  4252              RSBS     r2,r2,#0
0000ac  b211              SXTH     r1,r2
0000ae  4a0a              LDR      r2,|L3.216|
0000b0  ed920a07          VLDR     s0,[r2,#0x1c]
0000b4  eebd0ac0          VCVT.S32.F32 s0,s0
0000b8  ee102a10          VMOV     r2,s0
0000bc  b210              SXTH     r0,r2
0000be  f7fffffe          BL       Set_CloudMotor_Current
0000c2  e003              B        |L3.204|
                  |L3.196|
;;;117    //			Set_CloudMotor_Current((int16_t)(0),-(int16_t)(out[PITCH_SPEED]));
;;;118    	else
;;;119    		Set_CloudMotor_Current(0, 0);
0000c4  2100              MOVS     r1,#0
0000c6  4608              MOV      r0,r1
0000c8  f7fffffe          BL       Set_CloudMotor_Current
                  |L3.204|
;;;120    }
0000cc  bd10              POP      {r4,pc}
;;;121    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L3.208|
                          DCD      real_angle
                  |L3.212|
                          DCD      pid+0x1c8
                  |L3.216|
                          DCD      out
                  |L3.220|
                          DCD      ||rc||

                          AREA ||i.angle_set_update||, CODE, READONLY, ALIGN=2

                  angle_set_update PROC
;;;48     //云台电机更新设定值
;;;49     void angle_set_update(struct Angle *angle)
000000  6a01              LDR      r1,[r0,#0x20]
;;;50     {
;;;51     	
;;;52     	if(angle->back_flag == 0)//缓慢启动回中(采用空间云台)
000002  2900              CMP      r1,#0
000004  d172              BNE      |L4.236|
;;;53     	{
;;;54     		if(((int)angle->yaw_set != (int)angle->yaw_target) || ((int)angle->pitch_set != (int)angle->pitch_target))
000006  ed900a02          VLDR     s0,[r0,#8]
00000a  eebd0ac0          VCVT.S32.F32 s0,s0
00000e  ee101a10          VMOV     r1,s0
000012  ed900a00          VLDR     s0,[r0,#0]
000016  eebd0ac0          VCVT.S32.F32 s0,s0
00001a  ee102a10          VMOV     r2,s0
00001e  4291              CMP      r1,r2
000020  d10d              BNE      |L4.62|
000022  ed900a03          VLDR     s0,[r0,#0xc]
000026  eebd0ac0          VCVT.S32.F32 s0,s0
00002a  ee101a10          VMOV     r1,s0
00002e  ed900a01          VLDR     s0,[r0,#4]
000032  eebd0ac0          VCVT.S32.F32 s0,s0
000036  ee102a10          VMOV     r2,s0
00003a  4291              CMP      r1,r2
00003c  d052              BEQ      |L4.228|
                  |L4.62|
;;;55     		{
;;;56     			if(((int)angle->yaw_set != (int)angle->yaw_target))
00003e  ed900a02          VLDR     s0,[r0,#8]
000042  eebd0ac0          VCVT.S32.F32 s0,s0
000046  ee101a10          VMOV     r1,s0
00004a  ed900a00          VLDR     s0,[r0,#0]
00004e  eebd0ac0          VCVT.S32.F32 s0,s0
000052  ee102a10          VMOV     r2,s0
000056  4291              CMP      r1,r2
000058  d017              BEQ      |L4.138|
;;;57     				angle->yaw_set = angle->yaw_set < angle->yaw_target ? angle->yaw_set + 0.01f : angle->yaw_set - 0.01f;
00005a  ed900a02          VLDR     s0,[r0,#8]
00005e  edd00a00          VLDR     s1,[r0,#0]
000062  eeb40ae0          VCMPE.F32 s0,s1
000066  eef1fa10          VMRS     APSR_nzcv,FPSCR
00006a  d206              BCS      |L4.122|
00006c  ed900a02          VLDR     s0,[r0,#8]
000070  eddf0a99          VLDR     s1,|L4.728|
000074  ee300a20          VADD.F32 s0,s0,s1
000078  e005              B        |L4.134|
                  |L4.122|
00007a  ed900a02          VLDR     s0,[r0,#8]
00007e  eddf0a96          VLDR     s1,|L4.728|
000082  ee300a60          VSUB.F32 s0,s0,s1
                  |L4.134|
000086  ed800a02          VSTR     s0,[r0,#8]
                  |L4.138|
;;;58     			if(((int)angle->pitch_set != (int)angle->pitch_target))
00008a  ed900a03          VLDR     s0,[r0,#0xc]
00008e  eebd0ac0          VCVT.S32.F32 s0,s0
000092  ee101a10          VMOV     r1,s0
000096  ed900a01          VLDR     s0,[r0,#4]
00009a  eebd0ac0          VCVT.S32.F32 s0,s0
00009e  ee102a10          VMOV     r2,s0
0000a2  4291              CMP      r1,r2
0000a4  d01d              BEQ      |L4.226|
;;;59     			{
;;;60     				angle->pitch_set = angle->pitch_set < angle->pitch_target ? angle->pitch_set + 0.01f : angle->pitch_set - 0.01f;
0000a6  ed900a03          VLDR     s0,[r0,#0xc]
0000aa  edd00a01          VLDR     s1,[r0,#4]
0000ae  eeb40ae0          VCMPE.F32 s0,s1
0000b2  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000b6  d206              BCS      |L4.198|
0000b8  ed900a03          VLDR     s0,[r0,#0xc]
0000bc  eddf0a86          VLDR     s1,|L4.728|
0000c0  ee300a20          VADD.F32 s0,s0,s1
0000c4  e005              B        |L4.210|
                  |L4.198|
0000c6  ed900a03          VLDR     s0,[r0,#0xc]
0000ca  eddf0a83          VLDR     s1,|L4.728|
0000ce  ee300a60          VSUB.F32 s0,s0,s1
                  |L4.210|
0000d2  ed800a03          VSTR     s0,[r0,#0xc]
;;;61     				angle->pitch_remote_last = angle->pitch_remote_now = angle->pitch_set;
0000d6  ed900a03          VLDR     s0,[r0,#0xc]
0000da  ed800a0a          VSTR     s0,[r0,#0x28]
0000de  ed800a09          VSTR     s0,[r0,#0x24]
                  |L4.226|
0000e2  e0f8              B        |L4.726|
                  |L4.228|
;;;62     			}
;;;63     		}
;;;64     		else
;;;65     			angle->back_flag = 1;	
0000e4  2101              MOVS     r1,#1
0000e6  6201              STR      r1,[r0,#0x20]
0000e8  e0f5              B        |L4.726|
0000ea  e7ff              B        |L4.236|
                  |L4.236|
;;;66     	}
;;;67     	
;;;68     	else		//回中结束后开始正常操作 右键自瞄
;;;69     	{			
;;;70     		if(rc.mouse_r == 1)
0000ec  497b              LDR      r1,|L4.732|
0000ee  7c49              LDRB     r1,[r1,#0x11]  ; rc
0000f0  2901              CMP      r1,#1
0000f2  d154              BNE      |L4.414|
;;;71     		{
;;;72     			//yaw轴不限位
;;;73     			angle->yaw_set += rc.L_x / 3000.0f - (rc.mouse_x / 300.0f) + out[VISUAL_YAW_OFFSET];
0000f4  4979              LDR      r1,|L4.732|
0000f6  f9b11004          LDRSH    r1,[r1,#4]  ; rc
0000fa  ee001a10          VMOV     s0,r1
0000fe  eeb80ac0          VCVT.F32.S32 s0,s0
000102  ed9f1a77          VLDR     s2,|L4.736|
000106  eec00a01          VDIV.F32 s1,s0,s2
00010a  4974              LDR      r1,|L4.732|
00010c  f9b1100a          LDRSH    r1,[r1,#0xa]  ; rc
000110  ee001a10          VMOV     s0,r1
000114  eeb80ac0          VCVT.F32.S32 s0,s0
000118  ed9f1a72          VLDR     s2,|L4.740|
00011c  eec01a01          VDIV.F32 s3,s0,s2
000120  ee300ae1          VSUB.F32 s0,s1,s3
000124  4970              LDR      r1,|L4.744|
000126  edd10a0c          VLDR     s1,[r1,#0x30]
00012a  ee300a20          VADD.F32 s0,s0,s1
00012e  edd00a02          VLDR     s1,[r0,#8]
000132  ee300a20          VADD.F32 s0,s0,s1
000136  ed800a02          VSTR     s0,[r0,#8]
;;;74     			
;;;75     			//pitch轴加入限位
;;;76     			angle->pitch_remote_last = angle->pitch_remote_now;
00013a  ed900a0a          VLDR     s0,[r0,#0x28]
00013e  ed800a09          VSTR     s0,[r0,#0x24]
;;;77     			angle->pitch_remote_now += (-rc.L_y / 4000.0f) + (-rc.mouse_y / 400.0f) + out[VISUAL_PITCH_OFFSET] ;
000142  4966              LDR      r1,|L4.732|
000144  f9b11006          LDRSH    r1,[r1,#6]  ; rc
000148  4249              RSBS     r1,r1,#0
00014a  ee001a10          VMOV     s0,r1
00014e  eeb80ac0          VCVT.F32.S32 s0,s0
000152  ed9f1a66          VLDR     s2,|L4.748|
000156  eec00a01          VDIV.F32 s1,s0,s2
00015a  4960              LDR      r1,|L4.732|
00015c  f9b1100c          LDRSH    r1,[r1,#0xc]  ; rc
000160  4249              RSBS     r1,r1,#0
000162  ee001a10          VMOV     s0,r1
000166  eeb80ac0          VCVT.F32.S32 s0,s0
00016a  ed9f1a61          VLDR     s2,|L4.752|
00016e  eec01a01          VDIV.F32 s3,s0,s2
000172  ee300aa1          VADD.F32 s0,s1,s3
000176  495c              LDR      r1,|L4.744|
000178  edd10a0d          VLDR     s1,[r1,#0x34]
00017c  ee300a20          VADD.F32 s0,s0,s1
000180  edd00a0a          VLDR     s1,[r0,#0x28]
000184  ee300a20          VADD.F32 s0,s0,s1
000188  ed800a0a          VSTR     s0,[r0,#0x28]
;;;78     			angle->pitch_differ = angle->pitch_remote_now - angle->pitch_remote_last;
00018c  ed900a0a          VLDR     s0,[r0,#0x28]
000190  edd00a09          VLDR     s1,[r0,#0x24]
000194  ee300a60          VSUB.F32 s0,s0,s1
000198  ed800a0b          VSTR     s0,[r0,#0x2c]
00019c  e04e              B        |L4.572|
                  |L4.414|
;;;79     		}
;;;80     
;;;81     		else if(rc.mouse_r == 0)
00019e  494f              LDR      r1,|L4.732|
0001a0  7c49              LDRB     r1,[r1,#0x11]  ; rc
0001a2  bbe1              CBNZ     r1,|L4.542|
;;;82     		{ 
;;;83     			//yaw轴不限位
;;;84     			angle->yaw_set += rc.L_x / 3000.0f - (rc.mouse_x / 300.0f) ;
0001a4  494d              LDR      r1,|L4.732|
0001a6  f9b11004          LDRSH    r1,[r1,#4]  ; rc
0001aa  ee001a10          VMOV     s0,r1
0001ae  eeb80ac0          VCVT.F32.S32 s0,s0
0001b2  ed9f1a4b          VLDR     s2,|L4.736|
0001b6  eec00a01          VDIV.F32 s1,s0,s2
0001ba  4948              LDR      r1,|L4.732|
0001bc  f9b1100a          LDRSH    r1,[r1,#0xa]  ; rc
0001c0  ee001a10          VMOV     s0,r1
0001c4  eeb80ac0          VCVT.F32.S32 s0,s0
0001c8  ed9f1a46          VLDR     s2,|L4.740|
0001cc  eec01a01          VDIV.F32 s3,s0,s2
0001d0  ee300ae1          VSUB.F32 s0,s1,s3
0001d4  edd00a02          VLDR     s1,[r0,#8]
0001d8  ee300a20          VADD.F32 s0,s0,s1
0001dc  ed800a02          VSTR     s0,[r0,#8]
;;;85     			//pitch轴加入限位
;;;86     			angle->pitch_remote_last = angle->pitch_remote_now;
0001e0  ed900a0a          VLDR     s0,[r0,#0x28]
0001e4  ed800a09          VSTR     s0,[r0,#0x24]
;;;87     			angle->pitch_remote_now += (-rc.L_y / 4000.0f) + (-rc.mouse_y / 400.0f) ;
0001e8  493c              LDR      r1,|L4.732|
0001ea  f9b11006          LDRSH    r1,[r1,#6]  ; rc
0001ee  4249              RSBS     r1,r1,#0
0001f0  ee001a10          VMOV     s0,r1
0001f4  eeb80ac0          VCVT.F32.S32 s0,s0
0001f8  ed9f1a3c          VLDR     s2,|L4.748|
0001fc  eec00a01          VDIV.F32 s1,s0,s2
000200  4936              LDR      r1,|L4.732|
000202  f9b1100c          LDRSH    r1,[r1,#0xc]  ; rc
000206  4249              RSBS     r1,r1,#0
000208  ee001a10          VMOV     s0,r1
00020c  eeb80ac0          VCVT.F32.S32 s0,s0
000210  ed9f1a37          VLDR     s2,|L4.752|
000214  eec01a01          VDIV.F32 s3,s0,s2
000218  ee300aa1          VADD.F32 s0,s1,s3
00021c  e000              B        |L4.544|
                  |L4.542|
00021e  e00d              B        |L4.572|
                  |L4.544|
000220  edd00a0a          VLDR     s1,[r0,#0x28]
000224  ee300a20          VADD.F32 s0,s0,s1
000228  ed800a0a          VSTR     s0,[r0,#0x28]
;;;88     			angle->pitch_differ = angle->pitch_remote_now - angle->pitch_remote_last;
00022c  ed900a0a          VLDR     s0,[r0,#0x28]
000230  edd00a09          VLDR     s1,[r0,#0x24]
000234  ee300a60          VSUB.F32 s0,s0,s1
000238  ed800a0b          VSTR     s0,[r0,#0x2c]
                  |L4.572|
;;;89     		}
;;;90     		
;;;91     		if(GMPitchEncoder.ecd_angle <= PITCH_MECHANICAL_LOW && angle->pitch_differ > 0.0f)
00023c  492d              LDR      r1,|L4.756|
00023e  ed910a11          VLDR     s0,[r1,#0x44]
000242  eddf0a2d          VLDR     s1,|L4.760|
000246  eeb40ae0          VCMPE.F32 s0,s1
00024a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00024e  d80e              BHI      |L4.622|
000250  ed900a0b          VLDR     s0,[r0,#0x2c]
000254  eeb50ac0          VCMPE.F32 s0,#0.0
000258  eef1fa10          VMRS     APSR_nzcv,FPSCR
00025c  dd07              BLE      |L4.622|
;;;92     			angle->pitch_set +=  (angle->pitch_differ);
00025e  ed900a03          VLDR     s0,[r0,#0xc]
000262  edd00a0b          VLDR     s1,[r0,#0x2c]
000266  ee300a20          VADD.F32 s0,s0,s1
00026a  ed800a03          VSTR     s0,[r0,#0xc]
                  |L4.622|
;;;93     		 
;;;94     		if(GMPitchEncoder.ecd_angle >= PITCH_MECHANICAL_TOP && angle->pitch_differ < 0.0f)
00026e  4921              LDR      r1,|L4.756|
000270  ed910a11          VLDR     s0,[r1,#0x44]
000274  eddf0a21          VLDR     s1,|L4.764|
000278  eeb40ae0          VCMPE.F32 s0,s1
00027c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000280  db0e              BLT      |L4.672|
000282  ed900a0b          VLDR     s0,[r0,#0x2c]
000286  eeb50ac0          VCMPE.F32 s0,#0.0
00028a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00028e  d207              BCS      |L4.672|
;;;95     			angle->pitch_set +=  (angle->pitch_differ);
000290  ed900a03          VLDR     s0,[r0,#0xc]
000294  edd00a0b          VLDR     s1,[r0,#0x2c]
000298  ee300a20          VADD.F32 s0,s0,s1
00029c  ed800a03          VSTR     s0,[r0,#0xc]
                  |L4.672|
;;;96     
;;;97     		if(GMPitchEncoder.ecd_angle > PITCH_MECHANICAL_LOW && GMPitchEncoder.ecd_angle < PITCH_MECHANICAL_TOP)
0002a0  4914              LDR      r1,|L4.756|
0002a2  ed910a11          VLDR     s0,[r1,#0x44]
0002a6  eddf0a14          VLDR     s1,|L4.760|
0002aa  eeb40ae0          VCMPE.F32 s0,s1
0002ae  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002b2  dd10              BLE      |L4.726|
0002b4  ed910a11          VLDR     s0,[r1,#0x44]
0002b8  eddf0a10          VLDR     s1,|L4.764|
0002bc  eeb40ae0          VCMPE.F32 s0,s1
0002c0  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002c4  d207              BCS      |L4.726|
;;;98     			angle->pitch_set +=  angle->pitch_differ;	 
0002c6  ed900a03          VLDR     s0,[r0,#0xc]
0002ca  edd00a0b          VLDR     s1,[r0,#0x2c]
0002ce  ee300a20          VADD.F32 s0,s0,s1
0002d2  ed800a03          VSTR     s0,[r0,#0xc]
                  |L4.726|
;;;99     	}
;;;100    
;;;101    }
0002d6  4770              BX       lr
;;;102    //云台电机更新输出电流值
                          ENDP

                  |L4.728|
0002d8  3c23d70a          DCFS     0x3c23d70a ; 0.0099999997764825821
                  |L4.732|
                          DCD      ||rc||
                  |L4.736|
0002e0  453b8000          DCFS     0x453b8000 ; 3000
                  |L4.740|
0002e4  43960000          DCFS     0x43960000 ; 300
                  |L4.744|
                          DCD      out
                  |L4.748|
0002ec  457a0000          DCFS     0x457a0000 ; 4000
                  |L4.752|
0002f0  43c80000          DCFS     0x43c80000 ; 400
                  |L4.756|
                          DCD      GMPitchEncoder
                  |L4.760|
0002f8  c2d60000          DCFS     0xc2d60000 ; -107
                  |L4.764|
0002fc  c2bc0000          DCFS     0xc2bc0000 ; -94

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  t_angle
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  fly_flag
                          DCD      0x00000000
                  differ_set
000004  00000000          DCFS     0x00000000 ; 0
                  last_set
000008  00000000          DCFS     0x00000000 ; 0
                  new_set
00000c  00000000          DCFS     0x00000000 ; 0
                  fly_times
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\HAL\\cloudmotor.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_cloudmotor_c_t_angle____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___12_cloudmotor_c_t_angle____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_cloudmotor_c_t_angle____REVSH|
#line 153
|__asm___12_cloudmotor_c_t_angle____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_cloudmotor_c_t_angle____RRX|
#line 328
|__asm___12_cloudmotor_c_t_angle____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
