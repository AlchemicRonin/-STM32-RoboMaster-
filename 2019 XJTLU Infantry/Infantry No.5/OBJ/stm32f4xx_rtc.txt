; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_rtc.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_rtc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_rtc.crf ..\FWLIB\src\stm32f4xx_rtc.c]
                          THUMB

                          AREA ||i.RTC_AlarmCmd||, CODE, READONLY, ALIGN=2

                  RTC_AlarmCmd PROC
;;;1309     */
;;;1310   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
000000  b538              PUSH     {r3-r5,lr}
;;;1311   {
000002  4602              MOV      r2,r0
;;;1312     __IO uint32_t alarmcounter = 0x00;
000004  2400              MOVS     r4,#0
000006  9400              STR      r4,[sp,#0]
;;;1313     uint32_t alarmstatus = 0x00;
000008  2300              MOVS     r3,#0
;;;1314     ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;1315       
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;1318     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1319   
;;;1320     /* Disable the write protection for RTC registers */
;;;1321     RTC->WPR = 0xCA;
00000c  24ca              MOVS     r4,#0xca
00000e  4d18              LDR      r5,|L1.112|
000010  602c              STR      r4,[r5,#0]
;;;1322     RTC->WPR = 0x53;
000012  2453              MOVS     r4,#0x53
000014  602c              STR      r4,[r5,#0]
;;;1323   
;;;1324     /* Configure the Alarm state */
;;;1325     if (NewState != DISABLE)
000016  b141              CBZ      r1,|L1.42|
;;;1326     {
;;;1327       RTC->CR |= (uint32_t)RTC_Alarm;
000018  4c15              LDR      r4,|L1.112|
00001a  3c1c              SUBS     r4,r4,#0x1c
00001c  6824              LDR      r4,[r4,#0]
00001e  4314              ORRS     r4,r4,r2
000020  4d13              LDR      r5,|L1.112|
000022  3d1c              SUBS     r5,r5,#0x1c
000024  602c              STR      r4,[r5,#0]
;;;1328   
;;;1329       status = SUCCESS;    
000026  2001              MOVS     r0,#1
000028  e01e              B        |L1.104|
                  |L1.42|
;;;1330     }
;;;1331     else
;;;1332     { 
;;;1333       /* Disable the Alarm in RTC_CR register */
;;;1334       RTC->CR &= (uint32_t)~RTC_Alarm;
00002a  4c11              LDR      r4,|L1.112|
00002c  3c1c              SUBS     r4,r4,#0x1c
00002e  6824              LDR      r4,[r4,#0]
000030  4394              BICS     r4,r4,r2
000032  4d0f              LDR      r5,|L1.112|
000034  3d1c              SUBS     r5,r5,#0x1c
000036  602c              STR      r4,[r5,#0]
;;;1335      
;;;1336       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1337       do
000038  bf00              NOP      
                  |L1.58|
;;;1338       {
;;;1339         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
00003a  4c0d              LDR      r4,|L1.112|
00003c  3c18              SUBS     r4,r4,#0x18
00003e  6824              LDR      r4,[r4,#0]
000040  ea042312          AND      r3,r4,r2,LSR #8
;;;1340         alarmcounter++;  
000044  9c00              LDR      r4,[sp,#0]
000046  1c64              ADDS     r4,r4,#1
000048  9400              STR      r4,[sp,#0]
;;;1341       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
00004a  9c00              LDR      r4,[sp,#0]
00004c  f5b43f80          CMP      r4,#0x10000
000050  d001              BEQ      |L1.86|
000052  2b00              CMP      r3,#0
000054  d0f1              BEQ      |L1.58|
                  |L1.86|
;;;1342       
;;;1343       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
000056  4c06              LDR      r4,|L1.112|
000058  3c18              SUBS     r4,r4,#0x18
00005a  6824              LDR      r4,[r4,#0]
00005c  ea042412          AND      r4,r4,r2,LSR #8
000060  b90c              CBNZ     r4,|L1.102|
;;;1344       {
;;;1345         status = ERROR;
000062  2000              MOVS     r0,#0
000064  e000              B        |L1.104|
                  |L1.102|
;;;1346       } 
;;;1347       else
;;;1348       {
;;;1349         status = SUCCESS;
000066  2001              MOVS     r0,#1
                  |L1.104|
;;;1350       }        
;;;1351     } 
;;;1352   
;;;1353     /* Enable the write protection for RTC registers */
;;;1354     RTC->WPR = 0xFF; 
000068  24ff              MOVS     r4,#0xff
00006a  4d01              LDR      r5,|L1.112|
00006c  602c              STR      r4,[r5,#0]
;;;1355     
;;;1356     return status;
;;;1357   }
00006e  bd38              POP      {r3-r5,pc}
;;;1358   
                          ENDP

                  |L1.112|
                          DCD      0x40002824

                          AREA ||i.RTC_AlarmStructInit||, CODE, READONLY, ALIGN=1

                  RTC_AlarmStructInit PROC
;;;1225     */
;;;1226   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  2100              MOVS     r1,#0
;;;1227   {
;;;1228     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1229     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;1230     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;1231     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;1232     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
000008  7081              STRB     r1,[r0,#2]
;;;1233   
;;;1234     /* Alarm Date Settings : Date = 1st day of the month */
;;;1235     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
00000a  6081              STR      r1,[r0,#8]
;;;1236     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
00000c  2101              MOVS     r1,#1
00000e  7301              STRB     r1,[r0,#0xc]
;;;1237   
;;;1238     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1239     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000010  2100              MOVS     r1,#0
000012  6041              STR      r1,[r0,#4]
;;;1240   }
000014  4770              BX       lr
;;;1241   
                          ENDP


                          AREA ||i.RTC_AlarmSubSecondConfig||, CODE, READONLY, ALIGN=2

                  RTC_AlarmSubSecondConfig PROC
;;;1403     */
;;;1404   void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
000000  b530              PUSH     {r4,r5,lr}
;;;1405   {
;;;1406     uint32_t tmpreg = 0;
000002  2300              MOVS     r3,#0
;;;1407   
;;;1408     /* Check the parameters */
;;;1409     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1410     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
;;;1411     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
;;;1412     
;;;1413     /* Disable the write protection for RTC registers */
;;;1414     RTC->WPR = 0xCA;
000004  24ca              MOVS     r4,#0xca
000006  4d0a              LDR      r5,|L3.48|
000008  602c              STR      r4,[r5,#0]
;;;1415     RTC->WPR = 0x53;
00000a  2453              MOVS     r4,#0x53
00000c  602c              STR      r4,[r5,#0]
;;;1416     
;;;1417     /* Configure the Alarm A or Alarm B Sub Second registers */
;;;1418     tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
00000e  ea410302          ORR      r3,r1,r2
;;;1419     
;;;1420     if (RTC_Alarm == RTC_Alarm_A)
000012  f5b07f80          CMP      r0,#0x100
000016  d103              BNE      |L3.32|
;;;1421     {
;;;1422       /* Configure the Alarm A Sub Second register */
;;;1423       RTC->ALRMASSR = tmpreg;
000018  4c05              LDR      r4,|L3.48|
00001a  3420              ADDS     r4,r4,#0x20
00001c  6023              STR      r3,[r4,#0]
00001e  e002              B        |L3.38|
                  |L3.32|
;;;1424     }
;;;1425     else
;;;1426     {
;;;1427       /* Configure the Alarm B Sub Second register */
;;;1428       RTC->ALRMBSSR = tmpreg;
000020  4c03              LDR      r4,|L3.48|
000022  3424              ADDS     r4,r4,#0x24
000024  6023              STR      r3,[r4,#0]
                  |L3.38|
;;;1429     }
;;;1430   
;;;1431     /* Enable the write protection for RTC registers */
;;;1432     RTC->WPR = 0xFF;
000026  24ff              MOVS     r4,#0xff
000028  4d01              LDR      r5,|L3.48|
00002a  602c              STR      r4,[r5,#0]
;;;1433   
;;;1434   }
00002c  bd30              POP      {r4,r5,pc}
;;;1435   
                          ENDP

00002e  0000              DCW      0x0000
                  |L3.48|
                          DCD      0x40002824

                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;2745     */
;;;2746   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  4601              MOV      r1,r0
;;;2747   {
;;;2748     uint8_t tmp = 0;
000002  bf00              NOP      
;;;2749     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000004  0908              LSRS     r0,r1,#4
000006  eb000080          ADD      r0,r0,r0,LSL #2
00000a  0042              LSLS     r2,r0,#1
;;;2750     return (tmp + (Value & (uint8_t)0x0F));
00000c  f001000f          AND      r0,r1,#0xf
000010  4410              ADD      r0,r0,r2
000012  b2c0              UXTB     r0,r0
;;;2751   }
000014  4770              BX       lr
;;;2752   
                          ENDP


                          AREA ||i.RTC_BypassShadowCmd||, CODE, READONLY, ALIGN=2

                  RTC_BypassShadowCmd PROC
;;;709    */
;;;710    void RTC_BypassShadowCmd(FunctionalState NewState)
000000  21ca              MOVS     r1,#0xca
;;;711    {
;;;712      /* Check the parameters */
;;;713      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;714    
;;;715      /* Disable the write protection for RTC registers */
;;;716      RTC->WPR = 0xCA;
000002  4a0d              LDR      r2,|L5.56|
000004  6011              STR      r1,[r2,#0]
;;;717      RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;718      
;;;719      if (NewState != DISABLE)
00000a  b140              CBZ      r0,|L5.30|
;;;720      {
;;;721        /* Set the BYPSHAD bit */
;;;722        RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
00000c  490a              LDR      r1,|L5.56|
00000e  391c              SUBS     r1,r1,#0x1c
000010  6809              LDR      r1,[r1,#0]
000012  f0410120          ORR      r1,r1,#0x20
000016  4a08              LDR      r2,|L5.56|
000018  3a1c              SUBS     r2,r2,#0x1c
00001a  6011              STR      r1,[r2,#0]
00001c  e007              B        |L5.46|
                  |L5.30|
;;;723      }
;;;724      else
;;;725      {
;;;726        /* Reset the BYPSHAD bit */
;;;727        RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
00001e  4906              LDR      r1,|L5.56|
000020  391c              SUBS     r1,r1,#0x1c
000022  6809              LDR      r1,[r1,#0]
000024  f00101df          AND      r1,r1,#0xdf
000028  4a03              LDR      r2,|L5.56|
00002a  3a1c              SUBS     r2,r2,#0x1c
00002c  6011              STR      r1,[r2,#0]
                  |L5.46|
;;;728      }
;;;729    
;;;730      /* Enable the write protection for RTC registers */
;;;731      RTC->WPR = 0xFF;
00002e  21ff              MOVS     r1,#0xff
000030  4a01              LDR      r2,|L5.56|
000032  6011              STR      r1,[r2,#0]
;;;732    }
000034  4770              BX       lr
;;;733    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40002824

                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;2727     */
;;;2728   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  4601              MOV      r1,r0
;;;2729   {
;;;2730     uint8_t bcdhigh = 0;
000002  2200              MOVS     r2,#0
;;;2731     
;;;2732     while (Value >= 10)
000004  e004              B        |L6.16|
                  |L6.6|
;;;2733     {
;;;2734       bcdhigh++;
000006  1c50              ADDS     r0,r2,#1
000008  b2c2              UXTB     r2,r0
;;;2735       Value -= 10;
00000a  f1a1000a          SUB      r0,r1,#0xa
00000e  b2c1              UXTB     r1,r0
                  |L6.16|
000010  290a              CMP      r1,#0xa               ;2732
000012  daf8              BGE      |L6.6|
;;;2736     }
;;;2737     
;;;2738     return  ((uint8_t)(bcdhigh << 4) | Value);
000014  0710              LSLS     r0,r2,#28
000016  ea416010          ORR      r0,r1,r0,LSR #24
;;;2739   }
00001a  4770              BX       lr
;;;2740   
                          ENDP


                          AREA ||i.RTC_CalibOutputCmd||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputCmd PROC
;;;1837     */
;;;1838   void RTC_CalibOutputCmd(FunctionalState NewState)
000000  21ca              MOVS     r1,#0xca
;;;1839   {
;;;1840     /* Check the parameters */
;;;1841     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1842     
;;;1843     /* Disable the write protection for RTC registers */
;;;1844     RTC->WPR = 0xCA;
000002  4a0d              LDR      r2,|L7.56|
000004  6011              STR      r1,[r2,#0]
;;;1845     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1846     
;;;1847     if (NewState != DISABLE)
00000a  b140              CBZ      r0,|L7.30|
;;;1848     {
;;;1849       /* Enable the RTC clock output */
;;;1850       RTC->CR |= (uint32_t)RTC_CR_COE;
00000c  490a              LDR      r1,|L7.56|
00000e  391c              SUBS     r1,r1,#0x1c
000010  6809              LDR      r1,[r1,#0]
000012  f4410100          ORR      r1,r1,#0x800000
000016  4a08              LDR      r2,|L7.56|
000018  3a1c              SUBS     r2,r2,#0x1c
00001a  6011              STR      r1,[r2,#0]
00001c  e007              B        |L7.46|
                  |L7.30|
;;;1851     }
;;;1852     else
;;;1853     { 
;;;1854       /* Disable the RTC clock output */
;;;1855       RTC->CR &= (uint32_t)~RTC_CR_COE;
00001e  4906              LDR      r1,|L7.56|
000020  391c              SUBS     r1,r1,#0x1c
000022  6809              LDR      r1,[r1,#0]
000024  f4210100          BIC      r1,r1,#0x800000
000028  4a03              LDR      r2,|L7.56|
00002a  3a1c              SUBS     r2,r2,#0x1c
00002c  6011              STR      r1,[r2,#0]
                  |L7.46|
;;;1856     }
;;;1857     
;;;1858     /* Enable the write protection for RTC registers */
;;;1859     RTC->WPR = 0xFF; 
00002e  21ff              MOVS     r1,#0xff
000030  4a01              LDR      r2,|L7.56|
000032  6011              STR      r1,[r2,#0]
;;;1860   }
000034  4770              BX       lr
;;;1861   
                          ENDP

000036  0000              DCW      0x0000
                  |L7.56|
                          DCD      0x40002824

                          AREA ||i.RTC_CalibOutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputConfig PROC
;;;1869   */
;;;1870   void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
000000  21ca              MOVS     r1,#0xca
;;;1871   {
;;;1872     /* Check the parameters */
;;;1873     assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
;;;1874   
;;;1875     /* Disable the write protection for RTC registers */
;;;1876     RTC->WPR = 0xCA;
000002  4a0a              LDR      r2,|L8.44|
000004  6011              STR      r1,[r2,#0]
;;;1877     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1878     
;;;1879     /*clear flags before configuration */
;;;1880     RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
00000a  4908              LDR      r1,|L8.44|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  6809              LDR      r1,[r1,#0]
000010  f4212100          BIC      r1,r1,#0x80000
000014  4a05              LDR      r2,|L8.44|
000016  3a1c              SUBS     r2,r2,#0x1c
000018  6011              STR      r1,[r2,#0]
;;;1881   
;;;1882     /* Configure the RTC_CR register */
;;;1883     RTC->CR |= (uint32_t)RTC_CalibOutput;
00001a  4611              MOV      r1,r2
00001c  6809              LDR      r1,[r1,#0]
00001e  4301              ORRS     r1,r1,r0
000020  6011              STR      r1,[r2,#0]
;;;1884   
;;;1885     /* Enable the write protection for RTC registers */
;;;1886     RTC->WPR = 0xFF;
000022  21ff              MOVS     r1,#0xff
000024  4a01              LDR      r2,|L8.44|
000026  6011              STR      r1,[r2,#0]
;;;1887   }
000028  4770              BX       lr
;;;1888   
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40002824

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;2642     */
;;;2643   void RTC_ClearFlag(uint32_t RTC_FLAG)
000000  b281              UXTH     r1,r0
;;;2644   {
;;;2645     /* Check the parameters */
;;;2646     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;2647   
;;;2648     /* Clear the Flags in the RTC_ISR register */
;;;2649     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
000002  f0410180          ORR      r1,r1,#0x80
000006  4a04              LDR      r2,|L9.24|
000008  6812              LDR      r2,[r2,#0]
00000a  f0020280          AND      r2,r2,#0x80
00000e  ea620101          ORN      r1,r2,r1
000012  4a01              LDR      r2,|L9.24|
000014  6011              STR      r1,[r2,#0]
;;;2650   }
000016  4770              BX       lr
;;;2651   
                          ENDP

                  |L9.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;2704     */
;;;2705   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000000  2100              MOVS     r1,#0
;;;2706   {
;;;2707     uint32_t tmpreg = 0;
;;;2708   
;;;2709     /* Check the parameters */
;;;2710     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;2711   
;;;2712     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2713     tmpreg = (uint32_t)(RTC_IT >> 4);
000002  0901              LSRS     r1,r0,#4
;;;2714   
;;;2715     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2716     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000004  b28a              UXTH     r2,r1
000006  f0420280          ORR      r2,r2,#0x80
00000a  4b04              LDR      r3,|L10.28|
00000c  681b              LDR      r3,[r3,#0]
00000e  f0030380          AND      r3,r3,#0x80
000012  ea630202          ORN      r2,r3,r2
000016  4b01              LDR      r3,|L10.28|
000018  601a              STR      r2,[r3,#0]
;;;2717   }
00001a  4770              BX       lr
;;;2718   
                          ENDP

                  |L10.28|
                          DCD      0x4000280c

                          AREA ||i.RTC_CoarseCalibCmd||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibCmd PROC
;;;1791     */
;;;1792   ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1793   {
000002  4604              MOV      r4,r0
;;;1794     ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;1795     
;;;1796     /* Check the parameters */
;;;1797     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1798   
;;;1799     /* Disable the write protection for RTC registers */
;;;1800     RTC->WPR = 0xCA;
000006  20ca              MOVS     r0,#0xca
000008  4910              LDR      r1,|L11.76|
00000a  6008              STR      r0,[r1,#0]
;;;1801     RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6008              STR      r0,[r1,#0]
;;;1802     
;;;1803     /* Set Initialization mode */
;;;1804     if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b900              CBNZ     r0,|L11.24|
;;;1805     {
;;;1806       status =  ERROR;
000016  e014              B        |L11.66|
                  |L11.24|
;;;1807     }
;;;1808     else
;;;1809     {
;;;1810       if (NewState != DISABLE)
000018  b144              CBZ      r4,|L11.44|
;;;1811       {
;;;1812         /* Enable the Coarse Calibration */
;;;1813         RTC->CR |= (uint32_t)RTC_CR_DCE;
00001a  480c              LDR      r0,|L11.76|
00001c  381c              SUBS     r0,r0,#0x1c
00001e  6800              LDR      r0,[r0,#0]
000020  f0400080          ORR      r0,r0,#0x80
000024  4909              LDR      r1,|L11.76|
000026  391c              SUBS     r1,r1,#0x1c
000028  6008              STR      r0,[r1,#0]
00002a  e007              B        |L11.60|
                  |L11.44|
;;;1814       }
;;;1815       else
;;;1816       { 
;;;1817         /* Disable the Coarse Calibration */
;;;1818         RTC->CR &= (uint32_t)~RTC_CR_DCE;
00002c  4807              LDR      r0,|L11.76|
00002e  381c              SUBS     r0,r0,#0x1c
000030  6800              LDR      r0,[r0,#0]
000032  f0200080          BIC      r0,r0,#0x80
000036  4905              LDR      r1,|L11.76|
000038  391c              SUBS     r1,r1,#0x1c
00003a  6008              STR      r0,[r1,#0]
                  |L11.60|
;;;1819       }
;;;1820       /* Exit Initialization mode */
;;;1821       RTC_ExitInitMode();
00003c  f7fffffe          BL       RTC_ExitInitMode
;;;1822       
;;;1823       status = SUCCESS;
000040  2501              MOVS     r5,#1
                  |L11.66|
;;;1824     } 
;;;1825     
;;;1826     /* Enable the write protection for RTC registers */
;;;1827     RTC->WPR = 0xFF; 
000042  20ff              MOVS     r0,#0xff
000044  4901              LDR      r1,|L11.76|
000046  6008              STR      r0,[r1,#0]
;;;1828     
;;;1829     return status;
000048  4628              MOV      r0,r5
;;;1830   }
00004a  bd30              POP      {r4,r5,pc}
;;;1831   
                          ENDP

                  |L11.76|
                          DCD      0x40002824

                          AREA ||i.RTC_CoarseCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibConfig PROC
;;;1750     */
;;;1751   ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
000000  b570              PUSH     {r4-r6,lr}
;;;1752   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1753     ErrorStatus status = ERROR;
000006  2600              MOVS     r6,#0
;;;1754      
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
;;;1757     assert_param(IS_RTC_CALIB_VALUE(Value)); 
;;;1758   
;;;1759     /* Disable the write protection for RTC registers */
;;;1760     RTC->WPR = 0xCA;
000008  20ca              MOVS     r0,#0xca
00000a  490a              LDR      r1,|L12.52|
00000c  6008              STR      r0,[r1,#0]
;;;1761     RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6008              STR      r0,[r1,#0]
;;;1762   
;;;1763     /* Set Initialization mode */
;;;1764     if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b900              CBNZ     r0,|L12.26|
;;;1765     {
;;;1766       status = ERROR;
000018  e007              B        |L12.42|
                  |L12.26|
;;;1767     } 
;;;1768     else
;;;1769     {
;;;1770       /* Set the coarse calibration value */
;;;1771       RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
00001a  ea440005          ORR      r0,r4,r5
00001e  4905              LDR      r1,|L12.52|
000020  390c              SUBS     r1,r1,#0xc
000022  6008              STR      r0,[r1,#0]
;;;1772       /* Exit Initialization mode */
;;;1773       RTC_ExitInitMode();
000024  f7fffffe          BL       RTC_ExitInitMode
;;;1774       
;;;1775       status = SUCCESS;
000028  2601              MOVS     r6,#1
                  |L12.42|
;;;1776     } 
;;;1777   
;;;1778     /* Enable the write protection for RTC registers */
;;;1779     RTC->WPR = 0xFF; 
00002a  20ff              MOVS     r0,#0xff
00002c  4901              LDR      r1,|L12.52|
00002e  6008              STR      r0,[r1,#0]
;;;1780     
;;;1781     return status;
000030  4630              MOV      r0,r6
;;;1782   }
000032  bd70              POP      {r4-r6,pc}
;;;1783   
                          ENDP

                  |L12.52|
                          DCD      0x40002824

                          AREA ||i.RTC_DateStructInit||, CODE, READONLY, ALIGN=1

                  RTC_DateStructInit PROC
;;;1035     */
;;;1036   void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000000  2101              MOVS     r1,#1
;;;1037   {
;;;1038     /* Monday, January 01 xx00 */
;;;1039     RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000002  7001              STRB     r1,[r0,#0]
;;;1040     RTC_DateStruct->RTC_Date = 1;
000004  7081              STRB     r1,[r0,#2]
;;;1041     RTC_DateStruct->RTC_Month = RTC_Month_January;
000006  7041              STRB     r1,[r0,#1]
;;;1042     RTC_DateStruct->RTC_Year = 0;
000008  2100              MOVS     r1,#0
00000a  70c1              STRB     r1,[r0,#3]
;;;1043   }
00000c  4770              BX       lr
;;;1044   
                          ENDP


                          AREA ||i.RTC_DayLightSavingConfig||, CODE, READONLY, ALIGN=2

                  RTC_DayLightSavingConfig PROC
;;;1630     */
;;;1631   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000000  22ca              MOVS     r2,#0xca
;;;1632   {
;;;1633     /* Check the parameters */
;;;1634     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1635     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1636   
;;;1637     /* Disable the write protection for RTC registers */
;;;1638     RTC->WPR = 0xCA;
000002  4b0c              LDR      r3,|L14.52|
000004  601a              STR      r2,[r3,#0]
;;;1639     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  601a              STR      r2,[r3,#0]
;;;1640   
;;;1641     /* Clear the bits to be configured */
;;;1642     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
00000a  4a0a              LDR      r2,|L14.52|
00000c  3a1c              SUBS     r2,r2,#0x1c
00000e  6812              LDR      r2,[r2,#0]
000010  f4222280          BIC      r2,r2,#0x40000
000014  4b07              LDR      r3,|L14.52|
000016  3b1c              SUBS     r3,r3,#0x1c
000018  601a              STR      r2,[r3,#0]
;;;1643   
;;;1644     /* Configure the RTC_CR register */
;;;1645     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
00001a  461a              MOV      r2,r3
00001c  6812              LDR      r2,[r2,#0]
00001e  ea400301          ORR      r3,r0,r1
000022  431a              ORRS     r2,r2,r3
000024  4b03              LDR      r3,|L14.52|
000026  3b1c              SUBS     r3,r3,#0x1c
000028  601a              STR      r2,[r3,#0]
;;;1646   
;;;1647     /* Enable the write protection for RTC registers */
;;;1648     RTC->WPR = 0xFF; 
00002a  22ff              MOVS     r2,#0xff
00002c  4b01              LDR      r3,|L14.52|
00002e  601a              STR      r2,[r3,#0]
;;;1649   }
000030  4770              BX       lr
;;;1650   
                          ENDP

000032  0000              DCW      0x0000
                  |L14.52|
                          DCD      0x40002824

                          AREA ||i.RTC_DeInit||, CODE, READONLY, ALIGN=2

                  RTC_DeInit PROC
;;;374      */
;;;375    ErrorStatus RTC_DeInit(void)
000000  b538              PUSH     {r3-r5,lr}
;;;376    {
;;;377      __IO uint32_t wutcounter = 0x00;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;378      uint32_t wutwfstatus = 0x00;
000006  2400              MOVS     r4,#0
;;;379      ErrorStatus status = ERROR;
000008  2500              MOVS     r5,#0
;;;380      
;;;381      /* Disable the write protection for RTC registers */
;;;382      RTC->WPR = 0xCA;
00000a  20ca              MOVS     r0,#0xca
00000c  492f              LDR      r1,|L15.204|
00000e  6008              STR      r0,[r1,#0]
;;;383      RTC->WPR = 0x53;
000010  2053              MOVS     r0,#0x53
000012  6008              STR      r0,[r1,#0]
;;;384    
;;;385      /* Set Initialization mode */
;;;386      if (RTC_EnterInitMode() == ERROR)
000014  f7fffffe          BL       RTC_EnterInitMode
000018  b900              CBNZ     r0,|L15.28|
;;;387      {
;;;388        status = ERROR;
00001a  e052              B        |L15.194|
                  |L15.28|
;;;389      }  
;;;390      else
;;;391      {
;;;392        /* Reset TR, DR and CR registers */
;;;393        RTC->TR = (uint32_t)0x00000000;
00001c  2000              MOVS     r0,#0
00001e  492b              LDR      r1,|L15.204|
000020  3924              SUBS     r1,r1,#0x24
000022  6008              STR      r0,[r1,#0]
;;;394        RTC->DR = (uint32_t)0x00002101;
000024  f2421001          MOV      r0,#0x2101
000028  1d09              ADDS     r1,r1,#4
00002a  6008              STR      r0,[r1,#0]
;;;395        /* Reset All CR bits except CR[2:0] */
;;;396        RTC->CR &= (uint32_t)0x00000007;
00002c  1d08              ADDS     r0,r1,#4
00002e  6800              LDR      r0,[r0,#0]
000030  f0000007          AND      r0,r0,#7
000034  1d09              ADDS     r1,r1,#4
000036  6008              STR      r0,[r1,#0]
;;;397      
;;;398        /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;399        do
000038  bf00              NOP      
                  |L15.58|
;;;400        {
;;;401          wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
00003a  4824              LDR      r0,|L15.204|
00003c  3818              SUBS     r0,r0,#0x18
00003e  6800              LDR      r0,[r0,#0]
000040  f0000404          AND      r4,r0,#4
;;;402          wutcounter++;  
000044  9800              LDR      r0,[sp,#0]
000046  1c40              ADDS     r0,r0,#1
000048  9000              STR      r0,[sp,#0]
;;;403        } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
00004a  9800              LDR      r0,[sp,#0]
00004c  f5b03f80          CMP      r0,#0x10000
000050  d001              BEQ      |L15.86|
000052  2c00              CMP      r4,#0
000054  d0f1              BEQ      |L15.58|
                  |L15.86|
;;;404        
;;;405        if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000056  481d              LDR      r0,|L15.204|
000058  3818              SUBS     r0,r0,#0x18
00005a  6800              LDR      r0,[r0,#0]
00005c  f0000004          AND      r0,r0,#4
000060  b908              CBNZ     r0,|L15.102|
;;;406        {
;;;407          status = ERROR;
000062  2500              MOVS     r5,#0
000064  e02d              B        |L15.194|
                  |L15.102|
;;;408        }
;;;409        else
;;;410        {
;;;411          /* Reset all RTC CR register bits */
;;;412          RTC->CR &= (uint32_t)0x00000000;
000066  4819              LDR      r0,|L15.204|
000068  381c              SUBS     r0,r0,#0x1c
00006a  6800              LDR      r0,[r0,#0]
00006c  2000              MOVS     r0,#0
00006e  4917              LDR      r1,|L15.204|
000070  391c              SUBS     r1,r1,#0x1c
000072  6008              STR      r0,[r1,#0]
;;;413          RTC->WUTR = (uint32_t)0x0000FFFF;
000074  f64f70ff          MOV      r0,#0xffff
000078  4914              LDR      r1,|L15.204|
00007a  3910              SUBS     r1,r1,#0x10
00007c  6008              STR      r0,[r1,#0]
;;;414          RTC->PRER = (uint32_t)0x007F00FF;
00007e  4814              LDR      r0,|L15.208|
000080  1f09              SUBS     r1,r1,#4
000082  6008              STR      r0,[r1,#0]
;;;415          RTC->CALIBR = (uint32_t)0x00000000;
000084  2000              MOVS     r0,#0
000086  4911              LDR      r1,|L15.204|
000088  390c              SUBS     r1,r1,#0xc
00008a  6008              STR      r0,[r1,#0]
;;;416          RTC->ALRMAR = (uint32_t)0x00000000;        
00008c  1d09              ADDS     r1,r1,#4
00008e  6008              STR      r0,[r1,#0]
;;;417          RTC->ALRMBR = (uint32_t)0x00000000;
000090  1d09              ADDS     r1,r1,#4
000092  6008              STR      r0,[r1,#0]
;;;418          RTC->SHIFTR = (uint32_t)0x00000000;
000094  490d              LDR      r1,|L15.204|
000096  3108              ADDS     r1,r1,#8
000098  6008              STR      r0,[r1,#0]
;;;419          RTC->CALR = (uint32_t)0x00000000;
00009a  490c              LDR      r1,|L15.204|
00009c  3118              ADDS     r1,r1,#0x18
00009e  6008              STR      r0,[r1,#0]
;;;420          RTC->ALRMASSR = (uint32_t)0x00000000;
0000a0  490a              LDR      r1,|L15.204|
0000a2  3120              ADDS     r1,r1,#0x20
0000a4  6008              STR      r0,[r1,#0]
;;;421          RTC->ALRMBSSR = (uint32_t)0x00000000;
0000a6  1d09              ADDS     r1,r1,#4
0000a8  6008              STR      r0,[r1,#0]
;;;422          
;;;423          /* Reset ISR register and exit initialization mode */
;;;424          RTC->ISR = (uint32_t)0x00000000;
0000aa  4908              LDR      r1,|L15.204|
0000ac  3918              SUBS     r1,r1,#0x18
0000ae  6008              STR      r0,[r1,#0]
;;;425          
;;;426          /* Reset Tamper and alternate functions configuration register */
;;;427          RTC->TAFCR = 0x00000000;
0000b0  4906              LDR      r1,|L15.204|
0000b2  311c              ADDS     r1,r1,#0x1c
0000b4  6008              STR      r0,[r1,#0]
;;;428      
;;;429          if(RTC_WaitForSynchro() == ERROR)
0000b6  f7fffffe          BL       RTC_WaitForSynchro
0000ba  b908              CBNZ     r0,|L15.192|
;;;430          {
;;;431            status = ERROR;
0000bc  2500              MOVS     r5,#0
0000be  e000              B        |L15.194|
                  |L15.192|
;;;432          }
;;;433          else
;;;434          {
;;;435            status = SUCCESS;      
0000c0  2501              MOVS     r5,#1
                  |L15.194|
;;;436          }
;;;437        }
;;;438      }
;;;439      
;;;440      /* Enable the write protection for RTC registers */
;;;441      RTC->WPR = 0xFF;  
0000c2  20ff              MOVS     r0,#0xff
0000c4  4901              LDR      r1,|L15.204|
0000c6  6008              STR      r0,[r1,#0]
;;;442      
;;;443      return status;
0000c8  4628              MOV      r0,r5
;;;444    }
0000ca  bd38              POP      {r3-r5,pc}
;;;445    
                          ENDP

                  |L15.204|
                          DCD      0x40002824
                  |L15.208|
                          DCD      0x007f00ff

                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterInitMode PROC
;;;551      */
;;;552    ErrorStatus RTC_EnterInitMode(void)
000000  b508              PUSH     {r3,lr}
;;;553    {
;;;554      __IO uint32_t initcounter = 0x00;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;555      ErrorStatus status = ERROR;
000006  2000              MOVS     r0,#0
;;;556      uint32_t initstatus = 0x00;
000008  2100              MOVS     r1,#0
;;;557         
;;;558      /* Check if the Initialization mode is set */
;;;559      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
00000a  4a10              LDR      r2,|L16.76|
00000c  6812              LDR      r2,[r2,#0]
00000e  f0020240          AND      r2,r2,#0x40
000012  b9ca              CBNZ     r2,|L16.72|
;;;560      {
;;;561        /* Set the Initialization mode */
;;;562        RTC->ISR = (uint32_t)RTC_INIT_MASK;
000014  1e42              SUBS     r2,r0,#1
000016  4b0d              LDR      r3,|L16.76|
000018  601a              STR      r2,[r3,#0]
;;;563        
;;;564        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;565        do
00001a  bf00              NOP      
                  |L16.28|
;;;566        {
;;;567          initstatus = RTC->ISR & RTC_ISR_INITF;
00001c  4a0b              LDR      r2,|L16.76|
00001e  6812              LDR      r2,[r2,#0]
000020  f0020140          AND      r1,r2,#0x40
;;;568          initcounter++;  
000024  9a00              LDR      r2,[sp,#0]
000026  1c52              ADDS     r2,r2,#1
000028  9200              STR      r2,[sp,#0]
;;;569        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
00002a  9a00              LDR      r2,[sp,#0]
00002c  f5b23f80          CMP      r2,#0x10000
000030  d001              BEQ      |L16.54|
000032  2900              CMP      r1,#0
000034  d0f2              BEQ      |L16.28|
                  |L16.54|
;;;570        
;;;571        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
000036  4a05              LDR      r2,|L16.76|
000038  6812              LDR      r2,[r2,#0]
00003a  f0020240          AND      r2,r2,#0x40
00003e  b10a              CBZ      r2,|L16.68|
;;;572        {
;;;573          status = SUCCESS;
000040  2001              MOVS     r0,#1
000042  e002              B        |L16.74|
                  |L16.68|
;;;574        }
;;;575        else
;;;576        {
;;;577          status = ERROR;
000044  2000              MOVS     r0,#0
000046  e000              B        |L16.74|
                  |L16.72|
;;;578        }        
;;;579      }
;;;580      else
;;;581      {
;;;582        status = SUCCESS;  
000048  2001              MOVS     r0,#1
                  |L16.74|
;;;583      } 
;;;584        
;;;585      return (status);  
;;;586    }
00004a  bd08              POP      {r3,pc}
;;;587    
                          ENDP

                  |L16.76|
                          DCD      0x4000280c

                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;596      */
;;;597    void RTC_ExitInitMode(void)
000000  4803              LDR      r0,|L17.16|
;;;598    { 
;;;599      /* Exit Initialization mode */
;;;600      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
000002  6800              LDR      r0,[r0,#0]
000004  f0200080          BIC      r0,r0,#0x80
000008  4901              LDR      r1,|L17.16|
00000a  6008              STR      r0,[r1,#0]
;;;601    }
00000c  4770              BX       lr
;;;602    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarm PROC
;;;1255     */
;;;1256   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1257   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;1258     uint32_t tmpreg = 0;
00000a  2500              MOVS     r5,#0
;;;1259   
;;;1260     /* Check the parameters */
;;;1261     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1262     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;1263   
;;;1264     /* Get the RTC_ALRMxR register */
;;;1265     if (RTC_Alarm == RTC_Alarm_A)
00000c  f5b77f80          CMP      r7,#0x100
000010  d102              BNE      |L18.24|
;;;1266     {
;;;1267       tmpreg = (uint32_t)(RTC->ALRMAR);
000012  4817              LDR      r0,|L18.112|
000014  6805              LDR      r5,[r0,#0]
000016  e002              B        |L18.30|
                  |L18.24|
;;;1268     }
;;;1269     else
;;;1270     {
;;;1271       tmpreg = (uint32_t)(RTC->ALRMBR);
000018  4815              LDR      r0,|L18.112|
00001a  1d00              ADDS     r0,r0,#4
00001c  6805              LDR      r5,[r0,#0]
                  |L18.30|
;;;1272     }
;;;1273   
;;;1274     /* Fill the structure with the read parameters */
;;;1275     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
00001e  f3c54005          UBFX     r0,r5,#16,#6
000022  7020              STRB     r0,[r4,#0]
;;;1276                                                        RTC_ALRMAR_HU)) >> 16);
;;;1277     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
000024  f3c52006          UBFX     r0,r5,#8,#7
000028  7060              STRB     r0,[r4,#1]
;;;1278                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1279     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
00002a  f005007f          AND      r0,r5,#0x7f
00002e  70a0              STRB     r0,[r4,#2]
;;;1280                                                        RTC_ALRMAR_SU));
;;;1281     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
000030  f4050080          AND      r0,r5,#0x400000
000034  0c00              LSRS     r0,r0,#16
000036  70e0              STRB     r0,[r4,#3]
;;;1282     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
000038  f3c56005          UBFX     r0,r5,#24,#6
00003c  7320              STRB     r0,[r4,#0xc]
;;;1283     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
00003e  f0054080          AND      r0,r5,#0x40000000
000042  60a0              STR      r0,[r4,#8]
;;;1284     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
000044  f0053080          AND      r0,r5,#0x80808080
000048  6060              STR      r0,[r4,#4]
;;;1285   
;;;1286     if (RTC_Format == RTC_Format_BIN)
00004a  b97e              CBNZ     r6,|L18.108|
;;;1287     {
;;;1288       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00004c  7820              LDRB     r0,[r4,#0]
00004e  f7fffffe          BL       RTC_Bcd2ToByte
000052  7020              STRB     r0,[r4,#0]
;;;1289                                                           RTC_AlarmTime.RTC_Hours);
;;;1290       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000054  7860              LDRB     r0,[r4,#1]
000056  f7fffffe          BL       RTC_Bcd2ToByte
00005a  7060              STRB     r0,[r4,#1]
;;;1291                                                           RTC_AlarmTime.RTC_Minutes);
;;;1292       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00005c  78a0              LDRB     r0,[r4,#2]
00005e  f7fffffe          BL       RTC_Bcd2ToByte
000062  70a0              STRB     r0,[r4,#2]
;;;1293                                                           RTC_AlarmTime.RTC_Seconds);
;;;1294       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000064  7b20              LDRB     r0,[r4,#0xc]
000066  f7fffffe          BL       RTC_Bcd2ToByte
00006a  7320              STRB     r0,[r4,#0xc]
                  |L18.108|
;;;1295     }  
;;;1296   }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;1297   
                          ENDP

                  |L18.112|
                          DCD      0x4000281c

                          AREA ||i.RTC_GetAlarmSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmSubSecond PROC
;;;1444     */
;;;1445   uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
000000  4601              MOV      r1,r0
;;;1446   {
;;;1447     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1448     
;;;1449     /* Get the RTC_ALRMxR register */
;;;1450     if (RTC_Alarm == RTC_Alarm_A)
000004  f5b17f80          CMP      r1,#0x100
000008  d104              BNE      |L19.20|
;;;1451     {
;;;1452       tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
00000a  4a05              LDR      r2,|L19.32|
00000c  6812              LDR      r2,[r2,#0]
00000e  f3c2000e          UBFX     r0,r2,#0,#15
000012  e004              B        |L19.30|
                  |L19.20|
;;;1453     }
;;;1454     else
;;;1455     {
;;;1456       tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
000014  4a02              LDR      r2,|L19.32|
000016  1d12              ADDS     r2,r2,#4
000018  6812              LDR      r2,[r2,#0]
00001a  f3c2000e          UBFX     r0,r2,#0,#15
                  |L19.30|
;;;1457     } 
;;;1458     
;;;1459     return (tmpreg);
;;;1460   }
00001e  4770              BX       lr
;;;1461   
                          ENDP

                  |L19.32|
                          DCD      0x40002844

                          AREA ||i.RTC_GetDate||, CODE, READONLY, ALIGN=2

                  RTC_GetDate PROC
;;;1054     */
;;;1055   void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1056   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1057     uint32_t tmpreg = 0;
000006  2500              MOVS     r5,#0
;;;1058   
;;;1059     /* Check the parameters */
;;;1060     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1061     
;;;1062     /* Get the RTC_TR register */
;;;1063     tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000008  480e              LDR      r0,|L20.68|
00000a  6800              LDR      r0,[r0,#0]
00000c  490e              LDR      r1,|L20.72|
00000e  ea000501          AND      r5,r0,r1
;;;1064   
;;;1065     /* Fill the structure fields with the read parameters */
;;;1066     RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
000012  0c28              LSRS     r0,r5,#16
000014  70e0              STRB     r0,[r4,#3]
;;;1067     RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000016  f3c52004          UBFX     r0,r5,#8,#5
00001a  7060              STRB     r0,[r4,#1]
;;;1068     RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
00001c  f005003f          AND      r0,r5,#0x3f
000020  70a0              STRB     r0,[r4,#2]
;;;1069     RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
000022  f3c53042          UBFX     r0,r5,#13,#3
000026  7020              STRB     r0,[r4,#0]
;;;1070   
;;;1071     /* Check the input parameters format */
;;;1072     if (RTC_Format == RTC_Format_BIN)
000028  b95e              CBNZ     r6,|L20.66|
;;;1073     {
;;;1074       /* Convert the structure parameters to Binary format */
;;;1075       RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
00002a  78e0              LDRB     r0,[r4,#3]
00002c  f7fffffe          BL       RTC_Bcd2ToByte
000030  70e0              STRB     r0,[r4,#3]
;;;1076       RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
000032  7860              LDRB     r0,[r4,#1]
000034  f7fffffe          BL       RTC_Bcd2ToByte
000038  7060              STRB     r0,[r4,#1]
;;;1077       RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f7fffffe          BL       RTC_Bcd2ToByte
000040  70a0              STRB     r0,[r4,#2]
                  |L20.66|
;;;1078     }
;;;1079   }
000042  bd70              POP      {r4-r6,pc}
;;;1080   
                          ENDP

                  |L20.68|
                          DCD      0x40002804
                  |L20.72|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;2605     */
;;;2606   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;2607   {
000002  4601              MOV      r1,r0
;;;2608     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2609     uint32_t tmpreg = 0;
000006  2200              MOVS     r2,#0
;;;2610     
;;;2611     /* Check the parameters */
;;;2612     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;2613     
;;;2614     /* Get all the flags */
;;;2615     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000008  4b05              LDR      r3,|L21.32|
00000a  681b              LDR      r3,[r3,#0]
00000c  4c05              LDR      r4,|L21.36|
00000e  ea030204          AND      r2,r3,r4
;;;2616     
;;;2617     /* Return the status of the flag */
;;;2618     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
000012  ea020301          AND      r3,r2,r1
000016  b10b              CBZ      r3,|L21.28|
;;;2619     {
;;;2620       bitstatus = SET;
000018  2001              MOVS     r0,#1
00001a  e000              B        |L21.30|
                  |L21.28|
;;;2621     }
;;;2622     else
;;;2623     {
;;;2624       bitstatus = RESET;
00001c  2000              MOVS     r0,#0
                  |L21.30|
;;;2625     }
;;;2626     return bitstatus;
;;;2627   }
00001e  bd10              POP      {r4,pc}
;;;2628   
                          ENDP

                  |L21.32|
                          DCD      0x4000280c
                  |L21.36|
                          DCD      0x00017f7f

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;2663     */
;;;2664   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2665   {
000002  4601              MOV      r1,r0
;;;2666     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2667     uint32_t tmpreg = 0, enablestatus = 0;
000006  2200              MOVS     r2,#0
000008  2300              MOVS     r3,#0
;;;2668    
;;;2669     /* Check the parameters */
;;;2670     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;2671     
;;;2672     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2673     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
00000a  4c0d              LDR      r4,|L22.64|
00000c  6824              LDR      r4,[r4,#0]
00000e  f0040204          AND      r2,r4,#4
;;;2674    
;;;2675     /* Get the Interrupt enable Status */
;;;2676     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)) | (tmpreg & (RTC_IT >> 16)));
000012  4c0b              LDR      r4,|L22.64|
000014  3c38              SUBS     r4,r4,#0x38
000016  6824              LDR      r4,[r4,#0]
000018  400c              ANDS     r4,r4,r1
00001a  ea0235d1          AND      r5,r2,r1,LSR #15
00001e  432c              ORRS     r4,r4,r5
000020  ea024511          AND      r5,r2,r1,LSR #16
000024  ea440305          ORR      r3,r4,r5
;;;2677     
;;;2678     /* Get the Interrupt pending bit */
;;;2679     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
000028  4c05              LDR      r4,|L22.64|
00002a  3c34              SUBS     r4,r4,#0x34
00002c  6824              LDR      r4,[r4,#0]
00002e  ea041211          AND      r2,r4,r1,LSR #4
;;;2680     
;;;2681     /* Get the status of the Interrupt */
;;;2682     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
000032  b11b              CBZ      r3,|L22.60|
000034  b294              UXTH     r4,r2
000036  b10c              CBZ      r4,|L22.60|
;;;2683     {
;;;2684       bitstatus = SET;
000038  2001              MOVS     r0,#1
00003a  e000              B        |L22.62|
                  |L22.60|
;;;2685     }
;;;2686     else
;;;2687     {
;;;2688       bitstatus = RESET;
00003c  2000              MOVS     r0,#0
                  |L22.62|
;;;2689     }
;;;2690     return bitstatus;
;;;2691   }
00003e  bd30              POP      {r4,r5,pc}
;;;2692   
                          ENDP

                  |L22.64|
                          DCD      0x40002840

                          AREA ||i.RTC_GetStoreOperation||, CODE, READONLY, ALIGN=2

                  RTC_GetStoreOperation PROC
;;;1657     */
;;;1658   uint32_t RTC_GetStoreOperation(void)
000000  4802              LDR      r0,|L23.12|
;;;1659   {
;;;1660     return (RTC->CR & RTC_CR_BCK);
000002  6800              LDR      r0,[r0,#0]
000004  f4002080          AND      r0,r0,#0x40000
;;;1661   }
000008  4770              BX       lr
;;;1662   
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      0x40002808

                          AREA ||i.RTC_GetSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetSubSecond PROC
;;;919      */
;;;920    uint32_t RTC_GetSubSecond(void)
000000  2000              MOVS     r0,#0
;;;921    {
;;;922      uint32_t tmpreg = 0;
;;;923      
;;;924      /* Get sub seconds values from the correspondent registers*/
;;;925      tmpreg = (uint32_t)(RTC->SSR);
000002  4903              LDR      r1,|L24.16|
000004  6808              LDR      r0,[r1,#0]
;;;926      
;;;927      /* Read DR register to unfroze calendar registers */
;;;928      (void) (RTC->DR);
000006  4902              LDR      r1,|L24.16|
000008  3924              SUBS     r1,r1,#0x24
00000a  6809              LDR      r1,[r1,#0]
;;;929      
;;;930      return (tmpreg);
;;;931    }
00000c  4770              BX       lr
;;;932    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x40002828

                          AREA ||i.RTC_GetTime||, CODE, READONLY, ALIGN=2

                  RTC_GetTime PROC
;;;886      */
;;;887    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;888    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;889      uint32_t tmpreg = 0;
000006  2500              MOVS     r5,#0
;;;890    
;;;891      /* Check the parameters */
;;;892      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;893    
;;;894      /* Get the RTC_TR register */
;;;895      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
000008  480f              LDR      r0,|L25.72|
00000a  6800              LDR      r0,[r0,#0]
00000c  490f              LDR      r1,|L25.76|
00000e  ea000501          AND      r5,r0,r1
;;;896      
;;;897      /* Fill the structure fields with the read parameters */
;;;898      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
000012  f3c54005          UBFX     r0,r5,#16,#6
000016  7020              STRB     r0,[r4,#0]
;;;899      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
000018  f3c52006          UBFX     r0,r5,#8,#7
00001c  7060              STRB     r0,[r4,#1]
;;;900      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
00001e  f005007f          AND      r0,r5,#0x7f
000022  70a0              STRB     r0,[r4,#2]
;;;901      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
000024  f4050080          AND      r0,r5,#0x400000
000028  0c00              LSRS     r0,r0,#16
00002a  70e0              STRB     r0,[r4,#3]
;;;902    
;;;903      /* Check the input parameters format */
;;;904      if (RTC_Format == RTC_Format_BIN)
00002c  b95e              CBNZ     r6,|L25.70|
;;;905      {
;;;906        /* Convert the structure parameters to Binary format */
;;;907        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00002e  7820              LDRB     r0,[r4,#0]
000030  f7fffffe          BL       RTC_Bcd2ToByte
000034  7020              STRB     r0,[r4,#0]
;;;908        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
000036  7860              LDRB     r0,[r4,#1]
000038  f7fffffe          BL       RTC_Bcd2ToByte
00003c  7060              STRB     r0,[r4,#1]
;;;909        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
00003e  78a0              LDRB     r0,[r4,#2]
000040  f7fffffe          BL       RTC_Bcd2ToByte
000044  70a0              STRB     r0,[r4,#2]
                  |L25.70|
;;;910      }
;;;911    }
000046  bd70              POP      {r4-r6,pc}
;;;912    
                          ENDP

                  |L25.72|
                          DCD      0x40002800
                  |L25.76|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStamp PROC
;;;2025     */
;;;2026   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2027                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;2028   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;2029     uint32_t tmptime = 0, tmpdate = 0;
00000a  2600              MOVS     r6,#0
00000c  2700              MOVS     r7,#0
;;;2030   
;;;2031     /* Check the parameters */
;;;2032     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;2033   
;;;2034     /* Get the TimeStamp time and date registers values */
;;;2035     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
00000e  4820              LDR      r0,|L26.144|
000010  6800              LDR      r0,[r0,#0]
000012  4920              LDR      r1,|L26.148|
000014  ea000601          AND      r6,r0,r1
;;;2036     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
000018  481d              LDR      r0,|L26.144|
00001a  1d00              ADDS     r0,r0,#4
00001c  6800              LDR      r0,[r0,#0]
00001e  491e              LDR      r1,|L26.152|
000020  ea000701          AND      r7,r0,r1
;;;2037   
;;;2038     /* Fill the Time structure fields with the read parameters */
;;;2039     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
000024  f3c64005          UBFX     r0,r6,#16,#6
000028  7020              STRB     r0,[r4,#0]
;;;2040     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
00002a  f3c62006          UBFX     r0,r6,#8,#7
00002e  7060              STRB     r0,[r4,#1]
;;;2041     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000030  f006007f          AND      r0,r6,#0x7f
000034  70a0              STRB     r0,[r4,#2]
;;;2042     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
000036  f4060080          AND      r0,r6,#0x400000
00003a  0c00              LSRS     r0,r0,#16
00003c  70e0              STRB     r0,[r4,#3]
;;;2043   
;;;2044     /* Fill the Date structure fields with the read parameters */
;;;2045     RTC_StampDateStruct->RTC_Year = 0;
00003e  2000              MOVS     r0,#0
000040  70e8              STRB     r0,[r5,#3]
;;;2046     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000042  f3c72004          UBFX     r0,r7,#8,#5
000046  7068              STRB     r0,[r5,#1]
;;;2047     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
000048  f007003f          AND      r0,r7,#0x3f
00004c  70a8              STRB     r0,[r5,#2]
;;;2048     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
00004e  f3c73042          UBFX     r0,r7,#13,#3
000052  7028              STRB     r0,[r5,#0]
;;;2049   
;;;2050     /* Check the input parameters format */
;;;2051     if (RTC_Format == RTC_Format_BIN)
000054  f1b80f00          CMP      r8,#0
000058  d117              BNE      |L26.138|
;;;2052     {
;;;2053       /* Convert the Time structure parameters to Binary format */
;;;2054       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
00005a  7820              LDRB     r0,[r4,#0]
00005c  f7fffffe          BL       RTC_Bcd2ToByte
000060  7020              STRB     r0,[r4,#0]
;;;2055       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
000062  7860              LDRB     r0,[r4,#1]
000064  f7fffffe          BL       RTC_Bcd2ToByte
000068  7060              STRB     r0,[r4,#1]
;;;2056       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
00006a  78a0              LDRB     r0,[r4,#2]
00006c  f7fffffe          BL       RTC_Bcd2ToByte
000070  70a0              STRB     r0,[r4,#2]
;;;2057   
;;;2058       /* Convert the Date structure parameters to Binary format */
;;;2059       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
000072  7868              LDRB     r0,[r5,#1]
000074  f7fffffe          BL       RTC_Bcd2ToByte
000078  7068              STRB     r0,[r5,#1]
;;;2060       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
00007a  78a8              LDRB     r0,[r5,#2]
00007c  f7fffffe          BL       RTC_Bcd2ToByte
000080  70a8              STRB     r0,[r5,#2]
;;;2061       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
000082  7828              LDRB     r0,[r5,#0]
000084  f7fffffe          BL       RTC_Bcd2ToByte
000088  7028              STRB     r0,[r5,#0]
                  |L26.138|
;;;2062     }
;;;2063   }
00008a  e8bd81f0          POP      {r4-r8,pc}
;;;2064   
                          ENDP

00008e  0000              DCW      0x0000
                  |L26.144|
                          DCD      0x40002830
                  |L26.148|
                          DCD      0x007f7f7f
                  |L26.152|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetTimeStampSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStampSubSecond PROC
;;;2069     */
;;;2070   uint32_t RTC_GetTimeStampSubSecond(void)
000000  4801              LDR      r0,|L27.8|
;;;2071   {
;;;2072     /* Get timestamp sub seconds values from the correspondent registers */
;;;2073     return (uint32_t)(RTC->TSSSR);
000002  6800              LDR      r0,[r0,#0]
;;;2074   }
000004  4770              BX       lr
;;;2075   
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x40002838

                          AREA ||i.RTC_GetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_GetWakeUpCounter PROC
;;;1541     */
;;;1542   uint32_t RTC_GetWakeUpCounter(void)
000000  4801              LDR      r0,|L28.8|
;;;1543   {
;;;1544     /* Get the counter value */
;;;1545     return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
000002  6800              LDR      r0,[r0,#0]
000004  b280              UXTH     r0,r0
;;;1546   }
000006  4770              BX       lr
;;;1547   
                          ENDP

                  |L28.8|
                          DCD      0x40002814

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;2556     */
;;;2557   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000000  22ca              MOVS     r2,#0xca
;;;2558   {
;;;2559     /* Check the parameters */
;;;2560     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;2561     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2562   
;;;2563     /* Disable the write protection for RTC registers */
;;;2564     RTC->WPR = 0xCA;
000002  4b17              LDR      r3,|L29.96|
000004  601a              STR      r2,[r3,#0]
;;;2565     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  601a              STR      r2,[r3,#0]
;;;2566   
;;;2567     if (NewState != DISABLE)
00000a  b191              CBZ      r1,|L29.50|
;;;2568     {
;;;2569       /* Configure the Interrupts in the RTC_CR register */
;;;2570       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
00000c  4a14              LDR      r2,|L29.96|
00000e  3a1c              SUBS     r2,r2,#0x1c
000010  6812              LDR      r2,[r2,#0]
000012  f0200304          BIC      r3,r0,#4
000016  431a              ORRS     r2,r2,r3
000018  4b11              LDR      r3,|L29.96|
00001a  3b1c              SUBS     r3,r3,#0x1c
00001c  601a              STR      r2,[r3,#0]
;;;2571       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2572       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
00001e  4a10              LDR      r2,|L29.96|
000020  321c              ADDS     r2,r2,#0x1c
000022  6812              LDR      r2,[r2,#0]
000024  f0000304          AND      r3,r0,#4
000028  431a              ORRS     r2,r2,r3
00002a  4b0d              LDR      r3,|L29.96|
00002c  331c              ADDS     r3,r3,#0x1c
00002e  601a              STR      r2,[r3,#0]
000030  e011              B        |L29.86|
                  |L29.50|
;;;2573     }
;;;2574     else
;;;2575     {
;;;2576       /* Configure the Interrupts in the RTC_CR register */
;;;2577       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
000032  4a0b              LDR      r2,|L29.96|
000034  3a1c              SUBS     r2,r2,#0x1c
000036  6812              LDR      r2,[r2,#0]
000038  f0200304          BIC      r3,r0,#4
00003c  439a              BICS     r2,r2,r3
00003e  4b08              LDR      r3,|L29.96|
000040  3b1c              SUBS     r3,r3,#0x1c
000042  601a              STR      r2,[r3,#0]
;;;2578       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2579       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000044  4a06              LDR      r2,|L29.96|
000046  321c              ADDS     r2,r2,#0x1c
000048  6812              LDR      r2,[r2,#0]
00004a  f0000304          AND      r3,r0,#4
00004e  439a              BICS     r2,r2,r3
000050  4b03              LDR      r3,|L29.96|
000052  331c              ADDS     r3,r3,#0x1c
000054  601a              STR      r2,[r3,#0]
                  |L29.86|
;;;2580     }
;;;2581     /* Enable the write protection for RTC registers */
;;;2582     RTC->WPR = 0xFF; 
000056  22ff              MOVS     r2,#0xff
000058  4b01              LDR      r3,|L29.96|
00005a  601a              STR      r2,[r3,#0]
;;;2583   }
00005c  4770              BX       lr
;;;2584   
                          ENDP

00005e  0000              DCW      0x0000
                  |L29.96|
                          DCD      0x40002824

                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=2

                  RTC_Init PROC
;;;456      */
;;;457    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;458    {
000002  4604              MOV      r4,r0
;;;459      ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;460      
;;;461      /* Check the parameters */
;;;462      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;463      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;464      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;465    
;;;466      /* Disable the write protection for RTC registers */
;;;467      RTC->WPR = 0xCA;
000006  20ca              MOVS     r0,#0xca
000008  4915              LDR      r1,|L30.96|
00000a  6008              STR      r0,[r1,#0]
;;;468      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6008              STR      r0,[r1,#0]
;;;469    
;;;470      /* Set Initialization mode */
;;;471      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b900              CBNZ     r0,|L30.24|
;;;472      {
;;;473        status = ERROR;
000016  e01d              B        |L30.84|
                  |L30.24|
;;;474      } 
;;;475      else
;;;476      {
;;;477        /* Clear RTC CR FMT Bit */
;;;478        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
000018  4811              LDR      r0,|L30.96|
00001a  381c              SUBS     r0,r0,#0x1c
00001c  6800              LDR      r0,[r0,#0]
00001e  f0200040          BIC      r0,r0,#0x40
000022  490f              LDR      r1,|L30.96|
000024  391c              SUBS     r1,r1,#0x1c
000026  6008              STR      r0,[r1,#0]
;;;479        /* Set RTC_CR register */
;;;480        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]
00002c  6821              LDR      r1,[r4,#0]
00002e  4308              ORRS     r0,r0,r1
000030  490b              LDR      r1,|L30.96|
000032  391c              SUBS     r1,r1,#0x1c
000034  6008              STR      r0,[r1,#0]
;;;481      
;;;482        /* Configure the RTC PRER */
;;;483        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
000036  490a              LDR      r1,|L30.96|
000038  3914              SUBS     r1,r1,#0x14
00003a  68a0              LDR      r0,[r4,#8]
00003c  6008              STR      r0,[r1,#0]
;;;484        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
00003e  4608              MOV      r0,r1
000040  6800              LDR      r0,[r0,#0]
000042  88a1              LDRH     r1,[r4,#4]
000044  ea404001          ORR      r0,r0,r1,LSL #16
000048  4905              LDR      r1,|L30.96|
00004a  3914              SUBS     r1,r1,#0x14
00004c  6008              STR      r0,[r1,#0]
;;;485    
;;;486        /* Exit Initialization mode */
;;;487        RTC_ExitInitMode();
00004e  f7fffffe          BL       RTC_ExitInitMode
;;;488    
;;;489        status = SUCCESS;    
000052  2501              MOVS     r5,#1
                  |L30.84|
;;;490      }
;;;491      /* Enable the write protection for RTC registers */
;;;492      RTC->WPR = 0xFF; 
000054  20ff              MOVS     r0,#0xff
000056  4902              LDR      r1,|L30.96|
000058  6008              STR      r0,[r1,#0]
;;;493      
;;;494      return status;
00005a  4628              MOV      r0,r5
;;;495    }
00005c  bd30              POP      {r4,r5,pc}
;;;496    
                          ENDP

00005e  0000              DCW      0x0000
                  |L30.96|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputConfig PROC
;;;1696     */
;;;1697   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000000  22ca              MOVS     r2,#0xca
;;;1698   {
;;;1699     /* Check the parameters */
;;;1700     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1701     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1702   
;;;1703     /* Disable the write protection for RTC registers */
;;;1704     RTC->WPR = 0xCA;
000002  4b0c              LDR      r3,|L31.52|
000004  601a              STR      r2,[r3,#0]
;;;1705     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  601a              STR      r2,[r3,#0]
;;;1706   
;;;1707     /* Clear the bits to be configured */
;;;1708     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
00000a  4a0a              LDR      r2,|L31.52|
00000c  3a1c              SUBS     r2,r2,#0x1c
00000e  6812              LDR      r2,[r2,#0]
000010  f42202e0          BIC      r2,r2,#0x700000
000014  4b07              LDR      r3,|L31.52|
000016  3b1c              SUBS     r3,r3,#0x1c
000018  601a              STR      r2,[r3,#0]
;;;1709   
;;;1710     /* Configure the output selection and polarity */
;;;1711     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
00001a  461a              MOV      r2,r3
00001c  6812              LDR      r2,[r2,#0]
00001e  ea400301          ORR      r3,r0,r1
000022  431a              ORRS     r2,r2,r3
000024  4b03              LDR      r3,|L31.52|
000026  3b1c              SUBS     r3,r3,#0x1c
000028  601a              STR      r2,[r3,#0]
;;;1712   
;;;1713     /* Enable the write protection for RTC registers */
;;;1714     RTC->WPR = 0xFF; 
00002a  22ff              MOVS     r2,#0xff
00002c  4b01              LDR      r3,|L31.52|
00002e  601a              STR      r2,[r3,#0]
;;;1715   }
000030  4770              BX       lr
;;;1716   
                          ENDP

000032  0000              DCW      0x0000
                  |L31.52|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputTypeConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputTypeConfig PROC
;;;2398     */
;;;2399   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000000  4905              LDR      r1,|L32.24|
;;;2400   {
;;;2401     /* Check the parameters */
;;;2402     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;2403     
;;;2404     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000002  6809              LDR      r1,[r1,#0]
000004  f4212180          BIC      r1,r1,#0x40000
000008  4a03              LDR      r2,|L32.24|
00000a  6011              STR      r1,[r2,#0]
;;;2405     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;2406   }
000014  4770              BX       lr
;;;2407   
                          ENDP

000016  0000              DCW      0x0000
                  |L32.24|
                          DCD      0x40002840

                          AREA ||i.RTC_ReadBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_ReadBackupRegister PROC
;;;2323     */
;;;2324   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
000000  b508              PUSH     {r3,lr}
;;;2325   {
000002  4601              MOV      r1,r0
;;;2326     __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;2327     
;;;2328     /* Check the parameters */
;;;2329     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2330   
;;;2331     tmp = RTC_BASE + 0x50;
000008  4804              LDR      r0,|L33.28|
00000a  9000              STR      r0,[sp,#0]
;;;2332     tmp += (RTC_BKP_DR * 4);
00000c  9800              LDR      r0,[sp,#0]
00000e  eb000081          ADD      r0,r0,r1,LSL #2
000012  9000              STR      r0,[sp,#0]
;;;2333     
;;;2334     /* Read the specified register */
;;;2335     return (*(__IO uint32_t *)tmp);
000014  9800              LDR      r0,[sp,#0]
000016  6800              LDR      r0,[r0,#0]
;;;2336   }
000018  bd08              POP      {r3,pc}
;;;2337   
                          ENDP

00001a  0000              DCW      0x0000
                  |L33.28|
                          DCD      0x40002850

                          AREA ||i.RTC_RefClockCmd||, CODE, READONLY, ALIGN=2

                  RTC_RefClockCmd PROC
;;;661      */
;;;662    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;663    { 
000002  4604              MOV      r4,r0
;;;664      ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;665      
;;;666      /* Check the parameters */
;;;667      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;668      
;;;669      /* Disable the write protection for RTC registers */
;;;670      RTC->WPR = 0xCA;
000006  20ca              MOVS     r0,#0xca
000008  4910              LDR      r1,|L34.76|
00000a  6008              STR      r0,[r1,#0]
;;;671      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6008              STR      r0,[r1,#0]
;;;672        
;;;673      /* Set Initialization mode */
;;;674      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b900              CBNZ     r0,|L34.24|
;;;675      {
;;;676        status = ERROR;
000016  e014              B        |L34.66|
                  |L34.24|
;;;677      } 
;;;678      else
;;;679      {  
;;;680        if (NewState != DISABLE)
000018  b144              CBZ      r4,|L34.44|
;;;681        {
;;;682          /* Enable the RTC reference clock detection */
;;;683          RTC->CR |= RTC_CR_REFCKON;   
00001a  480c              LDR      r0,|L34.76|
00001c  381c              SUBS     r0,r0,#0x1c
00001e  6800              LDR      r0,[r0,#0]
000020  f0400010          ORR      r0,r0,#0x10
000024  4909              LDR      r1,|L34.76|
000026  391c              SUBS     r1,r1,#0x1c
000028  6008              STR      r0,[r1,#0]
00002a  e007              B        |L34.60|
                  |L34.44|
;;;684        }
;;;685        else
;;;686        {
;;;687          /* Disable the RTC reference clock detection */
;;;688          RTC->CR &= ~RTC_CR_REFCKON;    
00002c  4807              LDR      r0,|L34.76|
00002e  381c              SUBS     r0,r0,#0x1c
000030  6800              LDR      r0,[r0,#0]
000032  f0200010          BIC      r0,r0,#0x10
000036  4905              LDR      r1,|L34.76|
000038  391c              SUBS     r1,r1,#0x1c
00003a  6008              STR      r0,[r1,#0]
                  |L34.60|
;;;689        }
;;;690        /* Exit Initialization mode */
;;;691        RTC_ExitInitMode();
00003c  f7fffffe          BL       RTC_ExitInitMode
;;;692        
;;;693        status = SUCCESS;
000040  2501              MOVS     r5,#1
                  |L34.66|
;;;694      }
;;;695      
;;;696      /* Enable the write protection for RTC registers */
;;;697      RTC->WPR = 0xFF;  
000042  20ff              MOVS     r0,#0xff
000044  4901              LDR      r1,|L34.76|
000046  6008              STR      r0,[r1,#0]
;;;698      
;;;699      return status; 
000048  4628              MOV      r0,r5
;;;700    }
00004a  bd30              POP      {r4,r5,pc}
;;;701    
                          ENDP

                  |L34.76|
                          DCD      0x40002824

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;1114     */
;;;1115   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1116   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;1117     uint32_t tmpreg = 0;
00000a  2700              MOVS     r7,#0
;;;1118     
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1121     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1122     assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;1123     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;1124   
;;;1125     if (RTC_Format == RTC_Format_BIN)
00000c  b965              CBNZ     r5,|L35.40|
;;;1126     {
;;;1127       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00000e  4836              LDR      r0,|L35.232|
000010  6800              LDR      r0,[r0,#0]
000012  f0000040          AND      r0,r0,#0x40
000016  b100              CBZ      r0,|L35.26|
;;;1128       {
;;;1129         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1130         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
000018  e002              B        |L35.32|
                  |L35.26|
;;;1131       } 
;;;1132       else
;;;1133       {
;;;1134         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
00001a  2000              MOVS     r0,#0
00001c  70e0              STRB     r0,[r4,#3]
;;;1135         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
00001e  bf00              NOP      
                  |L35.32|
;;;1136       }
;;;1137       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1138       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1139       
;;;1140       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
000020  68a0              LDR      r0,[r4,#8]
000022  b900              CBNZ     r0,|L35.38|
;;;1141       {
;;;1142         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
000024  e019              B        |L35.90|
                  |L35.38|
;;;1143       }
;;;1144       else
;;;1145       {
;;;1146         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
000026  e018              B        |L35.90|
                  |L35.40|
;;;1147       }
;;;1148     }
;;;1149     else
;;;1150     {
;;;1151       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000028  482f              LDR      r0,|L35.232|
00002a  6800              LDR      r0,[r0,#0]
00002c  f0000040          AND      r0,r0,#0x40
000030  b120              CBZ      r0,|L35.60|
;;;1152       {
;;;1153         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
000032  7820              LDRB     r0,[r4,#0]
000034  f7fffffe          BL       RTC_Bcd2ToByte
000038  4607              MOV      r7,r0
;;;1154         assert_param(IS_RTC_HOUR12(tmpreg));
;;;1155         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
00003a  e002              B        |L35.66|
                  |L35.60|
;;;1156       } 
;;;1157       else
;;;1158       {
;;;1159         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
00003c  2000              MOVS     r0,#0
00003e  70e0              STRB     r0,[r4,#3]
;;;1160         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
000040  bf00              NOP      
                  |L35.66|
;;;1161       }
;;;1162       
;;;1163       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;1164       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;1165       
;;;1166       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
000042  68a0              LDR      r0,[r4,#8]
000044  b920              CBNZ     r0,|L35.80|
;;;1167       {
;;;1168         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000046  7b20              LDRB     r0,[r4,#0xc]
000048  f7fffffe          BL       RTC_Bcd2ToByte
00004c  4607              MOV      r7,r0
;;;1169         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
00004e  e004              B        |L35.90|
                  |L35.80|
;;;1170       }
;;;1171       else
;;;1172       {
;;;1173         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000050  7b20              LDRB     r0,[r4,#0xc]
000052  f7fffffe          BL       RTC_Bcd2ToByte
000056  4607              MOV      r7,r0
;;;1174         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
000058  bf00              NOP      
                  |L35.90|
;;;1175       }    
;;;1176     }
;;;1177   
;;;1178     /* Check the input parameters format */
;;;1179     if (RTC_Format != RTC_Format_BIN)
00005a  b195              CBZ      r5,|L35.130|
;;;1180     {
;;;1181       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
00005c  7820              LDRB     r0,[r4,#0]
00005e  0400              LSLS     r0,r0,#16
000060  7861              LDRB     r1,[r4,#1]
000062  ea402001          ORR      r0,r0,r1,LSL #8
000066  78a1              LDRB     r1,[r4,#2]
000068  4308              ORRS     r0,r0,r1
00006a  78e1              LDRB     r1,[r4,#3]
00006c  ea404001          ORR      r0,r0,r1,LSL #16
000070  7b21              LDRB     r1,[r4,#0xc]
000072  ea406001          ORR      r0,r0,r1,LSL #24
000076  68a1              LDR      r1,[r4,#8]
000078  4308              ORRS     r0,r0,r1
00007a  6861              LDR      r1,[r4,#4]
00007c  ea400701          ORR      r7,r0,r1
000080  e01b              B        |L35.186|
                  |L35.130|
;;;1182                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1183                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1184                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1185                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1186                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1187                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1188     }  
;;;1189     else
;;;1190     {
;;;1191       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000082  7820              LDRB     r0,[r4,#0]
000084  f7fffffe          BL       RTC_ByteToBcd2
000088  ea4f4800          LSL      r8,r0,#16
00008c  7860              LDRB     r0,[r4,#1]
00008e  f7fffffe          BL       RTC_ByteToBcd2
000092  ea482800          ORR      r8,r8,r0,LSL #8
000096  78a0              LDRB     r0,[r4,#2]
000098  f7fffffe          BL       RTC_ByteToBcd2
00009c  ea480800          ORR      r8,r8,r0
0000a0  78e0              LDRB     r0,[r4,#3]
0000a2  ea484800          ORR      r8,r8,r0,LSL #16
0000a6  7b20              LDRB     r0,[r4,#0xc]
0000a8  f7fffffe          BL       RTC_ByteToBcd2
0000ac  ea486000          ORR      r0,r8,r0,LSL #24
0000b0  68a1              LDR      r1,[r4,#8]
0000b2  4308              ORRS     r0,r0,r1
0000b4  6861              LDR      r1,[r4,#4]
0000b6  ea400701          ORR      r7,r0,r1
                  |L35.186|
;;;1192                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1193                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1194                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1195                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1196                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1197                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1198     } 
;;;1199   
;;;1200     /* Disable the write protection for RTC registers */
;;;1201     RTC->WPR = 0xCA;
0000ba  20ca              MOVS     r0,#0xca
0000bc  490a              LDR      r1,|L35.232|
0000be  311c              ADDS     r1,r1,#0x1c
0000c0  6008              STR      r0,[r1,#0]
;;;1202     RTC->WPR = 0x53;
0000c2  2053              MOVS     r0,#0x53
0000c4  6008              STR      r0,[r1,#0]
;;;1203   
;;;1204     /* Configure the Alarm register */
;;;1205     if (RTC_Alarm == RTC_Alarm_A)
0000c6  f5b67f80          CMP      r6,#0x100
0000ca  d103              BNE      |L35.212|
;;;1206     {
;;;1207       RTC->ALRMAR = (uint32_t)tmpreg;
0000cc  4806              LDR      r0,|L35.232|
0000ce  3014              ADDS     r0,r0,#0x14
0000d0  6007              STR      r7,[r0,#0]
0000d2  e002              B        |L35.218|
                  |L35.212|
;;;1208     }
;;;1209     else
;;;1210     {
;;;1211       RTC->ALRMBR = (uint32_t)tmpreg;
0000d4  4804              LDR      r0,|L35.232|
0000d6  3018              ADDS     r0,r0,#0x18
0000d8  6007              STR      r7,[r0,#0]
                  |L35.218|
;;;1212     }
;;;1213   
;;;1214     /* Enable the write protection for RTC registers */
;;;1215     RTC->WPR = 0xFF;   
0000da  20ff              MOVS     r0,#0xff
0000dc  4902              LDR      r1,|L35.232|
0000de  311c              ADDS     r1,r1,#0x1c
0000e0  6008              STR      r0,[r1,#0]
;;;1216   }
0000e2  e8bd81f0          POP      {r4-r8,pc}
;;;1217   
                          ENDP

0000e6  0000              DCW      0x0000
                  |L35.232|
                          DCD      0x40002808

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;944      */
;;;945    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;946    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;947      uint32_t tmpreg = 0;
000008  2600              MOVS     r6,#0
;;;948      ErrorStatus status = ERROR;
00000a  2700              MOVS     r7,#0
;;;949      
;;;950      /* Check the parameters */
;;;951      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;952    
;;;953      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
00000c  b94d              CBNZ     r5,|L36.34|
00000e  7860              LDRB     r0,[r4,#1]
000010  f0000010          AND      r0,r0,#0x10
000014  2810              CMP      r0,#0x10
000016  d104              BNE      |L36.34|
;;;954      {
;;;955        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
000018  7860              LDRB     r0,[r4,#1]
00001a  f0200010          BIC      r0,r0,#0x10
00001e  300a              ADDS     r0,r0,#0xa
000020  7060              STRB     r0,[r4,#1]
                  |L36.34|
;;;956      }  
;;;957      if (RTC_Format == RTC_Format_BIN)
000022  b905              CBNZ     r5,|L36.38|
;;;958      {
;;;959        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;960        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;961        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
000024  e008              B        |L36.56|
                  |L36.38|
;;;962      }
;;;963      else
;;;964      {
;;;965        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;966        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
000026  7860              LDRB     r0,[r4,#1]
000028  f7fffffe          BL       RTC_Bcd2ToByte
00002c  4606              MOV      r6,r0
;;;967        assert_param(IS_RTC_MONTH(tmpreg));
;;;968        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
00002e  78a0              LDRB     r0,[r4,#2]
000030  f7fffffe          BL       RTC_Bcd2ToByte
000034  4606              MOV      r6,r0
;;;969        assert_param(IS_RTC_DATE(tmpreg));
000036  bf00              NOP      
                  |L36.56|
;;;970      }
;;;971      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;972    
;;;973      /* Check the input parameters format */
;;;974      if (RTC_Format != RTC_Format_BIN)
000038  b155              CBZ      r5,|L36.80|
;;;975      {
;;;976        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
00003a  78e0              LDRB     r0,[r4,#3]
00003c  0400              LSLS     r0,r0,#16
00003e  7861              LDRB     r1,[r4,#1]
000040  ea402001          ORR      r0,r0,r1,LSL #8
000044  78a1              LDRB     r1,[r4,#2]
000046  4308              ORRS     r0,r0,r1
000048  7821              LDRB     r1,[r4,#0]
00004a  ea403641          ORR      r6,r0,r1,LSL #13
00004e  e011              B        |L36.116|
                  |L36.80|
;;;977                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;978                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;979                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;980      }  
;;;981      else
;;;982      {
;;;983        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
000050  78e0              LDRB     r0,[r4,#3]
000052  f7fffffe          BL       RTC_ByteToBcd2
000056  ea4f4800          LSL      r8,r0,#16
00005a  7860              LDRB     r0,[r4,#1]
00005c  f7fffffe          BL       RTC_ByteToBcd2
000060  ea482800          ORR      r8,r8,r0,LSL #8
000064  78a0              LDRB     r0,[r4,#2]
000066  f7fffffe          BL       RTC_ByteToBcd2
00006a  ea480800          ORR      r8,r8,r0
00006e  7820              LDRB     r0,[r4,#0]
000070  ea483640          ORR      r6,r8,r0,LSL #13
                  |L36.116|
;;;984                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;985                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;986                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;987      }
;;;988    
;;;989      /* Disable the write protection for RTC registers */
;;;990      RTC->WPR = 0xCA;
000074  20ca              MOVS     r0,#0xca
000076  4912              LDR      r1,|L36.192|
000078  6008              STR      r0,[r1,#0]
;;;991      RTC->WPR = 0x53;
00007a  2053              MOVS     r0,#0x53
00007c  6008              STR      r0,[r1,#0]
;;;992    
;;;993      /* Set Initialization mode */
;;;994      if (RTC_EnterInitMode() == ERROR)
00007e  f7fffffe          BL       RTC_EnterInitMode
000082  b908              CBNZ     r0,|L36.136|
;;;995      {
;;;996        status = ERROR;
000084  2700              MOVS     r7,#0
000086  e014              B        |L36.178|
                  |L36.136|
;;;997      } 
;;;998      else
;;;999      {
;;;1000       /* Set the RTC_DR register */
;;;1001       RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
000088  480e              LDR      r0,|L36.196|
00008a  4030              ANDS     r0,r0,r6
00008c  490c              LDR      r1,|L36.192|
00008e  3920              SUBS     r1,r1,#0x20
000090  6008              STR      r0,[r1,#0]
;;;1002   
;;;1003       /* Exit Initialization mode */
;;;1004       RTC_ExitInitMode(); 
000092  f7fffffe          BL       RTC_ExitInitMode
;;;1005   
;;;1006       /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;1007       if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
000096  480a              LDR      r0,|L36.192|
000098  381c              SUBS     r0,r0,#0x1c
00009a  6800              LDR      r0,[r0,#0]
00009c  f0000020          AND      r0,r0,#0x20
0000a0  b930              CBNZ     r0,|L36.176|
;;;1008       {
;;;1009       if(RTC_WaitForSynchro() == ERROR)
0000a2  f7fffffe          BL       RTC_WaitForSynchro
0000a6  b908              CBNZ     r0,|L36.172|
;;;1010       {
;;;1011         status = ERROR;
0000a8  2700              MOVS     r7,#0
0000aa  e002              B        |L36.178|
                  |L36.172|
;;;1012       }
;;;1013       else
;;;1014       {
;;;1015         status = SUCCESS;
0000ac  2701              MOVS     r7,#1
0000ae  e000              B        |L36.178|
                  |L36.176|
;;;1016       }
;;;1017     }
;;;1018       else
;;;1019       {
;;;1020         status = SUCCESS;
0000b0  2701              MOVS     r7,#1
                  |L36.178|
;;;1021       }
;;;1022     }
;;;1023     /* Enable the write protection for RTC registers */
;;;1024     RTC->WPR = 0xFF;   
0000b2  20ff              MOVS     r0,#0xff
0000b4  4902              LDR      r1,|L36.192|
0000b6  6008              STR      r0,[r1,#0]
;;;1025     
;;;1026     return status;
0000b8  4638              MOV      r0,r7
;;;1027   }
0000ba  e8bd81f0          POP      {r4-r8,pc}
;;;1028   
                          ENDP

0000be  0000              DCW      0x0000
                  |L36.192|
                          DCD      0x40002824
                  |L36.196|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;764      */
;;;765    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;766    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;767      uint32_t tmpreg = 0;
000008  2600              MOVS     r6,#0
;;;768      ErrorStatus status = ERROR;
00000a  2700              MOVS     r7,#0
;;;769        
;;;770      /* Check the parameters */
;;;771      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;772      
;;;773      if (RTC_Format == RTC_Format_BIN)
00000c  b94d              CBNZ     r5,|L37.34|
;;;774      {
;;;775        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00000e  482e              LDR      r0,|L37.200|
000010  6800              LDR      r0,[r0,#0]
000012  f0000040          AND      r0,r0,#0x40
000016  b100              CBZ      r0,|L37.26|
;;;776        {
;;;777          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;778          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
000018  e002              B        |L37.32|
                  |L37.26|
;;;779        } 
;;;780        else
;;;781        {
;;;782          RTC_TimeStruct->RTC_H12 = 0x00;
00001a  2000              MOVS     r0,#0
00001c  70e0              STRB     r0,[r4,#3]
;;;783          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
00001e  bf00              NOP      
                  |L37.32|
;;;784        }
;;;785        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;786        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
000020  e00d              B        |L37.62|
                  |L37.34|
;;;787      }
;;;788      else
;;;789      {
;;;790        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000022  4829              LDR      r0,|L37.200|
000024  6800              LDR      r0,[r0,#0]
000026  f0000040          AND      r0,r0,#0x40
00002a  b120              CBZ      r0,|L37.54|
;;;791        {
;;;792          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00002c  7820              LDRB     r0,[r4,#0]
00002e  f7fffffe          BL       RTC_Bcd2ToByte
000032  4606              MOV      r6,r0
;;;793          assert_param(IS_RTC_HOUR12(tmpreg));
;;;794          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
000034  e002              B        |L37.60|
                  |L37.54|
;;;795        } 
;;;796        else
;;;797        {
;;;798          RTC_TimeStruct->RTC_H12 = 0x00;
000036  2000              MOVS     r0,#0
000038  70e0              STRB     r0,[r4,#3]
;;;799          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
00003a  bf00              NOP      
                  |L37.60|
;;;800        }
;;;801        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;802        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
00003c  bf00              NOP      
                  |L37.62|
;;;803      }
;;;804      
;;;805      /* Check the input parameters format */
;;;806      if (RTC_Format != RTC_Format_BIN)
00003e  b155              CBZ      r5,|L37.86|
;;;807      {
;;;808        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
000040  7820              LDRB     r0,[r4,#0]
000042  0400              LSLS     r0,r0,#16
000044  7861              LDRB     r1,[r4,#1]
000046  ea402001          ORR      r0,r0,r1,LSL #8
00004a  78a1              LDRB     r1,[r4,#2]
00004c  4308              ORRS     r0,r0,r1
00004e  78e1              LDRB     r1,[r4,#3]
000050  ea404601          ORR      r6,r0,r1,LSL #16
000054  e011              B        |L37.122|
                  |L37.86|
;;;809                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;810                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;811                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;812      }  
;;;813      else
;;;814      {
;;;815        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
000056  7820              LDRB     r0,[r4,#0]
000058  f7fffffe          BL       RTC_ByteToBcd2
00005c  ea4f4800          LSL      r8,r0,#16
000060  7860              LDRB     r0,[r4,#1]
000062  f7fffffe          BL       RTC_ByteToBcd2
000066  ea482800          ORR      r8,r8,r0,LSL #8
00006a  78a0              LDRB     r0,[r4,#2]
00006c  f7fffffe          BL       RTC_ByteToBcd2
000070  ea480800          ORR      r8,r8,r0
000074  78e0              LDRB     r0,[r4,#3]
000076  ea484600          ORR      r6,r8,r0,LSL #16
                  |L37.122|
;;;816                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;817                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;818                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;819      }  
;;;820    
;;;821      /* Disable the write protection for RTC registers */
;;;822      RTC->WPR = 0xCA;
00007a  20ca              MOVS     r0,#0xca
00007c  4912              LDR      r1,|L37.200|
00007e  311c              ADDS     r1,r1,#0x1c
000080  6008              STR      r0,[r1,#0]
;;;823      RTC->WPR = 0x53;
000082  2053              MOVS     r0,#0x53
000084  6008              STR      r0,[r1,#0]
;;;824    
;;;825      /* Set Initialization mode */
;;;826      if (RTC_EnterInitMode() == ERROR)
000086  f7fffffe          BL       RTC_EnterInitMode
00008a  b908              CBNZ     r0,|L37.144|
;;;827      {
;;;828        status = ERROR;
00008c  2700              MOVS     r7,#0
00008e  e013              B        |L37.184|
                  |L37.144|
;;;829      } 
;;;830      else
;;;831      {
;;;832        /* Set the RTC_TR register */
;;;833        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
000090  480e              LDR      r0,|L37.204|
000092  4030              ANDS     r0,r0,r6
000094  490c              LDR      r1,|L37.200|
000096  3908              SUBS     r1,r1,#8
000098  6008              STR      r0,[r1,#0]
;;;834    
;;;835        /* Exit Initialization mode */
;;;836        RTC_ExitInitMode(); 
00009a  f7fffffe          BL       RTC_ExitInitMode
;;;837    
;;;838        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;839        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
00009e  480a              LDR      r0,|L37.200|
0000a0  6800              LDR      r0,[r0,#0]
0000a2  f0000020          AND      r0,r0,#0x20
0000a6  b930              CBNZ     r0,|L37.182|
;;;840        {
;;;841        if(RTC_WaitForSynchro() == ERROR)
0000a8  f7fffffe          BL       RTC_WaitForSynchro
0000ac  b908              CBNZ     r0,|L37.178|
;;;842        {
;;;843          status = ERROR;
0000ae  2700              MOVS     r7,#0
0000b0  e002              B        |L37.184|
                  |L37.178|
;;;844        }
;;;845        else
;;;846        {
;;;847          status = SUCCESS;
0000b2  2701              MOVS     r7,#1
0000b4  e000              B        |L37.184|
                  |L37.182|
;;;848        }
;;;849      }
;;;850        else
;;;851        {
;;;852          status = SUCCESS;
0000b6  2701              MOVS     r7,#1
                  |L37.184|
;;;853        }
;;;854      }
;;;855      /* Enable the write protection for RTC registers */
;;;856      RTC->WPR = 0xFF; 
0000b8  20ff              MOVS     r0,#0xff
0000ba  4903              LDR      r1,|L37.200|
0000bc  311c              ADDS     r1,r1,#0x1c
0000be  6008              STR      r0,[r1,#0]
;;;857        
;;;858      return status;
0000c0  4638              MOV      r0,r7
;;;859    }
0000c2  e8bd81f0          POP      {r4-r8,pc}
;;;860    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L37.200|
                          DCD      0x40002808
                  |L37.204|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_SetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_SetWakeUpCounter PROC
;;;1520     */
;;;1521   void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
000000  21ca              MOVS     r1,#0xca
;;;1522   {
;;;1523     /* Check the parameters */
;;;1524     assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
;;;1525     
;;;1526     /* Disable the write protection for RTC registers */
;;;1527     RTC->WPR = 0xCA;
000002  4a05              LDR      r2,|L38.24|
000004  6011              STR      r1,[r2,#0]
;;;1528     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1529     
;;;1530     /* Configure the Wakeup Timer counter */
;;;1531     RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
00000a  4903              LDR      r1,|L38.24|
00000c  3910              SUBS     r1,r1,#0x10
00000e  6008              STR      r0,[r1,#0]
;;;1532     
;;;1533     /* Enable the write protection for RTC registers */
;;;1534     RTC->WPR = 0xFF; 
000010  21ff              MOVS     r1,#0xff
000012  6011              STR      r1,[r2,#0]
;;;1535   }
000014  4770              BX       lr
;;;1536   
                          ENDP

000016  0000              DCW      0x0000
                  |L38.24|
                          DCD      0x40002824

                          AREA ||i.RTC_SmoothCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_SmoothCalibConfig PROC
;;;1905   */
;;;1906   ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
000000  b570              PUSH     {r4-r6,lr}
;;;1907                                     uint32_t RTC_SmoothCalibPlusPulses,
;;;1908                                     uint32_t RTC_SmouthCalibMinusPulsesValue)
;;;1909   {
000002  4603              MOV      r3,r0
;;;1910     ErrorStatus status = ERROR;
000004  2000              MOVS     r0,#0
;;;1911     uint32_t recalpfcount = 0;
000006  2400              MOVS     r4,#0
;;;1912   
;;;1913     /* Check the parameters */
;;;1914     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
;;;1915     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
;;;1916     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
;;;1917   
;;;1918     /* Disable the write protection for RTC registers */
;;;1919     RTC->WPR = 0xCA;
000008  25ca              MOVS     r5,#0xca
00000a  4e14              LDR      r6,|L39.92|
00000c  6035              STR      r5,[r6,#0]
;;;1920     RTC->WPR = 0x53;
00000e  2553              MOVS     r5,#0x53
000010  6035              STR      r5,[r6,#0]
;;;1921     
;;;1922     /* check if a calibration is pending*/
;;;1923     if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
000012  4d12              LDR      r5,|L39.92|
000014  3d18              SUBS     r5,r5,#0x18
000016  682d              LDR      r5,[r5,#0]
000018  f4053580          AND      r5,r5,#0x10000
00001c  b155              CBZ      r5,|L39.52|
;;;1924     {
;;;1925       /* wait until the Calibration is completed*/
;;;1926       while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
00001e  e000              B        |L39.34|
                  |L39.32|
;;;1927       {
;;;1928         recalpfcount++;
000020  1c64              ADDS     r4,r4,#1
                  |L39.34|
000022  4d0e              LDR      r5,|L39.92|
000024  3d18              SUBS     r5,r5,#0x18           ;1926
000026  682d              LDR      r5,[r5,#0]            ;1926
000028  f4053580          AND      r5,r5,#0x10000        ;1926
00002c  b115              CBZ      r5,|L39.52|
00002e  f5b43f00          CMP      r4,#0x20000           ;1926
000032  d1f5              BNE      |L39.32|
                  |L39.52|
;;;1929       }
;;;1930     }
;;;1931   
;;;1932     /* check if the calibration pending is completed or if there is no calibration operation at all*/
;;;1933     if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
000034  4d09              LDR      r5,|L39.92|
000036  3d18              SUBS     r5,r5,#0x18
000038  682d              LDR      r5,[r5,#0]
00003a  f4053580          AND      r5,r5,#0x10000
00003e  b93d              CBNZ     r5,|L39.80|
;;;1934     {
;;;1935       /* Configure the Smooth calibration settings */
;;;1936       RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
000040  ea430501          ORR      r5,r3,r1
000044  4315              ORRS     r5,r5,r2
000046  4e05              LDR      r6,|L39.92|
000048  3618              ADDS     r6,r6,#0x18
00004a  6035              STR      r5,[r6,#0]
;;;1937   
;;;1938       status = SUCCESS;
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L39.82|
                  |L39.80|
;;;1939     }
;;;1940     else
;;;1941     {
;;;1942       status = ERROR;
000050  2000              MOVS     r0,#0
                  |L39.82|
;;;1943     }
;;;1944   
;;;1945     /* Enable the write protection for RTC registers */
;;;1946     RTC->WPR = 0xFF;
000052  25ff              MOVS     r5,#0xff
000054  4e01              LDR      r6,|L39.92|
000056  6035              STR      r5,[r6,#0]
;;;1947     
;;;1948     return (ErrorStatus)(status);
;;;1949   }
000058  bd70              POP      {r4-r6,pc}
;;;1950   
                          ENDP

00005a  0000              DCW      0x0000
                  |L39.92|
                          DCD      0x40002824

                          AREA ||i.RTC_StructInit||, CODE, READONLY, ALIGN=1

                  RTC_StructInit PROC
;;;502      */
;;;503    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
000000  2100              MOVS     r1,#0
;;;504    {
;;;505      /* Initialize the RTC_HourFormat member */
;;;506      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
000002  6001              STR      r1,[r0,#0]
;;;507        
;;;508      /* Initialize the RTC_AsynchPrediv member */
;;;509      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
000004  217f              MOVS     r1,#0x7f
000006  6041              STR      r1,[r0,#4]
;;;510    
;;;511      /* Initialize the RTC_SynchPrediv member */
;;;512      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000008  21ff              MOVS     r1,#0xff
00000a  6081              STR      r1,[r0,#8]
;;;513    }
00000c  4770              BX       lr
;;;514    
                          ENDP


                          AREA ||i.RTC_SynchroShiftConfig||, CODE, READONLY, ALIGN=2

                  RTC_SynchroShiftConfig PROC
;;;2436   */
;;;2437   ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2438   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2439     ErrorStatus status = ERROR;
000006  2700              MOVS     r7,#0
;;;2440     uint32_t shpfcount = 0;
000008  2600              MOVS     r6,#0
;;;2441   
;;;2442     /* Check the parameters */
;;;2443     assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
;;;2444     assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
;;;2445   
;;;2446     /* Disable the write protection for RTC registers */
;;;2447     RTC->WPR = 0xCA;
00000a  20ca              MOVS     r0,#0xca
00000c  491a              LDR      r1,|L41.120|
00000e  6008              STR      r0,[r1,#0]
;;;2448     RTC->WPR = 0x53;
000010  2053              MOVS     r0,#0x53
000012  6008              STR      r0,[r1,#0]
;;;2449     
;;;2450     /* Check if a Shift is pending*/
;;;2451     if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
000014  4818              LDR      r0,|L41.120|
000016  3818              SUBS     r0,r0,#0x18
000018  6800              LDR      r0,[r0,#0]
00001a  f0000008          AND      r0,r0,#8
00001e  b150              CBZ      r0,|L41.54|
;;;2452     {
;;;2453       /* Wait until the shift is completed*/
;;;2454       while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
000020  e000              B        |L41.36|
                  |L41.34|
;;;2455       {
;;;2456         shpfcount++;
000022  1c76              ADDS     r6,r6,#1
                  |L41.36|
000024  4814              LDR      r0,|L41.120|
000026  3818              SUBS     r0,r0,#0x18           ;2454
000028  6800              LDR      r0,[r0,#0]            ;2454
00002a  f0000008          AND      r0,r0,#8              ;2454
00002e  b110              CBZ      r0,|L41.54|
000030  f5b65f80          CMP      r6,#0x1000            ;2454
000034  d1f5              BNE      |L41.34|
                  |L41.54|
;;;2457       }
;;;2458     }
;;;2459   
;;;2460     /* Check if the Shift pending is completed or if there is no Shift operation at all*/
;;;2461     if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
000036  4810              LDR      r0,|L41.120|
000038  3818              SUBS     r0,r0,#0x18
00003a  6800              LDR      r0,[r0,#0]
00003c  f0000008          AND      r0,r0,#8
000040  b998              CBNZ     r0,|L41.106|
;;;2462     {
;;;2463       /* check if the reference clock detection is disabled */
;;;2464       if((RTC->CR & RTC_CR_REFCKON) == RESET)
000042  480d              LDR      r0,|L41.120|
000044  381c              SUBS     r0,r0,#0x1c
000046  6800              LDR      r0,[r0,#0]
000048  f0000010          AND      r0,r0,#0x10
00004c  b958              CBNZ     r0,|L41.102|
;;;2465       {
;;;2466         /* Configure the Shift settings */
;;;2467         RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
00004e  ea450004          ORR      r0,r5,r4
000052  4909              LDR      r1,|L41.120|
000054  3108              ADDS     r1,r1,#8
000056  6008              STR      r0,[r1,#0]
;;;2468       
;;;2469         if(RTC_WaitForSynchro() == ERROR)
000058  f7fffffe          BL       RTC_WaitForSynchro
00005c  b908              CBNZ     r0,|L41.98|
;;;2470         {
;;;2471           status = ERROR;
00005e  2700              MOVS     r7,#0
000060  e004              B        |L41.108|
                  |L41.98|
;;;2472         }
;;;2473         else
;;;2474         {
;;;2475           status = SUCCESS;
000062  2701              MOVS     r7,#1
000064  e002              B        |L41.108|
                  |L41.102|
;;;2476         }
;;;2477       }
;;;2478       else
;;;2479       {
;;;2480         status = ERROR;
000066  2700              MOVS     r7,#0
000068  e000              B        |L41.108|
                  |L41.106|
;;;2481       }
;;;2482     }
;;;2483     else
;;;2484     {
;;;2485       status = ERROR;
00006a  2700              MOVS     r7,#0
                  |L41.108|
;;;2486     }
;;;2487   
;;;2488     /* Enable the write protection for RTC registers */
;;;2489     RTC->WPR = 0xFF;
00006c  20ff              MOVS     r0,#0xff
00006e  4902              LDR      r1,|L41.120|
000070  6008              STR      r0,[r1,#0]
;;;2490     
;;;2491     return (ErrorStatus)(status);
000072  4638              MOV      r0,r7
;;;2492   }
000074  bdf0              POP      {r4-r7,pc}
;;;2493   
                          ENDP

000076  0000              DCW      0x0000
                  |L41.120|
                          DCD      0x40002824

                          AREA ||i.RTC_TamperCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperCmd PROC
;;;2130     */
;;;2131   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
000000  b129              CBZ      r1,|L42.14|
;;;2132   {
;;;2133     /* Check the parameters */
;;;2134     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;2135     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2136     
;;;2137     if (NewState != DISABLE)
;;;2138     {
;;;2139       /* Enable the selected Tamper pin */
;;;2140       RTC->TAFCR |= (uint32_t)RTC_Tamper;
000002  4a06              LDR      r2,|L42.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L42.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L42.24|
                  |L42.14|
;;;2141     }
;;;2142     else
;;;2143     {
;;;2144       /* Disable the selected Tamper pin */
;;;2145       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
00000e  4a03              LDR      r2,|L42.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L42.28|
000016  601a              STR      r2,[r3,#0]
                  |L42.24|
;;;2146     }  
;;;2147   }
000018  4770              BX       lr
;;;2148   
                          ENDP

00001a  0000              DCW      0x0000
                  |L42.28|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperFilterConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperFilterConfig PROC
;;;2161     */
;;;2162   void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
000000  4905              LDR      r1,|L43.24|
;;;2163   {
;;;2164     /* Check the parameters */
;;;2165     assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
;;;2166      
;;;2167     /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
;;;2168     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
000002  6809              LDR      r1,[r1,#0]
000004  f42151c0          BIC      r1,r1,#0x1800
000008  4a03              LDR      r2,|L43.24|
00000a  6011              STR      r1,[r2,#0]
;;;2169   
;;;2170     /* Configure the RTC_TAFCR register */
;;;2171     RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;2172   }
000014  4770              BX       lr
;;;2173   
                          ENDP

000016  0000              DCW      0x0000
                  |L43.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinSelection PROC
;;;2362     */
;;;2363   void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
000000  4905              LDR      r1,|L44.24|
;;;2364   {
;;;2365     /* Check the parameters */
;;;2366     assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
;;;2367     
;;;2368     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
000002  6809              LDR      r1,[r1,#0]
000004  f4213180          BIC      r1,r1,#0x10000
000008  4a03              LDR      r2,|L44.24|
00000a  6011              STR      r1,[r2,#0]
;;;2369     RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;2370   }
000014  4770              BX       lr
;;;2371   
                          ENDP

000016  0000              DCW      0x0000
                  |L44.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinsPrechargeDuration||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinsPrechargeDuration PROC
;;;2218     */
;;;2219   void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
000000  4905              LDR      r1,|L45.24|
;;;2220   {
;;;2221     /* Check the parameters */
;;;2222     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
;;;2223      
;;;2224     /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
;;;2225     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
000002  6809              LDR      r1,[r1,#0]
000004  f42141c0          BIC      r1,r1,#0x6000
000008  4a03              LDR      r2,|L45.24|
00000a  6011              STR      r1,[r2,#0]
;;;2226   
;;;2227     /* Configure the RTC_TAFCR register */
;;;2228     RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;2229   }
000014  4770              BX       lr
;;;2230   
                          ENDP

000016  0000              DCW      0x0000
                  |L45.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPullUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperPullUpCmd PROC
;;;2261     */
;;;2262   void RTC_TamperPullUpCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L46.16|
;;;2263   {
;;;2264     /* Check the parameters */
;;;2265     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2266     
;;;2267    if (NewState != DISABLE)
;;;2268     {
;;;2269       /* Enable precharge of the selected Tamper pin */
;;;2270       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
000002  4907              LDR      r1,|L46.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4214100          BIC      r1,r1,#0x8000
00000a  4a05              LDR      r2,|L46.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L46.28|
                  |L46.16|
;;;2271     }
;;;2272     else
;;;2273     {
;;;2274       /* Disable precharge of the selected Tamper pin */
;;;2275       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
000010  4903              LDR      r1,|L46.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4414100          ORR      r1,r1,#0x8000
000018  4a01              LDR      r2,|L46.32|
00001a  6011              STR      r1,[r2,#0]
                  |L46.28|
;;;2276     } 
;;;2277   }
00001c  4770              BX       lr
;;;2278   
                          ENDP

00001e  0000              DCW      0x0000
                  |L46.32|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperSamplingFreqConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperSamplingFreqConfig PROC
;;;2195     */
;;;2196   void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
000000  4905              LDR      r1,|L47.24|
;;;2197   {
;;;2198     /* Check the parameters */
;;;2199     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
;;;2200    
;;;2201     /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
;;;2202     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
000002  6809              LDR      r1,[r1,#0]
000004  f42161e0          BIC      r1,r1,#0x700
000008  4a03              LDR      r2,|L47.24|
00000a  6011              STR      r1,[r2,#0]
;;;2203   
;;;2204     /* Configure the RTC_TAFCR register */
;;;2205     RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;2206   }
000014  4770              BX       lr
;;;2207   
                          ENDP

000016  0000              DCW      0x0000
                  |L47.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperTriggerConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperTriggerConfig PROC
;;;2104     */
;;;2105   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000000  b931              CBNZ     r1,|L48.16|
;;;2106   {
;;;2107     /* Check the parameters */
;;;2108     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;2109     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;2110    
;;;2111     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
;;;2112     {  
;;;2113       /* Configure the RTC_TAFCR register */
;;;2114       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
000002  4a07              LDR      r2,|L48.32|
000004  6812              LDR      r2,[r2,#0]
000006  ea220240          BIC      r2,r2,r0,LSL #1
00000a  4b05              LDR      r3,|L48.32|
00000c  601a              STR      r2,[r3,#0]
00000e  e005              B        |L48.28|
                  |L48.16|
;;;2115     }
;;;2116     else
;;;2117     { 
;;;2118       /* Configure the RTC_TAFCR register */
;;;2119       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
000010  4a03              LDR      r2,|L48.32|
000012  6812              LDR      r2,[r2,#0]
000014  ea420240          ORR      r2,r2,r0,LSL #1
000018  4b01              LDR      r3,|L48.32|
00001a  601a              STR      r2,[r3,#0]
                  |L48.28|
;;;2120     }  
;;;2121   }
00001c  4770              BX       lr
;;;2122   
                          ENDP

00001e  0000              DCW      0x0000
                  |L48.32|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampCmd PROC
;;;1981     */
;;;1982   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1983   {
000002  460a              MOV      r2,r1
;;;1984     uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;1985   
;;;1986     /* Check the parameters */
;;;1987     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1988     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1989   
;;;1990     /* Get the RTC_CR register and clear the bits to be configured */
;;;1991     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000006  4b0b              LDR      r3,|L49.52|
000008  681b              LDR      r3,[r3,#0]
00000a  f6400408          MOV      r4,#0x808
00000e  ea230104          BIC      r1,r3,r4
;;;1992   
;;;1993     /* Get the new configuration */
;;;1994     if (NewState != DISABLE)
000012  b11a              CBZ      r2,|L49.28|
;;;1995     {
;;;1996       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
000014  f4406300          ORR      r3,r0,#0x800
000018  4319              ORRS     r1,r1,r3
00001a  e000              B        |L49.30|
                  |L49.28|
;;;1997     }
;;;1998     else
;;;1999     {
;;;2000       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
00001c  4301              ORRS     r1,r1,r0
                  |L49.30|
;;;2001     }
;;;2002   
;;;2003     /* Disable the write protection for RTC registers */
;;;2004     RTC->WPR = 0xCA;
00001e  23ca              MOVS     r3,#0xca
000020  4c04              LDR      r4,|L49.52|
000022  341c              ADDS     r4,r4,#0x1c
000024  6023              STR      r3,[r4,#0]
;;;2005     RTC->WPR = 0x53;
000026  2353              MOVS     r3,#0x53
000028  6023              STR      r3,[r4,#0]
;;;2006   
;;;2007     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;2008     RTC->CR = (uint32_t)tmpreg;
00002a  4b02              LDR      r3,|L49.52|
00002c  6019              STR      r1,[r3,#0]
;;;2009   
;;;2010     /* Enable the write protection for RTC registers */
;;;2011     RTC->WPR = 0xFF; 
00002e  23ff              MOVS     r3,#0xff
000030  6023              STR      r3,[r4,#0]
;;;2012   }
000032  bd10              POP      {r4,pc}
;;;2013   
                          ENDP

                  |L49.52|
                          DCD      0x40002808

                          AREA ||i.RTC_TimeStampOnTamperDetectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampOnTamperDetectionCmd PROC
;;;2238     */
;;;2239   void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L50.16|
;;;2240   {
;;;2241     /* Check the parameters */
;;;2242     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2243      
;;;2244     if (NewState != DISABLE)
;;;2245     {
;;;2246       /* Save timestamp on tamper detection event */
;;;2247       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
000002  4907              LDR      r1,|L50.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410180          ORR      r1,r1,#0x80
00000a  4a05              LDR      r2,|L50.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L50.28|
                  |L50.16|
;;;2248     }
;;;2249     else
;;;2250     {
;;;2251       /* Tamper detection does not cause a timestamp to be saved */
;;;2252       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
000010  4903              LDR      r1,|L50.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210180          BIC      r1,r1,#0x80
000018  4a01              LDR      r2,|L50.32|
00001a  6011              STR      r1,[r2,#0]
                  |L50.28|
;;;2253     }
;;;2254   }
00001c  4770              BX       lr
;;;2255   
                          ENDP

00001e  0000              DCW      0x0000
                  |L50.32|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampPinSelection PROC
;;;2379     */
;;;2380   void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
000000  4905              LDR      r1,|L51.24|
;;;2381   {
;;;2382     /* Check the parameters */
;;;2383     assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;2384     
;;;2385     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
000002  6809              LDR      r1,[r1,#0]
000004  f4213100          BIC      r1,r1,#0x20000
000008  4a03              LDR      r2,|L51.24|
00000a  6011              STR      r1,[r2,#0]
;;;2386     RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;2387   }
000014  4770              BX       lr
;;;2388   
                          ENDP

000016  0000              DCW      0x0000
                  |L51.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStructInit||, CODE, READONLY, ALIGN=1

                  RTC_TimeStructInit PROC
;;;867      */
;;;868    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000000  2100              MOVS     r1,#0
;;;869    {
;;;870      /* Time = 00h:00min:00sec */
;;;871      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;872      RTC_TimeStruct->RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;873      RTC_TimeStruct->RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;874      RTC_TimeStruct->RTC_Seconds = 0; 
000008  7081              STRB     r1,[r0,#2]
;;;875    }
00000a  4770              BX       lr
;;;876    
                          ENDP


                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;618      */
;;;619    ErrorStatus RTC_WaitForSynchro(void)
000000  b508              PUSH     {r3,lr}
;;;620    {
;;;621      __IO uint32_t synchrocounter = 0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;622      ErrorStatus status = ERROR;
000006  2000              MOVS     r0,#0
;;;623      uint32_t synchrostatus = 0x00;
000008  2100              MOVS     r1,#0
;;;624    
;;;625      /* Disable the write protection for RTC registers */
;;;626      RTC->WPR = 0xCA;
00000a  22ca              MOVS     r2,#0xca
00000c  4b13              LDR      r3,|L53.92|
00000e  601a              STR      r2,[r3,#0]
;;;627      RTC->WPR = 0x53;
000010  2253              MOVS     r2,#0x53
000012  601a              STR      r2,[r3,#0]
;;;628        
;;;629      /* Clear RSF flag */
;;;630      RTC->ISR &= (uint32_t)RTC_RSF_MASK;
000014  4a11              LDR      r2,|L53.92|
000016  3a18              SUBS     r2,r2,#0x18
000018  6812              LDR      r2,[r2,#0]
00001a  f02202a0          BIC      r2,r2,#0xa0
00001e  4b0f              LDR      r3,|L53.92|
000020  3b18              SUBS     r3,r3,#0x18
000022  601a              STR      r2,[r3,#0]
;;;631        
;;;632      /* Wait the registers to be synchronised */
;;;633      do
000024  bf00              NOP      
                  |L53.38|
;;;634      {
;;;635        synchrostatus = RTC->ISR & RTC_ISR_RSF;
000026  4a0d              LDR      r2,|L53.92|
000028  3a18              SUBS     r2,r2,#0x18
00002a  6812              LDR      r2,[r2,#0]
00002c  f0020120          AND      r1,r2,#0x20
;;;636        synchrocounter++;  
000030  9a00              LDR      r2,[sp,#0]
000032  1c52              ADDS     r2,r2,#1
000034  9200              STR      r2,[sp,#0]
;;;637      } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
000036  9a00              LDR      r2,[sp,#0]
000038  f5b23f00          CMP      r2,#0x20000
00003c  d001              BEQ      |L53.66|
00003e  2900              CMP      r1,#0
000040  d0f1              BEQ      |L53.38|
                  |L53.66|
;;;638        
;;;639      if ((RTC->ISR & RTC_ISR_RSF) != RESET)
000042  4a06              LDR      r2,|L53.92|
000044  3a18              SUBS     r2,r2,#0x18
000046  6812              LDR      r2,[r2,#0]
000048  f0020220          AND      r2,r2,#0x20
00004c  b10a              CBZ      r2,|L53.82|
;;;640      {
;;;641        status = SUCCESS;
00004e  2001              MOVS     r0,#1
000050  e000              B        |L53.84|
                  |L53.82|
;;;642      }
;;;643      else
;;;644      {
;;;645        status = ERROR;
000052  2000              MOVS     r0,#0
                  |L53.84|
;;;646      }        
;;;647    
;;;648      /* Enable the write protection for RTC registers */
;;;649      RTC->WPR = 0xFF; 
000054  22ff              MOVS     r2,#0xff
000056  4b01              LDR      r3,|L53.92|
000058  601a              STR      r2,[r3,#0]
;;;650        
;;;651      return (status); 
;;;652    }
00005a  bd08              POP      {r3,pc}
;;;653    
                          ENDP

                  |L53.92|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpClockConfig||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpClockConfig PROC
;;;1493     */
;;;1494   void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
000000  21ca              MOVS     r1,#0xca
;;;1495   {
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
;;;1498   
;;;1499     /* Disable the write protection for RTC registers */
;;;1500     RTC->WPR = 0xCA;
000002  4a0a              LDR      r2,|L54.44|
000004  6011              STR      r1,[r2,#0]
;;;1501     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1502   
;;;1503     /* Clear the Wakeup Timer clock source bits in CR register */
;;;1504     RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
00000a  4908              LDR      r1,|L54.44|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  6809              LDR      r1,[r1,#0]
000010  f0210107          BIC      r1,r1,#7
000014  4a05              LDR      r2,|L54.44|
000016  3a1c              SUBS     r2,r2,#0x1c
000018  6011              STR      r1,[r2,#0]
;;;1505   
;;;1506     /* Configure the clock source */
;;;1507     RTC->CR |= (uint32_t)RTC_WakeUpClock;
00001a  4611              MOV      r1,r2
00001c  6809              LDR      r1,[r1,#0]
00001e  4301              ORRS     r1,r1,r0
000020  6011              STR      r1,[r2,#0]
;;;1508     
;;;1509     /* Enable the write protection for RTC registers */
;;;1510     RTC->WPR = 0xFF; 
000022  21ff              MOVS     r1,#0xff
000024  4a01              LDR      r2,|L54.44|
000026  6011              STR      r1,[r2,#0]
;;;1511   }
000028  4770              BX       lr
;;;1512   
                          ENDP

00002a  0000              DCW      0x0000
                  |L54.44|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpCmd PROC
;;;1553     */
;;;1554   ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
000000  b518              PUSH     {r3,r4,lr}
;;;1555   {
000002  4601              MOV      r1,r0
;;;1556     __IO uint32_t wutcounter = 0x00;
000004  2300              MOVS     r3,#0
000006  9300              STR      r3,[sp,#0]
;;;1557     uint32_t wutwfstatus = 0x00;
000008  2200              MOVS     r2,#0
;;;1558     ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;1559     
;;;1560     /* Check the parameters */
;;;1561     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1562   
;;;1563     /* Disable the write protection for RTC registers */
;;;1564     RTC->WPR = 0xCA;
00000c  23ca              MOVS     r3,#0xca
00000e  4c19              LDR      r4,|L55.116|
000010  6023              STR      r3,[r4,#0]
;;;1565     RTC->WPR = 0x53;
000012  2353              MOVS     r3,#0x53
000014  6023              STR      r3,[r4,#0]
;;;1566   
;;;1567     if (NewState != DISABLE)
000016  b149              CBZ      r1,|L55.44|
;;;1568     {
;;;1569       /* Enable the Wakeup Timer */
;;;1570       RTC->CR |= (uint32_t)RTC_CR_WUTE;
000018  4b16              LDR      r3,|L55.116|
00001a  3b1c              SUBS     r3,r3,#0x1c
00001c  681b              LDR      r3,[r3,#0]
00001e  f4436380          ORR      r3,r3,#0x400
000022  4c14              LDR      r4,|L55.116|
000024  3c1c              SUBS     r4,r4,#0x1c
000026  6023              STR      r3,[r4,#0]
;;;1571       status = SUCCESS;    
000028  2001              MOVS     r0,#1
00002a  e01f              B        |L55.108|
                  |L55.44|
;;;1572     }
;;;1573     else
;;;1574     {
;;;1575       /* Disable the Wakeup Timer */
;;;1576       RTC->CR &= (uint32_t)~RTC_CR_WUTE;
00002c  4b11              LDR      r3,|L55.116|
00002e  3b1c              SUBS     r3,r3,#0x1c
000030  681b              LDR      r3,[r3,#0]
000032  f4236380          BIC      r3,r3,#0x400
000036  4c0f              LDR      r4,|L55.116|
000038  3c1c              SUBS     r4,r4,#0x1c
00003a  6023              STR      r3,[r4,#0]
;;;1577       /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;1578       do
00003c  bf00              NOP      
                  |L55.62|
;;;1579       {
;;;1580         wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
00003e  4b0d              LDR      r3,|L55.116|
000040  3b18              SUBS     r3,r3,#0x18
000042  681b              LDR      r3,[r3,#0]
000044  f0030204          AND      r2,r3,#4
;;;1581         wutcounter++;  
000048  9b00              LDR      r3,[sp,#0]
00004a  1c5b              ADDS     r3,r3,#1
00004c  9300              STR      r3,[sp,#0]
;;;1582       } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
00004e  9b00              LDR      r3,[sp,#0]
000050  f5b33f80          CMP      r3,#0x10000
000054  d001              BEQ      |L55.90|
000056  2a00              CMP      r2,#0
000058  d0f1              BEQ      |L55.62|
                  |L55.90|
;;;1583       
;;;1584       if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
00005a  4b06              LDR      r3,|L55.116|
00005c  3b18              SUBS     r3,r3,#0x18
00005e  681b              LDR      r3,[r3,#0]
000060  f0030304          AND      r3,r3,#4
000064  b90b              CBNZ     r3,|L55.106|
;;;1585       {
;;;1586         status = ERROR;
000066  2000              MOVS     r0,#0
000068  e000              B        |L55.108|
                  |L55.106|
;;;1587       }
;;;1588       else
;;;1589       {
;;;1590         status = SUCCESS;
00006a  2001              MOVS     r0,#1
                  |L55.108|
;;;1591       }    
;;;1592     }
;;;1593   
;;;1594     /* Enable the write protection for RTC registers */
;;;1595     RTC->WPR = 0xFF; 
00006c  23ff              MOVS     r3,#0xff
00006e  4c01              LDR      r4,|L55.116|
000070  6023              STR      r3,[r4,#0]
;;;1596     
;;;1597     return status;
;;;1598   }
000072  bd18              POP      {r3,r4,pc}
;;;1599   
                          ENDP

                  |L55.116|
                          DCD      0x40002824

                          AREA ||i.RTC_WriteBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_WriteBackupRegister PROC
;;;2302     */
;;;2303   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
000000  b508              PUSH     {r3,lr}
;;;2304   {
;;;2305     __IO uint32_t tmp = 0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;2306     
;;;2307     /* Check the parameters */
;;;2308     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2309   
;;;2310     tmp = RTC_BASE + 0x50;
000006  4a04              LDR      r2,|L56.24|
000008  9200              STR      r2,[sp,#0]
;;;2311     tmp += (RTC_BKP_DR * 4);
00000a  9a00              LDR      r2,[sp,#0]
00000c  eb020280          ADD      r2,r2,r0,LSL #2
000010  9200              STR      r2,[sp,#0]
;;;2312   
;;;2313     /* Write the specified register */
;;;2314     *(__IO uint32_t *)tmp = (uint32_t)Data;
000012  9a00              LDR      r2,[sp,#0]
000014  6011              STR      r1,[r2,#0]
;;;2315   }
000016  bd08              POP      {r3,pc}
;;;2316   
                          ENDP

                  |L56.24|
                          DCD      0x40002850

                          AREA ||i.RTC_WriteProtectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_WriteProtectionCmd PROC
;;;524      */
;;;525    void RTC_WriteProtectionCmd(FunctionalState NewState)
000000  b118              CBZ      r0,|L57.10|
;;;526    {
;;;527      /* Check the parameters */
;;;528      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;529        
;;;530      if (NewState != DISABLE)
;;;531      {
;;;532        /* Enable the write protection for RTC registers */
;;;533        RTC->WPR = 0xFF;   
000002  21ff              MOVS     r1,#0xff
000004  4a04              LDR      r2,|L57.24|
000006  6011              STR      r1,[r2,#0]
000008  e004              B        |L57.20|
                  |L57.10|
;;;534      }
;;;535      else
;;;536      {
;;;537        /* Disable the write protection for RTC registers */
;;;538        RTC->WPR = 0xCA;
00000a  21ca              MOVS     r1,#0xca
00000c  4a02              LDR      r2,|L57.24|
00000e  6011              STR      r1,[r2,#0]
;;;539        RTC->WPR = 0x53;    
000010  2153              MOVS     r1,#0x53
000012  6011              STR      r1,[r2,#0]
                  |L57.20|
;;;540      }
;;;541    }
000014  4770              BX       lr
;;;542    
                          ENDP

000016  0000              DCW      0x0000
                  |L57.24|
                          DCD      0x40002824

;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___15_stm32f4xx_rtc_c_81435638____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REVSH|
#line 153
|__asm___15_stm32f4xx_rtc_c_81435638____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____RRX|
#line 328
|__asm___15_stm32f4xx_rtc_c_81435638____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
