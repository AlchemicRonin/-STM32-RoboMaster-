; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_cryp_aes.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_cryp_aes.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_cryp_aes.crf ..\FWLIB\src\stm32f4xx_cryp_aes.c]
                          THUMB

                          AREA ||i.CRYP_AES_CBC||, CODE, READONLY, ALIGN=1

                  CRYP_AES_CBC PROC
;;;293      */
;;;294    ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;295                             uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
;;;296                             uint8_t *Output)
;;;297    {
000004  b093              SUB      sp,sp,#0x4c
000006  4681              MOV      r9,r0
000008  468a              MOV      r10,r1
00000a  4693              MOV      r11,r2
;;;298      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;299      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;300      CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
;;;301      __IO uint32_t counter = 0;
00000c  2000              MOVS     r0,#0
00000e  9002              STR      r0,[sp,#8]
;;;302      uint32_t busystatus = 0;
000010  4680              MOV      r8,r0
;;;303      ErrorStatus status = SUCCESS;
000012  2001              MOVS     r0,#1
000014  9001              STR      r0,[sp,#4]
;;;304      uint32_t keyaddr    = (uint32_t)Key;
000016  465c              MOV      r4,r11
;;;305      uint32_t inputaddr  = (uint32_t)Input;
000018  9d20              LDR      r5,[sp,#0x80]
;;;306      uint32_t outputaddr = (uint32_t)Output;
00001a  9e22              LDR      r6,[sp,#0x88]
;;;307      uint32_t ivaddr = (uint32_t)InitVectors;
00001c  4657              MOV      r7,r10
;;;308      uint32_t i = 0;
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
;;;309    
;;;310      /* Crypto structures initialisation*/
;;;311      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
000022  a807              ADD      r0,sp,#0x1c
000024  f7fffffe          BL       CRYP_KeyStructInit
;;;312    
;;;313      switch(Keysize)
000028  9816              LDR      r0,[sp,#0x58]
00002a  2880              CMP      r0,#0x80
00002c  d005              BEQ      |L1.58|
00002e  28c0              CMP      r0,#0xc0
000030  d015              BEQ      |L1.94|
000032  f5b07f80          CMP      r0,#0x100
000036  d150              BNE      |L1.218|
000038  e02c              B        |L1.148|
                  |L1.58|
;;;314      {
;;;315        case 128:
;;;316        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
00003a  2000              MOVS     r0,#0
00003c  9012              STR      r0,[sp,#0x48]
;;;317        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
00003e  6820              LDR      r0,[r4,#0]
000040  ba00              REV      r0,r0
000042  900b              STR      r0,[sp,#0x2c]
;;;318        keyaddr+=4;
000044  1d24              ADDS     r4,r4,#4
;;;319        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000046  6820              LDR      r0,[r4,#0]
000048  ba00              REV      r0,r0
00004a  900c              STR      r0,[sp,#0x30]
;;;320        keyaddr+=4;
00004c  1d24              ADDS     r4,r4,#4
;;;321        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
00004e  6820              LDR      r0,[r4,#0]
000050  ba00              REV      r0,r0
000052  900d              STR      r0,[sp,#0x34]
;;;322        keyaddr+=4;
000054  1d24              ADDS     r4,r4,#4
;;;323        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000056  6820              LDR      r0,[r4,#0]
000058  ba00              REV      r0,r0
00005a  900e              STR      r0,[sp,#0x38]
;;;324        break;
00005c  e03e              B        |L1.220|
                  |L1.94|
;;;325        case 192:
;;;326        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
00005e  f44f7080          MOV      r0,#0x100
000062  9012              STR      r0,[sp,#0x48]
;;;327        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000064  6820              LDR      r0,[r4,#0]
000066  ba00              REV      r0,r0
000068  9009              STR      r0,[sp,#0x24]
;;;328        keyaddr+=4;
00006a  1d24              ADDS     r4,r4,#4
;;;329        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00006c  6820              LDR      r0,[r4,#0]
00006e  ba00              REV      r0,r0
000070  900a              STR      r0,[sp,#0x28]
;;;330        keyaddr+=4;
000072  1d24              ADDS     r4,r4,#4
;;;331        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000074  6820              LDR      r0,[r4,#0]
000076  ba00              REV      r0,r0
000078  900b              STR      r0,[sp,#0x2c]
;;;332        keyaddr+=4;
00007a  1d24              ADDS     r4,r4,#4
;;;333        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
00007c  6820              LDR      r0,[r4,#0]
00007e  ba00              REV      r0,r0
000080  900c              STR      r0,[sp,#0x30]
;;;334        keyaddr+=4;
000082  1d24              ADDS     r4,r4,#4
;;;335        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
000084  6820              LDR      r0,[r4,#0]
000086  ba00              REV      r0,r0
000088  900d              STR      r0,[sp,#0x34]
;;;336        keyaddr+=4;
00008a  1d24              ADDS     r4,r4,#4
;;;337        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
00008c  6820              LDR      r0,[r4,#0]
00008e  ba00              REV      r0,r0
000090  900e              STR      r0,[sp,#0x38]
;;;338        break;
000092  e023              B        |L1.220|
                  |L1.148|
;;;339        case 256:
;;;340        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000094  f44f7000          MOV      r0,#0x200
000098  9012              STR      r0,[sp,#0x48]
;;;341        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
00009a  6820              LDR      r0,[r4,#0]
00009c  ba00              REV      r0,r0
00009e  9007              STR      r0,[sp,#0x1c]
;;;342        keyaddr+=4;
0000a0  1d24              ADDS     r4,r4,#4
;;;343        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
0000a2  6820              LDR      r0,[r4,#0]
0000a4  ba00              REV      r0,r0
0000a6  9008              STR      r0,[sp,#0x20]
;;;344        keyaddr+=4;
0000a8  1d24              ADDS     r4,r4,#4
;;;345        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
0000aa  6820              LDR      r0,[r4,#0]
0000ac  ba00              REV      r0,r0
0000ae  9009              STR      r0,[sp,#0x24]
;;;346        keyaddr+=4;
0000b0  1d24              ADDS     r4,r4,#4
;;;347        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
0000b2  6820              LDR      r0,[r4,#0]
0000b4  ba00              REV      r0,r0
0000b6  900a              STR      r0,[sp,#0x28]
;;;348        keyaddr+=4;
0000b8  1d24              ADDS     r4,r4,#4
;;;349        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
0000ba  6820              LDR      r0,[r4,#0]
0000bc  ba00              REV      r0,r0
0000be  900b              STR      r0,[sp,#0x2c]
;;;350        keyaddr+=4;
0000c0  1d24              ADDS     r4,r4,#4
;;;351        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
0000c2  6820              LDR      r0,[r4,#0]
0000c4  ba00              REV      r0,r0
0000c6  900c              STR      r0,[sp,#0x30]
;;;352        keyaddr+=4;
0000c8  1d24              ADDS     r4,r4,#4
;;;353        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
0000ca  6820              LDR      r0,[r4,#0]
0000cc  ba00              REV      r0,r0
0000ce  900d              STR      r0,[sp,#0x34]
;;;354        keyaddr+=4;
0000d0  1d24              ADDS     r4,r4,#4
;;;355        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
0000d2  6820              LDR      r0,[r4,#0]
0000d4  ba00              REV      r0,r0
0000d6  900e              STR      r0,[sp,#0x38]
;;;356        break;
0000d8  e000              B        |L1.220|
                  |L1.218|
;;;357        default:
;;;358        break;
0000da  bf00              NOP      
                  |L1.220|
0000dc  bf00              NOP                            ;324
;;;359      }
;;;360    
;;;361      /* CRYP Initialization Vectors */
;;;362      AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
0000de  6838              LDR      r0,[r7,#0]
0000e0  ba00              REV      r0,r0
0000e2  9003              STR      r0,[sp,#0xc]
;;;363      ivaddr+=4;
0000e4  1d3f              ADDS     r7,r7,#4
;;;364      AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
0000e6  6838              LDR      r0,[r7,#0]
0000e8  ba00              REV      r0,r0
0000ea  9004              STR      r0,[sp,#0x10]
;;;365      ivaddr+=4;
0000ec  1d3f              ADDS     r7,r7,#4
;;;366      AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
0000ee  6838              LDR      r0,[r7,#0]
0000f0  ba00              REV      r0,r0
0000f2  9005              STR      r0,[sp,#0x14]
;;;367      ivaddr+=4;
0000f4  1d3f              ADDS     r7,r7,#4
;;;368      AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
0000f6  6838              LDR      r0,[r7,#0]
0000f8  ba00              REV      r0,r0
0000fa  9006              STR      r0,[sp,#0x18]
;;;369    
;;;370    
;;;371      /*------------------ AES Decryption ------------------*/
;;;372      if(Mode == MODE_DECRYPT) /* AES decryption */
0000fc  f1b90f00          CMP      r9,#0
000100  d128              BNE      |L1.340|
;;;373      {
;;;374        /* Flush IN/OUT FIFOs */
;;;375        CRYP_FIFOFlush();
000102  f7fffffe          BL       CRYP_FIFOFlush
;;;376    
;;;377        /* Crypto Init for Key preparation for decryption process */
;;;378        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
000106  2004              MOVS     r0,#4
000108  900f              STR      r0,[sp,#0x3c]
;;;379        AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
00010a  2038              MOVS     r0,#0x38
00010c  9010              STR      r0,[sp,#0x40]
;;;380        AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
00010e  2000              MOVS     r0,#0
000110  9011              STR      r0,[sp,#0x44]
;;;381    
;;;382        CRYP_Init(&AES_CRYP_InitStructure);
000112  a80f              ADD      r0,sp,#0x3c
000114  f7fffffe          BL       CRYP_Init
;;;383    
;;;384        /* Key Initialisation */
;;;385        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
000118  a807              ADD      r0,sp,#0x1c
00011a  f7fffffe          BL       CRYP_KeyInit
;;;386    
;;;387        /* Enable Crypto processor */
;;;388        CRYP_Cmd(ENABLE);
00011e  2001              MOVS     r0,#1
000120  f7fffffe          BL       CRYP_Cmd
;;;389    
;;;390        /* wait until the Busy flag is RESET */
;;;391        do
000124  bf00              NOP      
                  |L1.294|
;;;392        {
;;;393          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
000126  2010              MOVS     r0,#0x10
000128  f7fffffe          BL       CRYP_GetFlagStatus
00012c  4680              MOV      r8,r0
;;;394          counter++;
00012e  9802              LDR      r0,[sp,#8]
000130  1c40              ADDS     r0,r0,#1
000132  9002              STR      r0,[sp,#8]
;;;395        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
000134  9802              LDR      r0,[sp,#8]
000136  f5b03f80          CMP      r0,#0x10000
00013a  d002              BEQ      |L1.322|
00013c  f1b80f00          CMP      r8,#0
000140  d1f1              BNE      |L1.294|
                  |L1.322|
;;;396    
;;;397        if (busystatus != RESET)
000142  f1b80f00          CMP      r8,#0
000146  d002              BEQ      |L1.334|
;;;398       {
;;;399           status = ERROR;
000148  2000              MOVS     r0,#0
00014a  9001              STR      r0,[sp,#4]
00014c  e007              B        |L1.350|
                  |L1.334|
;;;400        }
;;;401        else
;;;402        {
;;;403          /* Crypto Init for decryption process */  
;;;404          AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
00014e  2004              MOVS     r0,#4
000150  900f              STR      r0,[sp,#0x3c]
000152  e004              B        |L1.350|
                  |L1.340|
;;;405        }
;;;406      }
;;;407      /*------------------ AES Encryption ------------------*/
;;;408      else /* AES encryption */
;;;409      {
;;;410        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
000154  a807              ADD      r0,sp,#0x1c
000156  f7fffffe          BL       CRYP_KeyInit
;;;411    
;;;412        /* Crypto Init for Encryption process */
;;;413        AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
00015a  2000              MOVS     r0,#0
00015c  900f              STR      r0,[sp,#0x3c]
                  |L1.350|
;;;414      }
;;;415      AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
00015e  2028              MOVS     r0,#0x28
000160  9010              STR      r0,[sp,#0x40]
;;;416      AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
000162  2080              MOVS     r0,#0x80
000164  9011              STR      r0,[sp,#0x44]
;;;417      CRYP_Init(&AES_CRYP_InitStructure);
000166  a80f              ADD      r0,sp,#0x3c
000168  f7fffffe          BL       CRYP_Init
;;;418    
;;;419      /* CRYP Initialization Vectors */
;;;420      CRYP_IVInit(&AES_CRYP_IVInitStructure);
00016c  a803              ADD      r0,sp,#0xc
00016e  f7fffffe          BL       CRYP_IVInit
;;;421    
;;;422      /* Flush IN/OUT FIFOs */
;;;423      CRYP_FIFOFlush();
000172  f7fffffe          BL       CRYP_FIFOFlush
;;;424    
;;;425      /* Enable Crypto processor */
;;;426      CRYP_Cmd(ENABLE);
000176  2001              MOVS     r0,#1
000178  f7fffffe          BL       CRYP_Cmd
;;;427    
;;;428      if(CRYP_GetCmdStatus() == DISABLE)
00017c  f7fffffe          BL       CRYP_GetCmdStatus
000180  b918              CBNZ     r0,|L1.394|
;;;429      {
;;;430        /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;431           the CRYP peripheral (please check the device sales type. */
;;;432        return(ERROR);
000182  2000              MOVS     r0,#0
                  |L1.388|
;;;433      }
;;;434      
;;;435      for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
;;;436      {
;;;437    
;;;438        /* Write the Input block in the IN FIFO */
;;;439        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;440        inputaddr+=4;
;;;441        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;442        inputaddr+=4;
;;;443        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;444        inputaddr+=4;
;;;445        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;446        inputaddr+=4;
;;;447        /* Wait until the complete message has been processed */
;;;448        counter = 0;
;;;449        do
;;;450        {
;;;451          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;452          counter++;
;;;453        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;454    
;;;455        if (busystatus != RESET)
;;;456       {
;;;457           status = ERROR;
;;;458        }
;;;459        else
;;;460        {
;;;461    
;;;462          /* Read the Output block from the Output FIFO */
;;;463          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;464          outputaddr+=4;
;;;465          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;466          outputaddr+=4;
;;;467          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;468          outputaddr+=4;
;;;469          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;470          outputaddr+=4;
;;;471        }
;;;472      }
;;;473    
;;;474      /* Disable Crypto */
;;;475      CRYP_Cmd(DISABLE);
;;;476    
;;;477      return status;
;;;478    }
000184  b017              ADD      sp,sp,#0x5c
000186  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.394|
00018a  2000              MOVS     r0,#0                 ;435
00018c  9000              STR      r0,[sp,#0]            ;435
00018e  e039              B        |L1.516|
                  |L1.400|
000190  6828              LDR      r0,[r5,#0]            ;439
000192  f7fffffe          BL       CRYP_DataIn
000196  1d2d              ADDS     r5,r5,#4              ;440
000198  6828              LDR      r0,[r5,#0]            ;441
00019a  f7fffffe          BL       CRYP_DataIn
00019e  1d2d              ADDS     r5,r5,#4              ;442
0001a0  6828              LDR      r0,[r5,#0]            ;443
0001a2  f7fffffe          BL       CRYP_DataIn
0001a6  1d2d              ADDS     r5,r5,#4              ;444
0001a8  6828              LDR      r0,[r5,#0]            ;445
0001aa  f7fffffe          BL       CRYP_DataIn
0001ae  1d2d              ADDS     r5,r5,#4              ;446
0001b0  2000              MOVS     r0,#0                 ;448
0001b2  9002              STR      r0,[sp,#8]            ;448
0001b4  bf00              NOP                            ;449
                  |L1.438|
0001b6  2010              MOVS     r0,#0x10              ;451
0001b8  f7fffffe          BL       CRYP_GetFlagStatus
0001bc  4680              MOV      r8,r0                 ;451
0001be  9802              LDR      r0,[sp,#8]            ;452
0001c0  1c40              ADDS     r0,r0,#1              ;452
0001c2  9002              STR      r0,[sp,#8]            ;452
0001c4  9802              LDR      r0,[sp,#8]            ;453
0001c6  f5b03f80          CMP      r0,#0x10000           ;453
0001ca  d002              BEQ      |L1.466|
0001cc  f1b80f00          CMP      r8,#0                 ;453
0001d0  d1f1              BNE      |L1.438|
                  |L1.466|
0001d2  f1b80f00          CMP      r8,#0                 ;455
0001d6  d002              BEQ      |L1.478|
0001d8  2000              MOVS     r0,#0                 ;457
0001da  9001              STR      r0,[sp,#4]            ;457
0001dc  e00f              B        |L1.510|
                  |L1.478|
0001de  f7fffffe          BL       CRYP_DataOut
0001e2  6030              STR      r0,[r6,#0]            ;463
0001e4  1d36              ADDS     r6,r6,#4              ;464
0001e6  f7fffffe          BL       CRYP_DataOut
0001ea  6030              STR      r0,[r6,#0]            ;465
0001ec  1d36              ADDS     r6,r6,#4              ;466
0001ee  f7fffffe          BL       CRYP_DataOut
0001f2  6030              STR      r0,[r6,#0]            ;467
0001f4  1d36              ADDS     r6,r6,#4              ;468
0001f6  f7fffffe          BL       CRYP_DataOut
0001fa  6030              STR      r0,[r6,#0]            ;469
0001fc  1d36              ADDS     r6,r6,#4              ;470
                  |L1.510|
0001fe  9800              LDR      r0,[sp,#0]            ;435
000200  3010              ADDS     r0,r0,#0x10           ;435
000202  9000              STR      r0,[sp,#0]            ;435
                  |L1.516|
000204  9921              LDR      r1,[sp,#0x84]         ;435
000206  9800              LDR      r0,[sp,#0]            ;435
000208  4288              CMP      r0,r1                 ;435
00020a  d202              BCS      |L1.530|
00020c  9801              LDR      r0,[sp,#4]            ;435
00020e  2800              CMP      r0,#0                 ;435
000210  d1be              BNE      |L1.400|
                  |L1.530|
000212  2000              MOVS     r0,#0                 ;475
000214  f7fffffe          BL       CRYP_Cmd
000218  9801              LDR      r0,[sp,#4]            ;477
00021a  e7b3              B        |L1.388|
;;;479    
                          ENDP


                          AREA ||i.CRYP_AES_CCM||, CODE, READONLY, ALIGN=1

                  CRYP_AES_CCM PROC
;;;1134     */
;;;1135   ErrorStatus CRYP_AES_CCM(uint8_t Mode, 
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1136                            uint8_t* Nonce, uint32_t NonceSize,
;;;1137                            uint8_t *Key, uint16_t Keysize,
;;;1138                            uint8_t *Input, uint32_t ILength,
;;;1139                            uint8_t *Header, uint32_t HLength, uint8_t *HBuffer,
;;;1140                            uint8_t *Output,
;;;1141                            uint8_t *AuthTAG, uint32_t TAGSize)
;;;1142   {
000004  b0a1              SUB      sp,sp,#0x84
;;;1143     CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;1144     CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;1145     CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
;;;1146     __IO uint32_t counter = 0;
000006  2000              MOVS     r0,#0
000008  9010              STR      r0,[sp,#0x40]
;;;1147     uint32_t busystatus = 0;
00000a  900f              STR      r0,[sp,#0x3c]
;;;1148     ErrorStatus status = SUCCESS;
00000c  2001              MOVS     r0,#1
00000e  900e              STR      r0,[sp,#0x38]
;;;1149     uint32_t keyaddr    = (uint32_t)Key;
000010  9c24              LDR      r4,[sp,#0x90]
;;;1150     uint32_t inputaddr  = (uint32_t)Input;
000012  f8dd80bc          LDR      r8,[sp,#0xbc]
;;;1151     uint32_t outputaddr = (uint32_t)Output;
000016  f8dd90d0          LDR      r9,[sp,#0xd0]
;;;1152     uint32_t headeraddr = (uint32_t)Header;
00001a  f8dda0c4          LDR      r10,[sp,#0xc4]
;;;1153     uint32_t tagaddr = (uint32_t)AuthTAG;
00001e  9835              LDR      r0,[sp,#0xd4]
000020  900d              STR      r0,[sp,#0x34]
;;;1154     uint32_t headersize = HLength;
000022  9f32              LDR      r7,[sp,#0xc8]
;;;1155     uint32_t loopcounter = 0;
000024  2500              MOVS     r5,#0
;;;1156     uint32_t bufferidx = 0;
000026  2000              MOVS     r0,#0
000028  900c              STR      r0,[sp,#0x30]
;;;1157     uint8_t blockb0[16] = {0};/* Block B0 */
00002a  9008              STR      r0,[sp,#0x20]
00002c  9009              STR      r0,[sp,#0x24]
00002e  900a              STR      r0,[sp,#0x28]
000030  900b              STR      r0,[sp,#0x2c]
;;;1158     uint8_t ctr[16] = {0}; /* Counter */
000032  9004              STR      r0,[sp,#0x10]
000034  9005              STR      r0,[sp,#0x14]
000036  9006              STR      r0,[sp,#0x18]
000038  9007              STR      r0,[sp,#0x1c]
;;;1159     uint32_t temptag[4] = {0}; /* temporary TAG (MAC) */
00003a  9000              STR      r0,[sp,#0]
00003c  9001              STR      r0,[sp,#4]
00003e  9002              STR      r0,[sp,#8]
000040  9003              STR      r0,[sp,#0xc]
;;;1160     uint32_t ctraddr = (uint32_t)ctr;
000042  ae04              ADD      r6,sp,#0x10
;;;1161     uint32_t b0addr = (uint32_t)blockb0;
000044  f10d0b20          ADD      r11,sp,#0x20
;;;1162     
;;;1163     /************************ Formatting the header block ***********************/
;;;1164     if(headersize != 0)
000048  2f00              CMP      r7,#0
00004a  d058              BEQ      |L2.254|
;;;1165     {
;;;1166       /* Check that the associated data (or header) length is lower than 2^16 - 2^8 = 65536 - 256 = 65280 */
;;;1167       if(headersize < 65280)
00004c  f5b74f7f          CMP      r7,#0xff00
000050  d20d              BCS      |L2.110|
;;;1168       {
;;;1169         HBuffer[bufferidx++] = (uint8_t) ((headersize >> 8) & 0xFF);
000052  f3c72207          UBFX     r2,r7,#8,#8
000056  980c              LDR      r0,[sp,#0x30]
000058  1c41              ADDS     r1,r0,#1
00005a  910c              STR      r1,[sp,#0x30]
00005c  9933              LDR      r1,[sp,#0xcc]
00005e  540a              STRB     r2,[r1,r0]
;;;1170         HBuffer[bufferidx++] = (uint8_t) ((headersize) & 0xFF);
000060  980c              LDR      r0,[sp,#0x30]
000062  1c41              ADDS     r1,r0,#1
000064  910c              STR      r1,[sp,#0x30]
000066  9933              LDR      r1,[sp,#0xcc]
000068  540f              STRB     r7,[r1,r0]
;;;1171         headersize += 2;
00006a  1cbf              ADDS     r7,r7,#2
00006c  e026              B        |L2.188|
                  |L2.110|
;;;1172       }
;;;1173       else
;;;1174       {
;;;1175         /* header is encoded as 0xff || 0xfe || [headersize]32, i.e., six octets */
;;;1176         HBuffer[bufferidx++] = 0xFF;
00006e  22ff              MOVS     r2,#0xff
000070  980c              LDR      r0,[sp,#0x30]
000072  1c41              ADDS     r1,r0,#1
000074  910c              STR      r1,[sp,#0x30]
000076  9933              LDR      r1,[sp,#0xcc]
000078  540a              STRB     r2,[r1,r0]
;;;1177         HBuffer[bufferidx++] = 0xFE;
00007a  22fe              MOVS     r2,#0xfe
00007c  980c              LDR      r0,[sp,#0x30]
00007e  1c41              ADDS     r1,r0,#1
000080  910c              STR      r1,[sp,#0x30]
000082  9933              LDR      r1,[sp,#0xcc]
000084  540a              STRB     r2,[r1,r0]
;;;1178         HBuffer[bufferidx++] = headersize & 0xff000000;
000086  2000              MOVS     r0,#0
000088  4602              MOV      r2,r0
00008a  980c              LDR      r0,[sp,#0x30]
00008c  1c41              ADDS     r1,r0,#1
00008e  910c              STR      r1,[sp,#0x30]
000090  9933              LDR      r1,[sp,#0xcc]
000092  540a              STRB     r2,[r1,r0]
;;;1179         HBuffer[bufferidx++] = headersize & 0x00ff0000;
000094  2000              MOVS     r0,#0
000096  4602              MOV      r2,r0
000098  980c              LDR      r0,[sp,#0x30]
00009a  1c41              ADDS     r1,r0,#1
00009c  910c              STR      r1,[sp,#0x30]
00009e  9933              LDR      r1,[sp,#0xcc]
0000a0  540a              STRB     r2,[r1,r0]
;;;1180         HBuffer[bufferidx++] = headersize & 0x0000ff00;
0000a2  2000              MOVS     r0,#0
0000a4  4602              MOV      r2,r0
0000a6  980c              LDR      r0,[sp,#0x30]
0000a8  1c41              ADDS     r1,r0,#1
0000aa  910c              STR      r1,[sp,#0x30]
0000ac  9933              LDR      r1,[sp,#0xcc]
0000ae  540a              STRB     r2,[r1,r0]
;;;1181         HBuffer[bufferidx++] = headersize & 0x000000ff;
0000b0  980c              LDR      r0,[sp,#0x30]
0000b2  1c41              ADDS     r1,r0,#1
0000b4  910c              STR      r1,[sp,#0x30]
0000b6  9933              LDR      r1,[sp,#0xcc]
0000b8  540f              STRB     r7,[r1,r0]
;;;1182         headersize += 6;
0000ba  1dbf              ADDS     r7,r7,#6
                  |L2.188|
;;;1183       }
;;;1184       /* Copy the header buffer in internal buffer "HBuffer" */
;;;1185       for(loopcounter = 0; loopcounter < headersize; loopcounter++)
0000bc  2500              MOVS     r5,#0
0000be  e007              B        |L2.208|
                  |L2.192|
;;;1186       {
;;;1187         HBuffer[bufferidx++] = Header[loopcounter];
0000c0  9831              LDR      r0,[sp,#0xc4]
0000c2  5d42              LDRB     r2,[r0,r5]
0000c4  980c              LDR      r0,[sp,#0x30]
0000c6  1c41              ADDS     r1,r0,#1
0000c8  910c              STR      r1,[sp,#0x30]
0000ca  9933              LDR      r1,[sp,#0xcc]
0000cc  540a              STRB     r2,[r1,r0]
0000ce  1c6d              ADDS     r5,r5,#1              ;1185
                  |L2.208|
0000d0  42bd              CMP      r5,r7                 ;1185
0000d2  d3f5              BCC      |L2.192|
;;;1188       }
;;;1189       /* Check if the header size is modulo 16 */
;;;1190       if ((headersize % 16) != 0)
0000d4  f007000f          AND      r0,r7,#0xf
0000d8  b178              CBZ      r0,|L2.250|
;;;1191       {
;;;1192         /* Padd the header buffer with 0s till the HBuffer length is modulo 16 */
;;;1193         for(loopcounter = headersize; loopcounter <= ((headersize/16) + 1) * 16; loopcounter++)
0000da  463d              MOV      r5,r7
0000dc  e003              B        |L2.230|
                  |L2.222|
;;;1194         {
;;;1195           HBuffer[loopcounter] = 0;
0000de  2100              MOVS     r1,#0
0000e0  9833              LDR      r0,[sp,#0xcc]
0000e2  5541              STRB     r1,[r0,r5]
0000e4  1c6d              ADDS     r5,r5,#1              ;1193
                  |L2.230|
0000e6  2001              MOVS     r0,#1                 ;1193
0000e8  eb001017          ADD      r0,r0,r7,LSR #4       ;1193
0000ec  ebb51f00          CMP      r5,r0,LSL #4          ;1193
0000f0  d9f5              BLS      |L2.222|
;;;1196         }
;;;1197         /* Set the header size to modulo 16 */
;;;1198         headersize = ((headersize/16) + 1) * 16;
0000f2  2001              MOVS     r0,#1
0000f4  eb001017          ADD      r0,r0,r7,LSR #4
0000f8  0107              LSLS     r7,r0,#4
                  |L2.250|
;;;1199       }
;;;1200       /* set the pointer headeraddr to HBuffer */
;;;1201       headeraddr = (uint32_t)HBuffer;
0000fa  f8dda0cc          LDR      r10,[sp,#0xcc]
                  |L2.254|
;;;1202     }
;;;1203     /************************* Formatting the block B0 **************************/
;;;1204     if(headersize != 0)
0000fe  b117              CBZ      r7,|L2.262|
;;;1205     {
;;;1206       blockb0[0] = 0x40;
000100  2040              MOVS     r0,#0x40
000102  f88d0020          STRB     r0,[sp,#0x20]
                  |L2.262|
;;;1207     }
;;;1208     /* Flags byte */
;;;1209     blockb0[0] |= 0u | (((( (uint8_t) TAGSize - 2) / 2) & 0x07 ) << 3 ) | ( ( (uint8_t) (15 - NonceSize) - 1) & 0x07);
000106  9936              LDR      r1,[sp,#0xd8]
000108  b2c9              UXTB     r1,r1
00010a  1e88              SUBS     r0,r1,#2
00010c  eb0071d0          ADD      r1,r0,r0,LSR #31
000110  f3c10142          UBFX     r1,r1,#1,#3
000114  2200              MOVS     r2,#0
000116  ea4201c1          ORR      r1,r2,r1,LSL #3
00011a  9a23              LDR      r2,[sp,#0x8c]
00011c  f1c2020e          RSB      r2,r2,#0xe
000120  f0020207          AND      r2,r2,#7
000124  4311              ORRS     r1,r1,r2
000126  f89d2020          LDRB     r2,[sp,#0x20]
00012a  4311              ORRS     r1,r1,r2
00012c  f88d1020          STRB     r1,[sp,#0x20]
;;;1210     
;;;1211     for (loopcounter = 0; loopcounter < NonceSize; loopcounter++)
000130  2500              MOVS     r5,#0
000132  e005              B        |L2.320|
                  |L2.308|
;;;1212     {
;;;1213       blockb0[loopcounter+1] = Nonce[loopcounter];
000134  9822              LDR      r0,[sp,#0x88]
000136  5d41              LDRB     r1,[r0,r5]
000138  aa08              ADD      r2,sp,#0x20
00013a  1c68              ADDS     r0,r5,#1
00013c  5411              STRB     r1,[r2,r0]
00013e  1c6d              ADDS     r5,r5,#1              ;1211
                  |L2.320|
000140  9823              LDR      r0,[sp,#0x8c]         ;1211
000142  4285              CMP      r5,r0                 ;1211
000144  d3f6              BCC      |L2.308|
;;;1214     }
;;;1215     for ( ; loopcounter < 13; loopcounter++)
000146  e004              B        |L2.338|
                  |L2.328|
;;;1216     {
;;;1217       blockb0[loopcounter+1] = 0;
000148  2100              MOVS     r1,#0
00014a  aa08              ADD      r2,sp,#0x20
00014c  1c68              ADDS     r0,r5,#1
00014e  5411              STRB     r1,[r2,r0]
000150  1c6d              ADDS     r5,r5,#1              ;1215
                  |L2.338|
000152  2d0d              CMP      r5,#0xd               ;1215
000154  d3f8              BCC      |L2.328|
;;;1218     }
;;;1219     
;;;1220     blockb0[14] = ((ILength >> 8) & 0xFF);
000156  9830              LDR      r0,[sp,#0xc0]
000158  0a00              LSRS     r0,r0,#8
00015a  f88d002e          STRB     r0,[sp,#0x2e]
;;;1221     blockb0[15] = (ILength & 0xFF);
00015e  9830              LDR      r0,[sp,#0xc0]
000160  b2c0              UXTB     r0,r0
000162  f88d002f          STRB     r0,[sp,#0x2f]
;;;1222     
;;;1223     /************************* Formatting the initial counter *******************/
;;;1224     /* Byte 0:
;;;1225        Bits 7 and 6 are reserved and shall be set to 0
;;;1226        Bits 3, 4, and 5 shall also be set to 0, to ensure that all the counter blocks
;;;1227        are distinct from B0
;;;1228        Bits 0, 1, and 2 contain the same encoding of q as in B0
;;;1229     */
;;;1230     ctr[0] = blockb0[0] & 0x07;
000166  f89d0020          LDRB     r0,[sp,#0x20]
00016a  f0000007          AND      r0,r0,#7
00016e  f88d0010          STRB     r0,[sp,#0x10]
;;;1231     /* byte 1 to NonceSize is the IV (Nonce) */
;;;1232     for(loopcounter = 1; loopcounter < NonceSize + 1; loopcounter++)
000172  2501              MOVS     r5,#1
000174  e004              B        |L2.384|
                  |L2.374|
;;;1233     {
;;;1234       ctr[loopcounter] = blockb0[loopcounter];
000176  a808              ADD      r0,sp,#0x20
000178  5d40              LDRB     r0,[r0,r5]
00017a  a904              ADD      r1,sp,#0x10
00017c  5548              STRB     r0,[r1,r5]
00017e  1c6d              ADDS     r5,r5,#1              ;1232
                  |L2.384|
000180  9823              LDR      r0,[sp,#0x8c]         ;1232
000182  1c40              ADDS     r0,r0,#1              ;1232
000184  4285              CMP      r5,r0                 ;1232
000186  d3f6              BCC      |L2.374|
;;;1235     }
;;;1236     /* Set the LSB to 1 */
;;;1237     ctr[15] |= 0x01;
000188  f89d001f          LDRB     r0,[sp,#0x1f]
00018c  f0400001          ORR      r0,r0,#1
000190  f88d001f          STRB     r0,[sp,#0x1f]
;;;1238     
;;;1239     /* Crypto structures initialisation*/
;;;1240     CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
000194  a815              ADD      r0,sp,#0x54
000196  f7fffffe          BL       CRYP_KeyStructInit
;;;1241     
;;;1242     switch(Keysize)
00019a  982e              LDR      r0,[sp,#0xb8]
00019c  2880              CMP      r0,#0x80
00019e  d005              BEQ      |L2.428|
0001a0  28c0              CMP      r0,#0xc0
0001a2  d015              BEQ      |L2.464|
0001a4  f5b07f80          CMP      r0,#0x100
0001a8  d150              BNE      |L2.588|
0001aa  e02c              B        |L2.518|
                  |L2.428|
;;;1243     {
;;;1244       case 128:
;;;1245       AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
0001ac  2000              MOVS     r0,#0
0001ae  9020              STR      r0,[sp,#0x80]
;;;1246       AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
0001b0  6820              LDR      r0,[r4,#0]
0001b2  ba00              REV      r0,r0
0001b4  9019              STR      r0,[sp,#0x64]
;;;1247       keyaddr+=4;
0001b6  1d24              ADDS     r4,r4,#4
;;;1248       AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
0001b8  6820              LDR      r0,[r4,#0]
0001ba  ba00              REV      r0,r0
0001bc  901a              STR      r0,[sp,#0x68]
;;;1249       keyaddr+=4;
0001be  1d24              ADDS     r4,r4,#4
;;;1250       AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
0001c0  6820              LDR      r0,[r4,#0]
0001c2  ba00              REV      r0,r0
0001c4  901b              STR      r0,[sp,#0x6c]
;;;1251       keyaddr+=4;
0001c6  1d24              ADDS     r4,r4,#4
;;;1252       AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
0001c8  6820              LDR      r0,[r4,#0]
0001ca  ba00              REV      r0,r0
0001cc  901c              STR      r0,[sp,#0x70]
;;;1253       break;
0001ce  e03e              B        |L2.590|
                  |L2.464|
;;;1254       case 192:
;;;1255       AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
0001d0  f44f7080          MOV      r0,#0x100
0001d4  9020              STR      r0,[sp,#0x80]
;;;1256       AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
0001d6  6820              LDR      r0,[r4,#0]
0001d8  ba00              REV      r0,r0
0001da  9017              STR      r0,[sp,#0x5c]
;;;1257       keyaddr+=4;
0001dc  1d24              ADDS     r4,r4,#4
;;;1258       AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
0001de  6820              LDR      r0,[r4,#0]
0001e0  ba00              REV      r0,r0
0001e2  9018              STR      r0,[sp,#0x60]
;;;1259       keyaddr+=4;
0001e4  1d24              ADDS     r4,r4,#4
;;;1260       AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
0001e6  6820              LDR      r0,[r4,#0]
0001e8  ba00              REV      r0,r0
0001ea  9019              STR      r0,[sp,#0x64]
;;;1261       keyaddr+=4;
0001ec  1d24              ADDS     r4,r4,#4
;;;1262       AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
0001ee  6820              LDR      r0,[r4,#0]
0001f0  ba00              REV      r0,r0
0001f2  901a              STR      r0,[sp,#0x68]
;;;1263       keyaddr+=4;
0001f4  1d24              ADDS     r4,r4,#4
;;;1264       AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
0001f6  6820              LDR      r0,[r4,#0]
0001f8  ba00              REV      r0,r0
0001fa  901b              STR      r0,[sp,#0x6c]
;;;1265       keyaddr+=4;
0001fc  1d24              ADDS     r4,r4,#4
;;;1266       AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
0001fe  6820              LDR      r0,[r4,#0]
000200  ba00              REV      r0,r0
000202  901c              STR      r0,[sp,#0x70]
;;;1267       break;
000204  e023              B        |L2.590|
                  |L2.518|
;;;1268       case 256:
;;;1269       AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000206  f44f7000          MOV      r0,#0x200
00020a  9020              STR      r0,[sp,#0x80]
;;;1270       AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
00020c  6820              LDR      r0,[r4,#0]
00020e  ba00              REV      r0,r0
000210  9015              STR      r0,[sp,#0x54]
;;;1271       keyaddr+=4;
000212  1d24              ADDS     r4,r4,#4
;;;1272       AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
000214  6820              LDR      r0,[r4,#0]
000216  ba00              REV      r0,r0
000218  9016              STR      r0,[sp,#0x58]
;;;1273       keyaddr+=4;
00021a  1d24              ADDS     r4,r4,#4
;;;1274       AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
00021c  6820              LDR      r0,[r4,#0]
00021e  ba00              REV      r0,r0
000220  9017              STR      r0,[sp,#0x5c]
;;;1275       keyaddr+=4;
000222  1d24              ADDS     r4,r4,#4
;;;1276       AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
000224  6820              LDR      r0,[r4,#0]
000226  ba00              REV      r0,r0
000228  9018              STR      r0,[sp,#0x60]
;;;1277       keyaddr+=4;
00022a  1d24              ADDS     r4,r4,#4
;;;1278       AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
00022c  6820              LDR      r0,[r4,#0]
00022e  ba00              REV      r0,r0
000230  9019              STR      r0,[sp,#0x64]
;;;1279       keyaddr+=4;
000232  1d24              ADDS     r4,r4,#4
;;;1280       AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000234  6820              LDR      r0,[r4,#0]
000236  ba00              REV      r0,r0
000238  901a              STR      r0,[sp,#0x68]
;;;1281       keyaddr+=4;
00023a  1d24              ADDS     r4,r4,#4
;;;1282       AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
00023c  6820              LDR      r0,[r4,#0]
00023e  ba00              REV      r0,r0
000240  901b              STR      r0,[sp,#0x6c]
;;;1283       keyaddr+=4;
000242  1d24              ADDS     r4,r4,#4
;;;1284       AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000244  6820              LDR      r0,[r4,#0]
000246  ba00              REV      r0,r0
000248  901c              STR      r0,[sp,#0x70]
;;;1285       break;
00024a  e000              B        |L2.590|
                  |L2.588|
;;;1286       default:
;;;1287       break;
00024c  bf00              NOP      
                  |L2.590|
00024e  bf00              NOP                            ;1253
;;;1288     }
;;;1289     
;;;1290     /* CRYP Initialization Vectors */
;;;1291     AES_CRYP_IVInitStructure.CRYP_IV0Left = (__REV(*(uint32_t*)(ctraddr)));
000250  6830              LDR      r0,[r6,#0]
000252  ba00              REV      r0,r0
000254  9011              STR      r0,[sp,#0x44]
;;;1292     ctraddr+=4;
000256  1d36              ADDS     r6,r6,#4
;;;1293     AES_CRYP_IVInitStructure.CRYP_IV0Right= (__REV(*(uint32_t*)(ctraddr)));
000258  6830              LDR      r0,[r6,#0]
00025a  ba00              REV      r0,r0
00025c  9012              STR      r0,[sp,#0x48]
;;;1294     ctraddr+=4;
00025e  1d36              ADDS     r6,r6,#4
;;;1295     AES_CRYP_IVInitStructure.CRYP_IV1Left = (__REV(*(uint32_t*)(ctraddr)));
000260  6830              LDR      r0,[r6,#0]
000262  ba00              REV      r0,r0
000264  9013              STR      r0,[sp,#0x4c]
;;;1296     ctraddr+=4;
000266  1d36              ADDS     r6,r6,#4
;;;1297     AES_CRYP_IVInitStructure.CRYP_IV1Right= (__REV(*(uint32_t*)(ctraddr)));
000268  6830              LDR      r0,[r6,#0]
00026a  ba00              REV      r0,r0
00026c  9014              STR      r0,[sp,#0x50]
;;;1298     
;;;1299     /*------------------ AES Encryption ------------------*/
;;;1300     if(Mode == MODE_ENCRYPT) /* AES encryption */
00026e  9821              LDR      r0,[sp,#0x84]
000270  2801              CMP      r0,#1
000272  d17d              BNE      |L2.880|
;;;1301     {
;;;1302       /* Flush IN/OUT FIFOs */
;;;1303       CRYP_FIFOFlush();
000274  f7fffffe          BL       CRYP_FIFOFlush
;;;1304       
;;;1305       /* Key Initialisation */
;;;1306       CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
000278  a815              ADD      r0,sp,#0x54
00027a  f7fffffe          BL       CRYP_KeyInit
;;;1307       
;;;1308       /* CRYP Initialization Vectors */
;;;1309       CRYP_IVInit(&AES_CRYP_IVInitStructure);
00027e  a811              ADD      r0,sp,#0x44
000280  f7fffffe          BL       CRYP_IVInit
;;;1310       
;;;1311       /* Crypto Init for Key preparation for decryption process */
;;;1312       AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
000284  2000              MOVS     r0,#0
000286  901d              STR      r0,[sp,#0x74]
;;;1313       AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
000288  f04f1008          MOV      r0,#0x80008
00028c  901e              STR      r0,[sp,#0x78]
;;;1314       AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00028e  2080              MOVS     r0,#0x80
000290  901f              STR      r0,[sp,#0x7c]
;;;1315       CRYP_Init(&AES_CRYP_InitStructure);
000292  a81d              ADD      r0,sp,#0x74
000294  f7fffffe          BL       CRYP_Init
;;;1316       
;;;1317       /***************************** Init phase *********************************/
;;;1318       /* Select init phase */
;;;1319       CRYP_PhaseConfig(CRYP_Phase_Init);
000298  2000              MOVS     r0,#0
00029a  f7fffffe          BL       CRYP_PhaseConfig
;;;1320       
;;;1321       b0addr = (uint32_t)blockb0;
00029e  f10d0b20          ADD      r11,sp,#0x20
;;;1322       /* Write the blockb0 block in the IN FIFO */
;;;1323       CRYP_DataIn((*(uint32_t*)(b0addr)));
0002a2  f8db0000          LDR      r0,[r11,#0]
0002a6  f7fffffe          BL       CRYP_DataIn
;;;1324       b0addr+=4;
0002aa  f10b0b04          ADD      r11,r11,#4
;;;1325       CRYP_DataIn((*(uint32_t*)(b0addr)));
0002ae  f8db0000          LDR      r0,[r11,#0]
0002b2  f7fffffe          BL       CRYP_DataIn
;;;1326       b0addr+=4;
0002b6  f10b0b04          ADD      r11,r11,#4
;;;1327       CRYP_DataIn((*(uint32_t*)(b0addr)));
0002ba  f8db0000          LDR      r0,[r11,#0]
0002be  f7fffffe          BL       CRYP_DataIn
;;;1328       b0addr+=4;
0002c2  f10b0b04          ADD      r11,r11,#4
;;;1329       CRYP_DataIn((*(uint32_t*)(b0addr)));
0002c6  f8db0000          LDR      r0,[r11,#0]
0002ca  f7fffffe          BL       CRYP_DataIn
;;;1330       
;;;1331       /* Enable Crypto processor */
;;;1332       CRYP_Cmd(ENABLE);
0002ce  2001              MOVS     r0,#1
0002d0  f7fffffe          BL       CRYP_Cmd
;;;1333       
;;;1334       /* Wait for CRYPEN bit to be 0 */
;;;1335       while(CRYP_GetCmdStatus() == ENABLE)
0002d4  bf00              NOP      
                  |L2.726|
0002d6  f7fffffe          BL       CRYP_GetCmdStatus
0002da  2801              CMP      r0,#1
0002dc  d0fb              BEQ      |L2.726|
;;;1336       {
;;;1337       }
;;;1338       /***************************** header phase *******************************/
;;;1339       if(headersize != 0)
0002de  2f00              CMP      r7,#0
0002e0  d045              BEQ      |L2.878|
;;;1340       {
;;;1341         /* Select header phase */
;;;1342         CRYP_PhaseConfig(CRYP_Phase_Header);
0002e2  f44f3080          MOV      r0,#0x10000
0002e6  f7fffffe          BL       CRYP_PhaseConfig
;;;1343         
;;;1344         /* Enable Crypto processor */
;;;1345         CRYP_Cmd(ENABLE);
0002ea  2001              MOVS     r0,#1
0002ec  f7fffffe          BL       CRYP_Cmd
;;;1346         
;;;1347         if(CRYP_GetCmdStatus() == DISABLE)
0002f0  f7fffffe          BL       CRYP_GetCmdStatus
0002f4  b918              CBNZ     r0,|L2.766|
;;;1348         {
;;;1349            /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;1350               the CRYP peripheral (please check the device sales type. */
;;;1351            return(ERROR);
0002f6  2000              MOVS     r0,#0
                  |L2.760|
;;;1352         }
;;;1353         
;;;1354         for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
;;;1355         {
;;;1356           /* Wait until the IFEM flag is reset */
;;;1357           while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;1358           {
;;;1359           }
;;;1360           
;;;1361           /* Write the Input block in the IN FIFO */
;;;1362           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1363           headeraddr+=4;
;;;1364           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1365           headeraddr+=4;
;;;1366           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1367           headeraddr+=4;
;;;1368           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1369           headeraddr+=4;
;;;1370         }
;;;1371         
;;;1372         /* Wait until the complete message has been processed */
;;;1373         counter = 0;
;;;1374         do
;;;1375         {
;;;1376           busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;1377           counter++;
;;;1378         }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1379   
;;;1380         if (busystatus != RESET)
;;;1381         {
;;;1382           status = ERROR;
;;;1383         }
;;;1384       }
;;;1385       
;;;1386       /**************************** payload phase *******************************/
;;;1387       if(ILength != 0)
;;;1388       {
;;;1389         /* Select payload phase */
;;;1390         CRYP_PhaseConfig(CRYP_Phase_Payload);
;;;1391         
;;;1392         /* Enable Crypto processor */
;;;1393         CRYP_Cmd(ENABLE);
;;;1394         
;;;1395         if(CRYP_GetCmdStatus() == DISABLE)
;;;1396         {
;;;1397           /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;1398              the CRYP peripheral (please check the device sales type. */
;;;1399           return(ERROR);
;;;1400         }
;;;1401         
;;;1402         for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
;;;1403         {
;;;1404           /* Wait until the IFEM flag is reset */
;;;1405           while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;1406           {
;;;1407           }
;;;1408           
;;;1409           /* Write the Input block in the IN FIFO */
;;;1410           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1411           inputaddr+=4;
;;;1412           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1413           inputaddr+=4;
;;;1414           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1415           inputaddr+=4;
;;;1416           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1417           inputaddr+=4;
;;;1418           
;;;1419           /* Wait until the complete message has been processed */
;;;1420           counter = 0;
;;;1421           do
;;;1422           {
;;;1423             busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;1424             counter++;
;;;1425           }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1426   
;;;1427           if (busystatus != RESET)
;;;1428           {
;;;1429             status = ERROR;
;;;1430           }
;;;1431           else
;;;1432           {
;;;1433             /* Wait until the OFNE flag is reset */
;;;1434             while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1435             {
;;;1436             }
;;;1437             
;;;1438             /* Read the Output block from the Output FIFO */
;;;1439             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1440             outputaddr+=4;
;;;1441             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1442             outputaddr+=4;
;;;1443             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1444             outputaddr+=4;
;;;1445             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1446             outputaddr+=4;
;;;1447           }
;;;1448         }
;;;1449       }
;;;1450       
;;;1451       /***************************** final phase ********************************/
;;;1452       /* Select final phase */
;;;1453       CRYP_PhaseConfig(CRYP_Phase_Final);
;;;1454       
;;;1455       /* Enable Crypto processor */
;;;1456       CRYP_Cmd(ENABLE);
;;;1457       
;;;1458       if(CRYP_GetCmdStatus() == DISABLE)
;;;1459       {
;;;1460         /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;1461            the CRYP peripheral (please check the device sales type. */
;;;1462         return(ERROR);
;;;1463       }
;;;1464       
;;;1465       ctraddr = (uint32_t)ctr;
;;;1466       /* Write the counter block in the IN FIFO */
;;;1467       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1468       ctraddr+=4;
;;;1469       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1470       ctraddr+=4;
;;;1471       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1472       ctraddr+=4;
;;;1473       /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
;;;1474       CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
;;;1475       
;;;1476       /* Wait until the OFNE flag is reset */
;;;1477       while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1478       {
;;;1479       }
;;;1480       
;;;1481       /* Read the Auth TAG in the IN FIFO */
;;;1482       temptag[0] = CRYP_DataOut();
;;;1483       temptag[1] = CRYP_DataOut();
;;;1484       temptag[2] = CRYP_DataOut();
;;;1485       temptag[3] = CRYP_DataOut();
;;;1486     }
;;;1487     /*------------------ AES Decryption ------------------*/
;;;1488     else /* AES decryption */
;;;1489     {
;;;1490       /* Flush IN/OUT FIFOs */
;;;1491       CRYP_FIFOFlush();
;;;1492       
;;;1493       /* Key Initialisation */
;;;1494       CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
;;;1495       
;;;1496       /* CRYP Initialization Vectors */
;;;1497       CRYP_IVInit(&AES_CRYP_IVInitStructure);
;;;1498       
;;;1499       /* Crypto Init for Key preparation for decryption process */
;;;1500       AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;1501       AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
;;;1502       AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
;;;1503       CRYP_Init(&AES_CRYP_InitStructure);
;;;1504       
;;;1505       /***************************** Init phase *********************************/
;;;1506       /* Select init phase */
;;;1507       CRYP_PhaseConfig(CRYP_Phase_Init);
;;;1508       
;;;1509       b0addr = (uint32_t)blockb0;
;;;1510       /* Write the blockb0 block in the IN FIFO */
;;;1511       CRYP_DataIn((*(uint32_t*)(b0addr)));
;;;1512       b0addr+=4;
;;;1513       CRYP_DataIn((*(uint32_t*)(b0addr)));
;;;1514       b0addr+=4;
;;;1515       CRYP_DataIn((*(uint32_t*)(b0addr)));
;;;1516       b0addr+=4;
;;;1517       CRYP_DataIn((*(uint32_t*)(b0addr)));
;;;1518       
;;;1519       /* Enable Crypto processor */
;;;1520       CRYP_Cmd(ENABLE);
;;;1521       
;;;1522       /* Wait for CRYPEN bit to be 0 */
;;;1523       while(CRYP_GetCmdStatus() == ENABLE)
;;;1524       {
;;;1525       }
;;;1526       
;;;1527       /***************************** header phase *******************************/
;;;1528       if(headersize != 0)
;;;1529       {
;;;1530         /* Select header phase */
;;;1531         CRYP_PhaseConfig(CRYP_Phase_Header);
;;;1532         
;;;1533         /* Enable Crypto processor */
;;;1534         CRYP_Cmd(ENABLE);
;;;1535         
;;;1536         if(CRYP_GetCmdStatus() == DISABLE)
;;;1537         {
;;;1538           /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;1539              the CRYP peripheral (please check the device sales type. */
;;;1540           return(ERROR);
;;;1541         }
;;;1542         
;;;1543         for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
;;;1544         {
;;;1545           /* Wait until the IFEM flag is reset */
;;;1546           while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;1547           {
;;;1548           }
;;;1549           
;;;1550           /* Write the Input block in the IN FIFO */
;;;1551           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1552           headeraddr+=4;
;;;1553           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1554           headeraddr+=4;
;;;1555           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1556           headeraddr+=4;
;;;1557           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1558           headeraddr+=4;
;;;1559         }
;;;1560         
;;;1561         /* Wait until the complete message has been processed */
;;;1562         counter = 0;
;;;1563         do
;;;1564         {
;;;1565           busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;1566           counter++;
;;;1567         }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1568   
;;;1569         if (busystatus != RESET)
;;;1570         {
;;;1571           status = ERROR;
;;;1572         }
;;;1573       }
;;;1574       
;;;1575       /**************************** payload phase *******************************/
;;;1576       if(ILength != 0)
;;;1577       {
;;;1578         /* Select payload phase */
;;;1579         CRYP_PhaseConfig(CRYP_Phase_Payload);
;;;1580   
;;;1581         /* Enable Crypto processor */
;;;1582         CRYP_Cmd(ENABLE);
;;;1583         
;;;1584         if(CRYP_GetCmdStatus() == DISABLE)
;;;1585         {
;;;1586           /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;1587              the CRYP peripheral (please check the device sales type. */
;;;1588           return(ERROR);
;;;1589         }
;;;1590         
;;;1591         for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
;;;1592         {
;;;1593           /* Wait until the IFEM flag is reset */
;;;1594           while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;1595           {
;;;1596           }
;;;1597           
;;;1598           /* Write the Input block in the IN FIFO */
;;;1599           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1600           inputaddr+=4;
;;;1601           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1602           inputaddr+=4;
;;;1603           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1604           inputaddr+=4;
;;;1605           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1606           inputaddr+=4;
;;;1607           
;;;1608           /* Wait until the complete message has been processed */
;;;1609           counter = 0;
;;;1610           do
;;;1611           {
;;;1612             busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;1613             counter++;
;;;1614           }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1615   
;;;1616           if (busystatus != RESET)
;;;1617           {
;;;1618             status = ERROR;
;;;1619           }
;;;1620           else
;;;1621           {
;;;1622             /* Wait until the OFNE flag is reset */
;;;1623             while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1624             {
;;;1625             }
;;;1626             
;;;1627             /* Read the Output block from the Output FIFO */
;;;1628             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1629             outputaddr+=4;
;;;1630             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1631             outputaddr+=4;
;;;1632             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1633             outputaddr+=4;
;;;1634             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1635             outputaddr+=4;
;;;1636           }
;;;1637         }
;;;1638       }
;;;1639       
;;;1640       /***************************** final phase ********************************/
;;;1641       /* Select final phase */
;;;1642       CRYP_PhaseConfig(CRYP_Phase_Final);
;;;1643       
;;;1644       /* Enable Crypto processor */
;;;1645       CRYP_Cmd(ENABLE);
;;;1646       
;;;1647       if(CRYP_GetCmdStatus() == DISABLE)
;;;1648       {
;;;1649         /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;1650            the CRYP peripheral (please check the device sales type. */
;;;1651         return(ERROR);
;;;1652       }
;;;1653       
;;;1654       ctraddr = (uint32_t)ctr;
;;;1655       /* Write the counter block in the IN FIFO */
;;;1656       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1657       ctraddr+=4;
;;;1658       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1659       ctraddr+=4;
;;;1660       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1661       ctraddr+=4;
;;;1662       /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
;;;1663       CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
;;;1664       
;;;1665       /* Wait until the OFNE flag is reset */
;;;1666       while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1667       {
;;;1668       }
;;;1669       
;;;1670       /* Read the Authentification TAG (MAC) in the IN FIFO */
;;;1671       temptag[0] = CRYP_DataOut();
;;;1672       temptag[1] = CRYP_DataOut();
;;;1673       temptag[2] = CRYP_DataOut();
;;;1674       temptag[3] = CRYP_DataOut();
;;;1675     }
;;;1676     
;;;1677     /* Copy temporary authentication TAG in user TAG buffer */
;;;1678     for(loopcounter = 0; (loopcounter < TAGSize); loopcounter++)
;;;1679     {
;;;1680       /* Set the authentication TAG buffer */
;;;1681       *((uint8_t*)tagaddr+loopcounter) = *((uint8_t*)temptag+loopcounter);
;;;1682     }
;;;1683     
;;;1684     /* Disable Crypto */
;;;1685     CRYP_Cmd(DISABLE);
;;;1686   
;;;1687     return status;
;;;1688   }
0002f8  b025              ADD      sp,sp,#0x94
0002fa  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.766|
0002fe  2500              MOVS     r5,#0                 ;1354
000300  e01e              B        |L2.832|
                  |L2.770|
000302  bf00              NOP                            ;1357
                  |L2.772|
000304  2001              MOVS     r0,#1                 ;1357
000306  f7fffffe          BL       CRYP_GetFlagStatus
00030a  2800              CMP      r0,#0                 ;1357
00030c  d0fa              BEQ      |L2.772|
00030e  f8da0000          LDR      r0,[r10,#0]           ;1362
000312  f7fffffe          BL       CRYP_DataIn
000316  f10a0a04          ADD      r10,r10,#4            ;1363
00031a  f8da0000          LDR      r0,[r10,#0]           ;1364
00031e  f7fffffe          BL       CRYP_DataIn
000322  f10a0a04          ADD      r10,r10,#4            ;1365
000326  f8da0000          LDR      r0,[r10,#0]           ;1366
00032a  f7fffffe          BL       CRYP_DataIn
00032e  f10a0a04          ADD      r10,r10,#4            ;1367
000332  f8da0000          LDR      r0,[r10,#0]           ;1368
000336  f7fffffe          BL       CRYP_DataIn
00033a  f10a0a04          ADD      r10,r10,#4            ;1369
00033e  3510              ADDS     r5,r5,#0x10           ;1354
                  |L2.832|
000340  42bd              CMP      r5,r7                 ;1354
000342  d3de              BCC      |L2.770|
000344  2000              MOVS     r0,#0                 ;1373
000346  9010              STR      r0,[sp,#0x40]         ;1373
000348  bf00              NOP                            ;1374
                  |L2.842|
00034a  2010              MOVS     r0,#0x10              ;1376
00034c  f7fffffe          BL       CRYP_GetFlagStatus
000350  900f              STR      r0,[sp,#0x3c]         ;1376
000352  9810              LDR      r0,[sp,#0x40]         ;1377
000354  1c40              ADDS     r0,r0,#1              ;1377
000356  9010              STR      r0,[sp,#0x40]         ;1377
000358  9810              LDR      r0,[sp,#0x40]         ;1378
00035a  f5b03f80          CMP      r0,#0x10000           ;1378
00035e  d002              BEQ      |L2.870|
000360  980f              LDR      r0,[sp,#0x3c]         ;1378
000362  2800              CMP      r0,#0                 ;1378
000364  d1f1              BNE      |L2.842|
                  |L2.870|
000366  980f              LDR      r0,[sp,#0x3c]         ;1380
000368  b108              CBZ      r0,|L2.878|
00036a  2000              MOVS     r0,#0                 ;1382
00036c  900e              STR      r0,[sp,#0x38]         ;1382
                  |L2.878|
00036e  e000              B        |L2.882|
                  |L2.880|
000370  e09a              B        |L2.1192|
                  |L2.882|
000372  9830              LDR      r0,[sp,#0xc0]         ;1387
000374  2800              CMP      r0,#0                 ;1387
000376  d066              BEQ      |L2.1094|
000378  f44f3000          MOV      r0,#0x20000           ;1390
00037c  f7fffffe          BL       CRYP_PhaseConfig
000380  2001              MOVS     r0,#1                 ;1393
000382  f7fffffe          BL       CRYP_Cmd
000386  f7fffffe          BL       CRYP_GetCmdStatus
00038a  b908              CBNZ     r0,|L2.912|
00038c  2000              MOVS     r0,#0                 ;1399
00038e  e7b3              B        |L2.760|
                  |L2.912|
000390  2500              MOVS     r5,#0                 ;1402
000392  e052              B        |L2.1082|
                  |L2.916|
000394  bf00              NOP                            ;1405
                  |L2.918|
000396  2001              MOVS     r0,#1                 ;1405
000398  f7fffffe          BL       CRYP_GetFlagStatus
00039c  2800              CMP      r0,#0                 ;1405
00039e  d0fa              BEQ      |L2.918|
0003a0  f8d80000          LDR      r0,[r8,#0]            ;1410
0003a4  f7fffffe          BL       CRYP_DataIn
0003a8  f1080804          ADD      r8,r8,#4              ;1411
0003ac  f8d80000          LDR      r0,[r8,#0]            ;1412
0003b0  f7fffffe          BL       CRYP_DataIn
0003b4  f1080804          ADD      r8,r8,#4              ;1413
0003b8  f8d80000          LDR      r0,[r8,#0]            ;1414
0003bc  f7fffffe          BL       CRYP_DataIn
0003c0  f1080804          ADD      r8,r8,#4              ;1415
0003c4  f8d80000          LDR      r0,[r8,#0]            ;1416
0003c8  f7fffffe          BL       CRYP_DataIn
0003cc  f1080804          ADD      r8,r8,#4              ;1417
0003d0  2000              MOVS     r0,#0                 ;1420
0003d2  9010              STR      r0,[sp,#0x40]         ;1420
0003d4  bf00              NOP                            ;1421
                  |L2.982|
0003d6  2010              MOVS     r0,#0x10              ;1423
0003d8  f7fffffe          BL       CRYP_GetFlagStatus
0003dc  900f              STR      r0,[sp,#0x3c]         ;1423
0003de  9810              LDR      r0,[sp,#0x40]         ;1424
0003e0  1c40              ADDS     r0,r0,#1              ;1424
0003e2  9010              STR      r0,[sp,#0x40]         ;1424
0003e4  9810              LDR      r0,[sp,#0x40]         ;1425
0003e6  f5b03f80          CMP      r0,#0x10000           ;1425
0003ea  d002              BEQ      |L2.1010|
0003ec  980f              LDR      r0,[sp,#0x3c]         ;1425
0003ee  2800              CMP      r0,#0                 ;1425
0003f0  d1f1              BNE      |L2.982|
                  |L2.1010|
0003f2  980f              LDR      r0,[sp,#0x3c]         ;1427
0003f4  b110              CBZ      r0,|L2.1020|
0003f6  2000              MOVS     r0,#0                 ;1429
0003f8  900e              STR      r0,[sp,#0x38]         ;1429
0003fa  e01d              B        |L2.1080|
                  |L2.1020|
0003fc  bf00              NOP                            ;1434
                  |L2.1022|
0003fe  2004              MOVS     r0,#4                 ;1434
000400  f7fffffe          BL       CRYP_GetFlagStatus
000404  2800              CMP      r0,#0                 ;1434
000406  d0fa              BEQ      |L2.1022|
000408  f7fffffe          BL       CRYP_DataOut
00040c  f8c90000          STR      r0,[r9,#0]            ;1439
000410  f1090904          ADD      r9,r9,#4              ;1440
000414  f7fffffe          BL       CRYP_DataOut
000418  f8c90000          STR      r0,[r9,#0]            ;1441
00041c  f1090904          ADD      r9,r9,#4              ;1442
000420  f7fffffe          BL       CRYP_DataOut
000424  f8c90000          STR      r0,[r9,#0]            ;1443
000428  f1090904          ADD      r9,r9,#4              ;1444
00042c  f7fffffe          BL       CRYP_DataOut
000430  f8c90000          STR      r0,[r9,#0]            ;1445
000434  f1090904          ADD      r9,r9,#4              ;1446
                  |L2.1080|
000438  3510              ADDS     r5,r5,#0x10           ;1402
                  |L2.1082|
00043a  9830              LDR      r0,[sp,#0xc0]         ;1402
00043c  4285              CMP      r5,r0                 ;1402
00043e  d202              BCS      |L2.1094|
000440  980e              LDR      r0,[sp,#0x38]         ;1402
000442  2800              CMP      r0,#0                 ;1402
000444  d1a6              BNE      |L2.916|
                  |L2.1094|
000446  f44f3040          MOV      r0,#0x30000           ;1453
00044a  f7fffffe          BL       CRYP_PhaseConfig
00044e  2001              MOVS     r0,#1                 ;1456
000450  f7fffffe          BL       CRYP_Cmd
000454  f7fffffe          BL       CRYP_GetCmdStatus
000458  b908              CBNZ     r0,|L2.1118|
00045a  2000              MOVS     r0,#0                 ;1462
00045c  e74c              B        |L2.760|
                  |L2.1118|
00045e  ae04              ADD      r6,sp,#0x10           ;1465
000460  6830              LDR      r0,[r6,#0]            ;1467
000462  f7fffffe          BL       CRYP_DataIn
000466  1d36              ADDS     r6,r6,#4              ;1468
000468  6830              LDR      r0,[r6,#0]            ;1469
00046a  f7fffffe          BL       CRYP_DataIn
00046e  1d36              ADDS     r6,r6,#4              ;1470
000470  6830              LDR      r0,[r6,#0]            ;1471
000472  f7fffffe          BL       CRYP_DataIn
000476  1d36              ADDS     r6,r6,#4              ;1472
000478  6831              LDR      r1,[r6,#0]            ;1474
00047a  f0217080          BIC      r0,r1,#0x1000000      ;1474
00047e  f7fffffe          BL       CRYP_DataIn
000482  bf00              NOP                            ;1477
                  |L2.1156|
000484  2004              MOVS     r0,#4                 ;1477
000486  f7fffffe          BL       CRYP_GetFlagStatus
00048a  2800              CMP      r0,#0                 ;1477
00048c  d0fa              BEQ      |L2.1156|
00048e  f7fffffe          BL       CRYP_DataOut
000492  9000              STR      r0,[sp,#0]            ;1482
000494  f7fffffe          BL       CRYP_DataOut
000498  9001              STR      r0,[sp,#4]            ;1483
00049a  f7fffffe          BL       CRYP_DataOut
00049e  9002              STR      r0,[sp,#8]            ;1484
0004a0  f7fffffe          BL       CRYP_DataOut
0004a4  9003              STR      r0,[sp,#0xc]          ;1485
0004a6  e115              B        |L2.1748|
                  |L2.1192|
0004a8  f7fffffe          BL       CRYP_FIFOFlush
0004ac  a815              ADD      r0,sp,#0x54           ;1494
0004ae  f7fffffe          BL       CRYP_KeyInit
0004b2  a811              ADD      r0,sp,#0x44           ;1497
0004b4  f7fffffe          BL       CRYP_IVInit
0004b8  2004              MOVS     r0,#4                 ;1500
0004ba  901d              STR      r0,[sp,#0x74]         ;1500
0004bc  f04f1008          MOV      r0,#0x80008           ;1501
0004c0  901e              STR      r0,[sp,#0x78]         ;1501
0004c2  2080              MOVS     r0,#0x80              ;1502
0004c4  901f              STR      r0,[sp,#0x7c]         ;1502
0004c6  a81d              ADD      r0,sp,#0x74           ;1503
0004c8  f7fffffe          BL       CRYP_Init
0004cc  2000              MOVS     r0,#0                 ;1507
0004ce  f7fffffe          BL       CRYP_PhaseConfig
0004d2  f10d0b20          ADD      r11,sp,#0x20          ;1509
0004d6  f8db0000          LDR      r0,[r11,#0]           ;1511
0004da  f7fffffe          BL       CRYP_DataIn
0004de  f10b0b04          ADD      r11,r11,#4            ;1512
0004e2  f8db0000          LDR      r0,[r11,#0]           ;1513
0004e6  f7fffffe          BL       CRYP_DataIn
0004ea  f10b0b04          ADD      r11,r11,#4            ;1514
0004ee  f8db0000          LDR      r0,[r11,#0]           ;1515
0004f2  f7fffffe          BL       CRYP_DataIn
0004f6  f10b0b04          ADD      r11,r11,#4            ;1516
0004fa  f8db0000          LDR      r0,[r11,#0]           ;1517
0004fe  f7fffffe          BL       CRYP_DataIn
000502  2001              MOVS     r0,#1                 ;1520
000504  f7fffffe          BL       CRYP_Cmd
000508  bf00              NOP                            ;1523
                  |L2.1290|
00050a  f7fffffe          BL       CRYP_GetCmdStatus
00050e  2801              CMP      r0,#1                 ;1523
000510  d0fb              BEQ      |L2.1290|
000512  b3ef              CBZ      r7,|L2.1424|
000514  f44f3080          MOV      r0,#0x10000           ;1531
000518  f7fffffe          BL       CRYP_PhaseConfig
00051c  2001              MOVS     r0,#1                 ;1534
00051e  f7fffffe          BL       CRYP_Cmd
000522  f7fffffe          BL       CRYP_GetCmdStatus
000526  b908              CBNZ     r0,|L2.1324|
000528  2000              MOVS     r0,#0                 ;1540
00052a  e6e5              B        |L2.760|
                  |L2.1324|
00052c  2500              MOVS     r5,#0                 ;1543
00052e  e01e              B        |L2.1390|
                  |L2.1328|
000530  bf00              NOP                            ;1546
                  |L2.1330|
000532  2001              MOVS     r0,#1                 ;1546
000534  f7fffffe          BL       CRYP_GetFlagStatus
000538  2800              CMP      r0,#0                 ;1546
00053a  d0fa              BEQ      |L2.1330|
00053c  f8da0000          LDR      r0,[r10,#0]           ;1551
000540  f7fffffe          BL       CRYP_DataIn
000544  f10a0a04          ADD      r10,r10,#4            ;1552
000548  f8da0000          LDR      r0,[r10,#0]           ;1553
00054c  f7fffffe          BL       CRYP_DataIn
000550  f10a0a04          ADD      r10,r10,#4            ;1554
000554  f8da0000          LDR      r0,[r10,#0]           ;1555
000558  f7fffffe          BL       CRYP_DataIn
00055c  f10a0a04          ADD      r10,r10,#4            ;1556
000560  f8da0000          LDR      r0,[r10,#0]           ;1557
000564  f7fffffe          BL       CRYP_DataIn
000568  f10a0a04          ADD      r10,r10,#4            ;1558
00056c  3510              ADDS     r5,r5,#0x10           ;1543
                  |L2.1390|
00056e  42bd              CMP      r5,r7                 ;1543
000570  d3de              BCC      |L2.1328|
000572  2000              MOVS     r0,#0                 ;1562
000574  9010              STR      r0,[sp,#0x40]         ;1562
000576  bf00              NOP                            ;1563
                  |L2.1400|
000578  2010              MOVS     r0,#0x10              ;1565
00057a  f7fffffe          BL       CRYP_GetFlagStatus
00057e  900f              STR      r0,[sp,#0x3c]         ;1565
000580  9810              LDR      r0,[sp,#0x40]         ;1566
000582  1c40              ADDS     r0,r0,#1              ;1566
000584  9010              STR      r0,[sp,#0x40]         ;1566
000586  9810              LDR      r0,[sp,#0x40]         ;1567
000588  f5b03f80          CMP      r0,#0x10000           ;1567
00058c  d004              BEQ      |L2.1432|
00058e  e000              B        |L2.1426|
                  |L2.1424|
000590  e006              B        |L2.1440|
                  |L2.1426|
000592  980f              LDR      r0,[sp,#0x3c]         ;1567
000594  2800              CMP      r0,#0                 ;1567
000596  d1ef              BNE      |L2.1400|
                  |L2.1432|
000598  980f              LDR      r0,[sp,#0x3c]         ;1569
00059a  b108              CBZ      r0,|L2.1440|
00059c  2000              MOVS     r0,#0                 ;1571
00059e  900e              STR      r0,[sp,#0x38]         ;1571
                  |L2.1440|
0005a0  9830              LDR      r0,[sp,#0xc0]         ;1576
0005a2  2800              CMP      r0,#0                 ;1576
0005a4  d066              BEQ      |L2.1652|
0005a6  f44f3000          MOV      r0,#0x20000           ;1579
0005aa  f7fffffe          BL       CRYP_PhaseConfig
0005ae  2001              MOVS     r0,#1                 ;1582
0005b0  f7fffffe          BL       CRYP_Cmd
0005b4  f7fffffe          BL       CRYP_GetCmdStatus
0005b8  b908              CBNZ     r0,|L2.1470|
0005ba  2000              MOVS     r0,#0                 ;1588
0005bc  e69c              B        |L2.760|
                  |L2.1470|
0005be  2500              MOVS     r5,#0                 ;1591
0005c0  e052              B        |L2.1640|
                  |L2.1474|
0005c2  bf00              NOP                            ;1594
                  |L2.1476|
0005c4  2001              MOVS     r0,#1                 ;1594
0005c6  f7fffffe          BL       CRYP_GetFlagStatus
0005ca  2800              CMP      r0,#0                 ;1594
0005cc  d0fa              BEQ      |L2.1476|
0005ce  f8d80000          LDR      r0,[r8,#0]            ;1599
0005d2  f7fffffe          BL       CRYP_DataIn
0005d6  f1080804          ADD      r8,r8,#4              ;1600
0005da  f8d80000          LDR      r0,[r8,#0]            ;1601
0005de  f7fffffe          BL       CRYP_DataIn
0005e2  f1080804          ADD      r8,r8,#4              ;1602
0005e6  f8d80000          LDR      r0,[r8,#0]            ;1603
0005ea  f7fffffe          BL       CRYP_DataIn
0005ee  f1080804          ADD      r8,r8,#4              ;1604
0005f2  f8d80000          LDR      r0,[r8,#0]            ;1605
0005f6  f7fffffe          BL       CRYP_DataIn
0005fa  f1080804          ADD      r8,r8,#4              ;1606
0005fe  2000              MOVS     r0,#0                 ;1609
000600  9010              STR      r0,[sp,#0x40]         ;1609
000602  bf00              NOP                            ;1610
                  |L2.1540|
000604  2010              MOVS     r0,#0x10              ;1612
000606  f7fffffe          BL       CRYP_GetFlagStatus
00060a  900f              STR      r0,[sp,#0x3c]         ;1612
00060c  9810              LDR      r0,[sp,#0x40]         ;1613
00060e  1c40              ADDS     r0,r0,#1              ;1613
000610  9010              STR      r0,[sp,#0x40]         ;1613
000612  9810              LDR      r0,[sp,#0x40]         ;1614
000614  f5b03f80          CMP      r0,#0x10000           ;1614
000618  d002              BEQ      |L2.1568|
00061a  980f              LDR      r0,[sp,#0x3c]         ;1614
00061c  2800              CMP      r0,#0                 ;1614
00061e  d1f1              BNE      |L2.1540|
                  |L2.1568|
000620  980f              LDR      r0,[sp,#0x3c]         ;1616
000622  b110              CBZ      r0,|L2.1578|
000624  2000              MOVS     r0,#0                 ;1618
000626  900e              STR      r0,[sp,#0x38]         ;1618
000628  e01d              B        |L2.1638|
                  |L2.1578|
00062a  bf00              NOP                            ;1623
                  |L2.1580|
00062c  2004              MOVS     r0,#4                 ;1623
00062e  f7fffffe          BL       CRYP_GetFlagStatus
000632  2800              CMP      r0,#0                 ;1623
000634  d0fa              BEQ      |L2.1580|
000636  f7fffffe          BL       CRYP_DataOut
00063a  f8c90000          STR      r0,[r9,#0]            ;1628
00063e  f1090904          ADD      r9,r9,#4              ;1629
000642  f7fffffe          BL       CRYP_DataOut
000646  f8c90000          STR      r0,[r9,#0]            ;1630
00064a  f1090904          ADD      r9,r9,#4              ;1631
00064e  f7fffffe          BL       CRYP_DataOut
000652  f8c90000          STR      r0,[r9,#0]            ;1632
000656  f1090904          ADD      r9,r9,#4              ;1633
00065a  f7fffffe          BL       CRYP_DataOut
00065e  f8c90000          STR      r0,[r9,#0]            ;1634
000662  f1090904          ADD      r9,r9,#4              ;1635
                  |L2.1638|
000666  3510              ADDS     r5,r5,#0x10           ;1591
                  |L2.1640|
000668  9830              LDR      r0,[sp,#0xc0]         ;1591
00066a  4285              CMP      r5,r0                 ;1591
00066c  d202              BCS      |L2.1652|
00066e  980e              LDR      r0,[sp,#0x38]         ;1591
000670  2800              CMP      r0,#0                 ;1591
000672  d1a6              BNE      |L2.1474|
                  |L2.1652|
000674  f44f3040          MOV      r0,#0x30000           ;1642
000678  f7fffffe          BL       CRYP_PhaseConfig
00067c  2001              MOVS     r0,#1                 ;1645
00067e  f7fffffe          BL       CRYP_Cmd
000682  f7fffffe          BL       CRYP_GetCmdStatus
000686  b908              CBNZ     r0,|L2.1676|
000688  2000              MOVS     r0,#0                 ;1651
00068a  e635              B        |L2.760|
                  |L2.1676|
00068c  ae04              ADD      r6,sp,#0x10           ;1654
00068e  6830              LDR      r0,[r6,#0]            ;1656
000690  f7fffffe          BL       CRYP_DataIn
000694  1d36              ADDS     r6,r6,#4              ;1657
000696  6830              LDR      r0,[r6,#0]            ;1658
000698  f7fffffe          BL       CRYP_DataIn
00069c  1d36              ADDS     r6,r6,#4              ;1659
00069e  6830              LDR      r0,[r6,#0]            ;1660
0006a0  f7fffffe          BL       CRYP_DataIn
0006a4  1d36              ADDS     r6,r6,#4              ;1661
0006a6  6831              LDR      r1,[r6,#0]            ;1663
0006a8  f0217080          BIC      r0,r1,#0x1000000      ;1663
0006ac  f7fffffe          BL       CRYP_DataIn
0006b0  bf00              NOP                            ;1666
                  |L2.1714|
0006b2  2004              MOVS     r0,#4                 ;1666
0006b4  f7fffffe          BL       CRYP_GetFlagStatus
0006b8  2800              CMP      r0,#0                 ;1666
0006ba  d0fa              BEQ      |L2.1714|
0006bc  f7fffffe          BL       CRYP_DataOut
0006c0  9000              STR      r0,[sp,#0]            ;1671
0006c2  f7fffffe          BL       CRYP_DataOut
0006c6  9001              STR      r0,[sp,#4]            ;1672
0006c8  f7fffffe          BL       CRYP_DataOut
0006cc  9002              STR      r0,[sp,#8]            ;1673
0006ce  f7fffffe          BL       CRYP_DataOut
0006d2  9003              STR      r0,[sp,#0xc]          ;1674
                  |L2.1748|
0006d4  2500              MOVS     r5,#0                 ;1678
0006d6  e004              B        |L2.1762|
                  |L2.1752|
0006d8  f81d1005          LDRB     r1,[sp,r5]            ;1681
0006dc  980d              LDR      r0,[sp,#0x34]         ;1681
0006de  5541              STRB     r1,[r0,r5]            ;1681
0006e0  1c6d              ADDS     r5,r5,#1              ;1678
                  |L2.1762|
0006e2  9836              LDR      r0,[sp,#0xd8]         ;1678
0006e4  4285              CMP      r5,r0                 ;1678
0006e6  d3f7              BCC      |L2.1752|
0006e8  2000              MOVS     r0,#0                 ;1685
0006ea  f7fffffe          BL       CRYP_Cmd
0006ee  980e              LDR      r0,[sp,#0x38]         ;1687
0006f0  e602              B        |L2.760|
;;;1689   
                          ENDP


                          AREA ||i.CRYP_AES_CTR||, CODE, READONLY, ALIGN=1

                  CRYP_AES_CTR PROC
;;;495      */
;;;496    ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;497                             uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
;;;498                             uint8_t *Output)
;;;499    {
000004  b095              SUB      sp,sp,#0x54
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  4692              MOV      r10,r2
00000c  469b              MOV      r11,r3
;;;500      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;501      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;502      CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
;;;503      __IO uint32_t counter = 0;
00000e  2000              MOVS     r0,#0
000010  9004              STR      r0,[sp,#0x10]
;;;504      uint32_t busystatus = 0;
000012  9003              STR      r0,[sp,#0xc]
;;;505      ErrorStatus status = SUCCESS;
000014  2001              MOVS     r0,#1
000016  9002              STR      r0,[sp,#8]
;;;506      uint32_t keyaddr    = (uint32_t)Key;
000018  4654              MOV      r4,r10
;;;507      uint32_t inputaddr  = (uint32_t)Input;
00001a  9d1e              LDR      r5,[sp,#0x78]
;;;508      uint32_t outputaddr = (uint32_t)Output;
00001c  9e20              LDR      r6,[sp,#0x80]
;;;509      uint32_t ivaddr     = (uint32_t)InitVectors;
00001e  464f              MOV      r7,r9
;;;510      uint32_t i = 0;
000020  2000              MOVS     r0,#0
000022  9001              STR      r0,[sp,#4]
;;;511    
;;;512      /* Crypto structures initialisation*/
;;;513      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
000024  a809              ADD      r0,sp,#0x24
000026  f7fffffe          BL       CRYP_KeyStructInit
;;;514    
;;;515      switch(Keysize)
00002a  f1bb0f80          CMP      r11,#0x80
00002e  d006              BEQ      |L3.62|
000030  f1bb0fc0          CMP      r11,#0xc0
000034  d015              BEQ      |L3.98|
000036  f5bb7f80          CMP      r11,#0x100
00003a  d150              BNE      |L3.222|
00003c  e02c              B        |L3.152|
                  |L3.62|
;;;516      {
;;;517        case 128:
;;;518        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
00003e  2000              MOVS     r0,#0
000040  9014              STR      r0,[sp,#0x50]
;;;519        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000042  6820              LDR      r0,[r4,#0]
000044  ba00              REV      r0,r0
000046  900d              STR      r0,[sp,#0x34]
;;;520        keyaddr+=4;
000048  1d24              ADDS     r4,r4,#4
;;;521        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
00004a  6820              LDR      r0,[r4,#0]
00004c  ba00              REV      r0,r0
00004e  900e              STR      r0,[sp,#0x38]
;;;522        keyaddr+=4;
000050  1d24              ADDS     r4,r4,#4
;;;523        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
000052  6820              LDR      r0,[r4,#0]
000054  ba00              REV      r0,r0
000056  900f              STR      r0,[sp,#0x3c]
;;;524        keyaddr+=4;
000058  1d24              ADDS     r4,r4,#4
;;;525        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
00005a  6820              LDR      r0,[r4,#0]
00005c  ba00              REV      r0,r0
00005e  9010              STR      r0,[sp,#0x40]
;;;526        break;
000060  e03e              B        |L3.224|
                  |L3.98|
;;;527        case 192:
;;;528        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
000062  f44f7080          MOV      r0,#0x100
000066  9014              STR      r0,[sp,#0x50]
;;;529        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000068  6820              LDR      r0,[r4,#0]
00006a  ba00              REV      r0,r0
00006c  900b              STR      r0,[sp,#0x2c]
;;;530        keyaddr+=4;
00006e  1d24              ADDS     r4,r4,#4
;;;531        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
000070  6820              LDR      r0,[r4,#0]
000072  ba00              REV      r0,r0
000074  900c              STR      r0,[sp,#0x30]
;;;532        keyaddr+=4;
000076  1d24              ADDS     r4,r4,#4
;;;533        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000078  6820              LDR      r0,[r4,#0]
00007a  ba00              REV      r0,r0
00007c  900d              STR      r0,[sp,#0x34]
;;;534        keyaddr+=4;
00007e  1d24              ADDS     r4,r4,#4
;;;535        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000080  6820              LDR      r0,[r4,#0]
000082  ba00              REV      r0,r0
000084  900e              STR      r0,[sp,#0x38]
;;;536        keyaddr+=4;
000086  1d24              ADDS     r4,r4,#4
;;;537        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
000088  6820              LDR      r0,[r4,#0]
00008a  ba00              REV      r0,r0
00008c  900f              STR      r0,[sp,#0x3c]
;;;538        keyaddr+=4;
00008e  1d24              ADDS     r4,r4,#4
;;;539        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000090  6820              LDR      r0,[r4,#0]
000092  ba00              REV      r0,r0
000094  9010              STR      r0,[sp,#0x40]
;;;540        break;
000096  e023              B        |L3.224|
                  |L3.152|
;;;541        case 256:
;;;542        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000098  f44f7000          MOV      r0,#0x200
00009c  9014              STR      r0,[sp,#0x50]
;;;543        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
00009e  6820              LDR      r0,[r4,#0]
0000a0  ba00              REV      r0,r0
0000a2  9009              STR      r0,[sp,#0x24]
;;;544        keyaddr+=4;
0000a4  1d24              ADDS     r4,r4,#4
;;;545        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
0000a6  6820              LDR      r0,[r4,#0]
0000a8  ba00              REV      r0,r0
0000aa  900a              STR      r0,[sp,#0x28]
;;;546        keyaddr+=4;
0000ac  1d24              ADDS     r4,r4,#4
;;;547        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
0000ae  6820              LDR      r0,[r4,#0]
0000b0  ba00              REV      r0,r0
0000b2  900b              STR      r0,[sp,#0x2c]
;;;548        keyaddr+=4;
0000b4  1d24              ADDS     r4,r4,#4
;;;549        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
0000b6  6820              LDR      r0,[r4,#0]
0000b8  ba00              REV      r0,r0
0000ba  900c              STR      r0,[sp,#0x30]
;;;550        keyaddr+=4;
0000bc  1d24              ADDS     r4,r4,#4
;;;551        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
0000be  6820              LDR      r0,[r4,#0]
0000c0  ba00              REV      r0,r0
0000c2  900d              STR      r0,[sp,#0x34]
;;;552        keyaddr+=4;
0000c4  1d24              ADDS     r4,r4,#4
;;;553        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
0000c6  6820              LDR      r0,[r4,#0]
0000c8  ba00              REV      r0,r0
0000ca  900e              STR      r0,[sp,#0x38]
;;;554        keyaddr+=4;
0000cc  1d24              ADDS     r4,r4,#4
;;;555        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
0000ce  6820              LDR      r0,[r4,#0]
0000d0  ba00              REV      r0,r0
0000d2  900f              STR      r0,[sp,#0x3c]
;;;556        keyaddr+=4;
0000d4  1d24              ADDS     r4,r4,#4
;;;557        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
0000d6  6820              LDR      r0,[r4,#0]
0000d8  ba00              REV      r0,r0
0000da  9010              STR      r0,[sp,#0x40]
;;;558        break;
0000dc  e000              B        |L3.224|
                  |L3.222|
;;;559        default:
;;;560        break;
0000de  bf00              NOP      
                  |L3.224|
0000e0  bf00              NOP                            ;526
;;;561      }
;;;562      /* CRYP Initialization Vectors */
;;;563      AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
0000e2  6838              LDR      r0,[r7,#0]
0000e4  ba00              REV      r0,r0
0000e6  9005              STR      r0,[sp,#0x14]
;;;564      ivaddr+=4;
0000e8  1d3f              ADDS     r7,r7,#4
;;;565      AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
0000ea  6838              LDR      r0,[r7,#0]
0000ec  ba00              REV      r0,r0
0000ee  9006              STR      r0,[sp,#0x18]
;;;566      ivaddr+=4;
0000f0  1d3f              ADDS     r7,r7,#4
;;;567      AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
0000f2  6838              LDR      r0,[r7,#0]
0000f4  ba00              REV      r0,r0
0000f6  9007              STR      r0,[sp,#0x1c]
;;;568      ivaddr+=4;
0000f8  1d3f              ADDS     r7,r7,#4
;;;569      AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
0000fa  6838              LDR      r0,[r7,#0]
0000fc  ba00              REV      r0,r0
0000fe  9008              STR      r0,[sp,#0x20]
;;;570    
;;;571      /* Key Initialisation */
;;;572      CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
000100  a809              ADD      r0,sp,#0x24
000102  f7fffffe          BL       CRYP_KeyInit
;;;573    
;;;574      /*------------------ AES Decryption ------------------*/
;;;575      if(Mode == MODE_DECRYPT) /* AES decryption */
000106  f1b80f00          CMP      r8,#0
00010a  d102              BNE      |L3.274|
;;;576      {
;;;577        /* Crypto Init for decryption process */
;;;578        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
00010c  2004              MOVS     r0,#4
00010e  9011              STR      r0,[sp,#0x44]
000110  e001              B        |L3.278|
                  |L3.274|
;;;579      }
;;;580      /*------------------ AES Encryption ------------------*/
;;;581      else /* AES encryption */
;;;582      {
;;;583        /* Crypto Init for Encryption process */
;;;584        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
000112  2000              MOVS     r0,#0
000114  9011              STR      r0,[sp,#0x44]
                  |L3.278|
;;;585      }
;;;586      AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
000116  2030              MOVS     r0,#0x30
000118  9012              STR      r0,[sp,#0x48]
;;;587      AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00011a  2080              MOVS     r0,#0x80
00011c  9013              STR      r0,[sp,#0x4c]
;;;588      CRYP_Init(&AES_CRYP_InitStructure);
00011e  a811              ADD      r0,sp,#0x44
000120  f7fffffe          BL       CRYP_Init
;;;589    
;;;590      /* CRYP Initialization Vectors */
;;;591      CRYP_IVInit(&AES_CRYP_IVInitStructure);
000124  a805              ADD      r0,sp,#0x14
000126  f7fffffe          BL       CRYP_IVInit
;;;592    
;;;593      /* Flush IN/OUT FIFOs */
;;;594      CRYP_FIFOFlush();
00012a  f7fffffe          BL       CRYP_FIFOFlush
;;;595    
;;;596      /* Enable Crypto processor */
;;;597      CRYP_Cmd(ENABLE);
00012e  2001              MOVS     r0,#1
000130  f7fffffe          BL       CRYP_Cmd
;;;598    
;;;599      if(CRYP_GetCmdStatus() == DISABLE)
000134  f7fffffe          BL       CRYP_GetCmdStatus
000138  b918              CBNZ     r0,|L3.322|
;;;600      {
;;;601        /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;602           the CRYP peripheral (please check the device sales type. */
;;;603        return(ERROR);
00013a  2000              MOVS     r0,#0
                  |L3.316|
;;;604      }
;;;605      
;;;606      for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
;;;607      {
;;;608    
;;;609        /* Write the Input block in the IN FIFO */
;;;610        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;611        inputaddr+=4;
;;;612        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;613        inputaddr+=4;
;;;614        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;615        inputaddr+=4;
;;;616        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;617        inputaddr+=4;
;;;618        /* Wait until the complete message has been processed */
;;;619        counter = 0;
;;;620        do
;;;621        {
;;;622          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;623          counter++;
;;;624        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;625    
;;;626        if (busystatus != RESET)
;;;627       {
;;;628           status = ERROR;
;;;629        }
;;;630        else
;;;631        {
;;;632    
;;;633          /* Read the Output block from the Output FIFO */
;;;634          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;635          outputaddr+=4;
;;;636          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;637          outputaddr+=4;
;;;638          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;639          outputaddr+=4;
;;;640          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;641          outputaddr+=4;
;;;642        }
;;;643      }
;;;644      /* Disable Crypto */
;;;645      CRYP_Cmd(DISABLE);
;;;646    
;;;647      return status;
;;;648    }
00013c  b015              ADD      sp,sp,#0x54
00013e  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.322|
000142  2000              MOVS     r0,#0                 ;606
000144  9001              STR      r0,[sp,#4]            ;606
000146  e038              B        |L3.442|
                  |L3.328|
000148  6828              LDR      r0,[r5,#0]            ;610
00014a  f7fffffe          BL       CRYP_DataIn
00014e  1d2d              ADDS     r5,r5,#4              ;611
000150  6828              LDR      r0,[r5,#0]            ;612
000152  f7fffffe          BL       CRYP_DataIn
000156  1d2d              ADDS     r5,r5,#4              ;613
000158  6828              LDR      r0,[r5,#0]            ;614
00015a  f7fffffe          BL       CRYP_DataIn
00015e  1d2d              ADDS     r5,r5,#4              ;615
000160  6828              LDR      r0,[r5,#0]            ;616
000162  f7fffffe          BL       CRYP_DataIn
000166  1d2d              ADDS     r5,r5,#4              ;617
000168  2000              MOVS     r0,#0                 ;619
00016a  9004              STR      r0,[sp,#0x10]         ;619
00016c  bf00              NOP                            ;620
                  |L3.366|
00016e  2010              MOVS     r0,#0x10              ;622
000170  f7fffffe          BL       CRYP_GetFlagStatus
000174  9003              STR      r0,[sp,#0xc]          ;622
000176  9804              LDR      r0,[sp,#0x10]         ;623
000178  1c40              ADDS     r0,r0,#1              ;623
00017a  9004              STR      r0,[sp,#0x10]         ;623
00017c  9804              LDR      r0,[sp,#0x10]         ;624
00017e  f5b03f80          CMP      r0,#0x10000           ;624
000182  d002              BEQ      |L3.394|
000184  9803              LDR      r0,[sp,#0xc]          ;624
000186  2800              CMP      r0,#0                 ;624
000188  d1f1              BNE      |L3.366|
                  |L3.394|
00018a  9803              LDR      r0,[sp,#0xc]          ;626
00018c  b110              CBZ      r0,|L3.404|
00018e  2000              MOVS     r0,#0                 ;628
000190  9002              STR      r0,[sp,#8]            ;628
000192  e00f              B        |L3.436|
                  |L3.404|
000194  f7fffffe          BL       CRYP_DataOut
000198  6030              STR      r0,[r6,#0]            ;634
00019a  1d36              ADDS     r6,r6,#4              ;635
00019c  f7fffffe          BL       CRYP_DataOut
0001a0  6030              STR      r0,[r6,#0]            ;636
0001a2  1d36              ADDS     r6,r6,#4              ;637
0001a4  f7fffffe          BL       CRYP_DataOut
0001a8  6030              STR      r0,[r6,#0]            ;638
0001aa  1d36              ADDS     r6,r6,#4              ;639
0001ac  f7fffffe          BL       CRYP_DataOut
0001b0  6030              STR      r0,[r6,#0]            ;640
0001b2  1d36              ADDS     r6,r6,#4              ;641
                  |L3.436|
0001b4  9801              LDR      r0,[sp,#4]            ;606
0001b6  3010              ADDS     r0,r0,#0x10           ;606
0001b8  9001              STR      r0,[sp,#4]            ;606
                  |L3.442|
0001ba  991f              LDR      r1,[sp,#0x7c]         ;606
0001bc  9801              LDR      r0,[sp,#4]            ;606
0001be  4288              CMP      r0,r1                 ;606
0001c0  d202              BCS      |L3.456|
0001c2  9802              LDR      r0,[sp,#8]            ;606
0001c4  2800              CMP      r0,#0                 ;606
0001c6  d1bf              BNE      |L3.328|
                  |L3.456|
0001c8  2000              MOVS     r0,#0                 ;645
0001ca  f7fffffe          BL       CRYP_Cmd
0001ce  9802              LDR      r0,[sp,#8]            ;647
0001d0  e7b4              B        |L3.316|
;;;649    
                          ENDP


                          AREA ||i.CRYP_AES_ECB||, CODE, READONLY, ALIGN=1

                  CRYP_AES_ECB PROC
;;;105      */
;;;106    ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;107                             uint8_t* Input, uint32_t Ilength, uint8_t* Output)
;;;108    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  4692              MOV      r10,r2
00000c  469b              MOV      r11,r3
;;;109      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;110      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;111      __IO uint32_t counter = 0;
00000e  2000              MOVS     r0,#0
000010  9002              STR      r0,[sp,#8]
;;;112      uint32_t busystatus = 0;
000012  2700              MOVS     r7,#0
;;;113      ErrorStatus status = SUCCESS;
000014  2001              MOVS     r0,#1
000016  9001              STR      r0,[sp,#4]
;;;114      uint32_t keyaddr    = (uint32_t)Key;
000018  464c              MOV      r4,r9
;;;115      uint32_t inputaddr  = (uint32_t)Input;
00001a  465d              MOV      r5,r11
;;;116      uint32_t outputaddr = (uint32_t)Output;
00001c  9e19              LDR      r6,[sp,#0x64]
;;;117      uint32_t i = 0;
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
;;;118    
;;;119      /* Crypto structures initialisation*/
;;;120      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
000022  a803              ADD      r0,sp,#0xc
000024  f7fffffe          BL       CRYP_KeyStructInit
;;;121    
;;;122      switch(Keysize)
000028  f1ba0f80          CMP      r10,#0x80
00002c  d006              BEQ      |L4.60|
00002e  f1ba0fc0          CMP      r10,#0xc0
000032  d015              BEQ      |L4.96|
000034  f5ba7f80          CMP      r10,#0x100
000038  d150              BNE      |L4.220|
00003a  e02c              B        |L4.150|
                  |L4.60|
;;;123      {
;;;124        case 128:
;;;125        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
00003c  2000              MOVS     r0,#0
00003e  900e              STR      r0,[sp,#0x38]
;;;126        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000040  6820              LDR      r0,[r4,#0]
000042  ba00              REV      r0,r0
000044  9007              STR      r0,[sp,#0x1c]
;;;127        keyaddr+=4;
000046  1d24              ADDS     r4,r4,#4
;;;128        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000048  6820              LDR      r0,[r4,#0]
00004a  ba00              REV      r0,r0
00004c  9008              STR      r0,[sp,#0x20]
;;;129        keyaddr+=4;
00004e  1d24              ADDS     r4,r4,#4
;;;130        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
000050  6820              LDR      r0,[r4,#0]
000052  ba00              REV      r0,r0
000054  9009              STR      r0,[sp,#0x24]
;;;131        keyaddr+=4;
000056  1d24              ADDS     r4,r4,#4
;;;132        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000058  6820              LDR      r0,[r4,#0]
00005a  ba00              REV      r0,r0
00005c  900a              STR      r0,[sp,#0x28]
;;;133        break;
00005e  e03e              B        |L4.222|
                  |L4.96|
;;;134        case 192:
;;;135        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
000060  f44f7080          MOV      r0,#0x100
000064  900e              STR      r0,[sp,#0x38]
;;;136        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000066  6820              LDR      r0,[r4,#0]
000068  ba00              REV      r0,r0
00006a  9005              STR      r0,[sp,#0x14]
;;;137        keyaddr+=4;
00006c  1d24              ADDS     r4,r4,#4
;;;138        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00006e  6820              LDR      r0,[r4,#0]
000070  ba00              REV      r0,r0
000072  9006              STR      r0,[sp,#0x18]
;;;139        keyaddr+=4;
000074  1d24              ADDS     r4,r4,#4
;;;140        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000076  6820              LDR      r0,[r4,#0]
000078  ba00              REV      r0,r0
00007a  9007              STR      r0,[sp,#0x1c]
;;;141        keyaddr+=4;
00007c  1d24              ADDS     r4,r4,#4
;;;142        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
00007e  6820              LDR      r0,[r4,#0]
000080  ba00              REV      r0,r0
000082  9008              STR      r0,[sp,#0x20]
;;;143        keyaddr+=4;
000084  1d24              ADDS     r4,r4,#4
;;;144        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
000086  6820              LDR      r0,[r4,#0]
000088  ba00              REV      r0,r0
00008a  9009              STR      r0,[sp,#0x24]
;;;145        keyaddr+=4;
00008c  1d24              ADDS     r4,r4,#4
;;;146        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
00008e  6820              LDR      r0,[r4,#0]
000090  ba00              REV      r0,r0
000092  900a              STR      r0,[sp,#0x28]
;;;147        break;
000094  e023              B        |L4.222|
                  |L4.150|
;;;148        case 256:
;;;149        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000096  f44f7000          MOV      r0,#0x200
00009a  900e              STR      r0,[sp,#0x38]
;;;150        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
00009c  6820              LDR      r0,[r4,#0]
00009e  ba00              REV      r0,r0
0000a0  9003              STR      r0,[sp,#0xc]
;;;151        keyaddr+=4;
0000a2  1d24              ADDS     r4,r4,#4
;;;152        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
0000a4  6820              LDR      r0,[r4,#0]
0000a6  ba00              REV      r0,r0
0000a8  9004              STR      r0,[sp,#0x10]
;;;153        keyaddr+=4;
0000aa  1d24              ADDS     r4,r4,#4
;;;154        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
0000ac  6820              LDR      r0,[r4,#0]
0000ae  ba00              REV      r0,r0
0000b0  9005              STR      r0,[sp,#0x14]
;;;155        keyaddr+=4;
0000b2  1d24              ADDS     r4,r4,#4
;;;156        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
0000b4  6820              LDR      r0,[r4,#0]
0000b6  ba00              REV      r0,r0
0000b8  9006              STR      r0,[sp,#0x18]
;;;157        keyaddr+=4;
0000ba  1d24              ADDS     r4,r4,#4
;;;158        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
0000bc  6820              LDR      r0,[r4,#0]
0000be  ba00              REV      r0,r0
0000c0  9007              STR      r0,[sp,#0x1c]
;;;159        keyaddr+=4;
0000c2  1d24              ADDS     r4,r4,#4
;;;160        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
0000c4  6820              LDR      r0,[r4,#0]
0000c6  ba00              REV      r0,r0
0000c8  9008              STR      r0,[sp,#0x20]
;;;161        keyaddr+=4;
0000ca  1d24              ADDS     r4,r4,#4
;;;162        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
0000cc  6820              LDR      r0,[r4,#0]
0000ce  ba00              REV      r0,r0
0000d0  9009              STR      r0,[sp,#0x24]
;;;163        keyaddr+=4;
0000d2  1d24              ADDS     r4,r4,#4
;;;164        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
0000d4  6820              LDR      r0,[r4,#0]
0000d6  ba00              REV      r0,r0
0000d8  900a              STR      r0,[sp,#0x28]
;;;165        break;
0000da  e000              B        |L4.222|
                  |L4.220|
;;;166        default:
;;;167        break;
0000dc  bf00              NOP      
                  |L4.222|
0000de  bf00              NOP                            ;133
;;;168      }
;;;169    
;;;170      /*------------------ AES Decryption ------------------*/
;;;171      if(Mode == MODE_DECRYPT) /* AES decryption */
0000e0  f1b80f00          CMP      r8,#0
0000e4  d125              BNE      |L4.306|
;;;172      {
;;;173        /* Flush IN/OUT FIFOs */
;;;174        CRYP_FIFOFlush();
0000e6  f7fffffe          BL       CRYP_FIFOFlush
;;;175    
;;;176        /* Crypto Init for Key preparation for decryption process */
;;;177        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
0000ea  2004              MOVS     r0,#4
0000ec  900b              STR      r0,[sp,#0x2c]
;;;178        AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
0000ee  2038              MOVS     r0,#0x38
0000f0  900c              STR      r0,[sp,#0x30]
;;;179        AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
0000f2  2000              MOVS     r0,#0
0000f4  900d              STR      r0,[sp,#0x34]
;;;180        CRYP_Init(&AES_CRYP_InitStructure);
0000f6  a80b              ADD      r0,sp,#0x2c
0000f8  f7fffffe          BL       CRYP_Init
;;;181    
;;;182        /* Key Initialisation */
;;;183        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       CRYP_KeyInit
;;;184    
;;;185        /* Enable Crypto processor */
;;;186        CRYP_Cmd(ENABLE);
000102  2001              MOVS     r0,#1
000104  f7fffffe          BL       CRYP_Cmd
;;;187    
;;;188        /* wait until the Busy flag is RESET */
;;;189        do
000108  bf00              NOP      
                  |L4.266|
;;;190        {
;;;191          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
00010a  2010              MOVS     r0,#0x10
00010c  f7fffffe          BL       CRYP_GetFlagStatus
000110  4607              MOV      r7,r0
;;;192          counter++;
000112  9802              LDR      r0,[sp,#8]
000114  1c40              ADDS     r0,r0,#1
000116  9002              STR      r0,[sp,#8]
;;;193        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
000118  9802              LDR      r0,[sp,#8]
00011a  f5b03f80          CMP      r0,#0x10000
00011e  d001              BEQ      |L4.292|
000120  2f00              CMP      r7,#0
000122  d1f2              BNE      |L4.266|
                  |L4.292|
;;;194    
;;;195        if (busystatus != RESET)
000124  b117              CBZ      r7,|L4.300|
;;;196       {
;;;197           status = ERROR;
000126  2000              MOVS     r0,#0
000128  9001              STR      r0,[sp,#4]
00012a  e007              B        |L4.316|
                  |L4.300|
;;;198        }
;;;199        else
;;;200        {
;;;201          /* Crypto Init for decryption process */  
;;;202          AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
00012c  2004              MOVS     r0,#4
00012e  900b              STR      r0,[sp,#0x2c]
000130  e004              B        |L4.316|
                  |L4.306|
;;;203        }
;;;204      }
;;;205      /*------------------ AES Encryption ------------------*/
;;;206      else /* AES encryption */
;;;207      {
;;;208    
;;;209        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
000132  a803              ADD      r0,sp,#0xc
000134  f7fffffe          BL       CRYP_KeyInit
;;;210    
;;;211        /* Crypto Init for Encryption process */
;;;212        AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
000138  2000              MOVS     r0,#0
00013a  900b              STR      r0,[sp,#0x2c]
                  |L4.316|
;;;213      }
;;;214    
;;;215      AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
00013c  2020              MOVS     r0,#0x20
00013e  900c              STR      r0,[sp,#0x30]
;;;216      AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
000140  2080              MOVS     r0,#0x80
000142  900d              STR      r0,[sp,#0x34]
;;;217      CRYP_Init(&AES_CRYP_InitStructure);
000144  a80b              ADD      r0,sp,#0x2c
000146  f7fffffe          BL       CRYP_Init
;;;218    
;;;219      /* Flush IN/OUT FIFOs */
;;;220      CRYP_FIFOFlush();
00014a  f7fffffe          BL       CRYP_FIFOFlush
;;;221    
;;;222      /* Enable Crypto processor */
;;;223      CRYP_Cmd(ENABLE);
00014e  2001              MOVS     r0,#1
000150  f7fffffe          BL       CRYP_Cmd
;;;224    
;;;225      if(CRYP_GetCmdStatus() == DISABLE)
000154  f7fffffe          BL       CRYP_GetCmdStatus
000158  b918              CBNZ     r0,|L4.354|
;;;226      {
;;;227        /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;228           the CRYP peripheral (please check the device sales type. */
;;;229        return(ERROR);
00015a  2000              MOVS     r0,#0
                  |L4.348|
;;;230      }
;;;231      
;;;232      for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
;;;233      {
;;;234    
;;;235        /* Write the Input block in the IN FIFO */
;;;236        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;237        inputaddr+=4;
;;;238        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;239        inputaddr+=4;
;;;240        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;241        inputaddr+=4;
;;;242        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;243        inputaddr+=4;
;;;244    
;;;245        /* Wait until the complete message has been processed */
;;;246        counter = 0;
;;;247        do
;;;248        {
;;;249          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;250          counter++;
;;;251        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;252    
;;;253        if (busystatus != RESET)
;;;254       {
;;;255           status = ERROR;
;;;256        }
;;;257        else
;;;258        {
;;;259    
;;;260          /* Read the Output block from the Output FIFO */
;;;261          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;262          outputaddr+=4;
;;;263          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;264          outputaddr+=4;
;;;265          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;266          outputaddr+=4;
;;;267          *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
;;;268          outputaddr+=4;
;;;269        }
;;;270      }
;;;271    
;;;272      /* Disable Crypto */
;;;273      CRYP_Cmd(DISABLE);
;;;274    
;;;275      return status; 
;;;276    }
00015c  b00f              ADD      sp,sp,#0x3c
00015e  e8bd8ff0          POP      {r4-r11,pc}
                  |L4.354|
000162  2000              MOVS     r0,#0                 ;232
000164  9000              STR      r0,[sp,#0]            ;232
000166  e036              B        |L4.470|
                  |L4.360|
000168  6828              LDR      r0,[r5,#0]            ;236
00016a  f7fffffe          BL       CRYP_DataIn
00016e  1d2d              ADDS     r5,r5,#4              ;237
000170  6828              LDR      r0,[r5,#0]            ;238
000172  f7fffffe          BL       CRYP_DataIn
000176  1d2d              ADDS     r5,r5,#4              ;239
000178  6828              LDR      r0,[r5,#0]            ;240
00017a  f7fffffe          BL       CRYP_DataIn
00017e  1d2d              ADDS     r5,r5,#4              ;241
000180  6828              LDR      r0,[r5,#0]            ;242
000182  f7fffffe          BL       CRYP_DataIn
000186  1d2d              ADDS     r5,r5,#4              ;243
000188  2000              MOVS     r0,#0                 ;246
00018a  9002              STR      r0,[sp,#8]            ;246
00018c  bf00              NOP                            ;247
                  |L4.398|
00018e  2010              MOVS     r0,#0x10              ;249
000190  f7fffffe          BL       CRYP_GetFlagStatus
000194  4607              MOV      r7,r0                 ;249
000196  9802              LDR      r0,[sp,#8]            ;250
000198  1c40              ADDS     r0,r0,#1              ;250
00019a  9002              STR      r0,[sp,#8]            ;250
00019c  9802              LDR      r0,[sp,#8]            ;251
00019e  f5b03f80          CMP      r0,#0x10000           ;251
0001a2  d001              BEQ      |L4.424|
0001a4  2f00              CMP      r7,#0                 ;251
0001a6  d1f2              BNE      |L4.398|
                  |L4.424|
0001a8  b117              CBZ      r7,|L4.432|
0001aa  2000              MOVS     r0,#0                 ;255
0001ac  9001              STR      r0,[sp,#4]            ;255
0001ae  e00f              B        |L4.464|
                  |L4.432|
0001b0  f7fffffe          BL       CRYP_DataOut
0001b4  6030              STR      r0,[r6,#0]            ;261
0001b6  1d36              ADDS     r6,r6,#4              ;262
0001b8  f7fffffe          BL       CRYP_DataOut
0001bc  6030              STR      r0,[r6,#0]            ;263
0001be  1d36              ADDS     r6,r6,#4              ;264
0001c0  f7fffffe          BL       CRYP_DataOut
0001c4  6030              STR      r0,[r6,#0]            ;265
0001c6  1d36              ADDS     r6,r6,#4              ;266
0001c8  f7fffffe          BL       CRYP_DataOut
0001cc  6030              STR      r0,[r6,#0]            ;267
0001ce  1d36              ADDS     r6,r6,#4              ;268
                  |L4.464|
0001d0  9800              LDR      r0,[sp,#0]            ;232
0001d2  3010              ADDS     r0,r0,#0x10           ;232
0001d4  9000              STR      r0,[sp,#0]            ;232
                  |L4.470|
0001d6  9918              LDR      r1,[sp,#0x60]         ;232
0001d8  9800              LDR      r0,[sp,#0]            ;232
0001da  4288              CMP      r0,r1                 ;232
0001dc  d202              BCS      |L4.484|
0001de  9801              LDR      r0,[sp,#4]            ;232
0001e0  2800              CMP      r0,#0                 ;232
0001e2  d1c1              BNE      |L4.360|
                  |L4.484|
0001e4  2000              MOVS     r0,#0                 ;273
0001e6  f7fffffe          BL       CRYP_Cmd
0001ea  9801              LDR      r0,[sp,#4]            ;275
0001ec  e7b6              B        |L4.348|
;;;277    
                          ENDP


                          AREA ||i.CRYP_AES_GCM||, CODE, READONLY, ALIGN=1

                  CRYP_AES_GCM PROC
;;;669      */
;;;670    ErrorStatus CRYP_AES_GCM(uint8_t Mode, uint8_t InitVectors[16],
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;671                             uint8_t *Key, uint16_t Keysize,
;;;672                             uint8_t *Input, uint32_t ILength,
;;;673                             uint8_t *Header, uint32_t HLength,
;;;674                             uint8_t *Output, uint8_t *AuthTAG)
;;;675    {
000004  b097              SUB      sp,sp,#0x5c
000006  f8ddb0a4          LDR      r11,[sp,#0xa4]
;;;676      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;677      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;678      CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
;;;679      __IO uint32_t counter = 0;
00000a  2000              MOVS     r0,#0
00000c  9006              STR      r0,[sp,#0x18]
;;;680      uint32_t busystatus = 0;
00000e  4681              MOV      r9,r0
;;;681      ErrorStatus status = SUCCESS;
000010  2001              MOVS     r0,#1
000012  9005              STR      r0,[sp,#0x14]
;;;682      uint32_t keyaddr    = (uint32_t)Key;
000014  9c19              LDR      r4,[sp,#0x64]
;;;683      uint32_t inputaddr  = (uint32_t)Input;
000016  9d24              LDR      r5,[sp,#0x90]
;;;684      uint32_t outputaddr = (uint32_t)Output;
000018  9e28              LDR      r6,[sp,#0xa0]
;;;685      uint32_t ivaddr     = (uint32_t)InitVectors;
00001a  9818              LDR      r0,[sp,#0x60]
00001c  9004              STR      r0,[sp,#0x10]
;;;686      uint32_t headeraddr = (uint32_t)Header;
00001e  9f26              LDR      r7,[sp,#0x98]
;;;687      uint32_t tagaddr = (uint32_t)AuthTAG;
000020  46d8              MOV      r8,r11
;;;688      uint64_t headerlength = HLength * 8;/* header length in bits */
000022  9827              LDR      r0,[sp,#0x9c]
000024  00c0              LSLS     r0,r0,#3
000026  2100              MOVS     r1,#0
000028  e9cd0102          STRD     r0,r1,[sp,#8]
;;;689      uint64_t inputlength = ILength * 8;/* input length in bits */
00002c  9825              LDR      r0,[sp,#0x94]
00002e  00c0              LSLS     r0,r0,#3
000030  e9cd0100          STRD     r0,r1,[sp,#0]
;;;690      uint32_t loopcounter = 0;
000034  468a              MOV      r10,r1
;;;691    
;;;692      /* Crypto structures initialisation*/
;;;693      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
000036  a80b              ADD      r0,sp,#0x2c
000038  f7fffffe          BL       CRYP_KeyStructInit
;;;694    
;;;695      switch(Keysize)
00003c  981a              LDR      r0,[sp,#0x68]
00003e  2880              CMP      r0,#0x80
000040  d005              BEQ      |L5.78|
000042  28c0              CMP      r0,#0xc0
000044  d015              BEQ      |L5.114|
000046  f5b07f80          CMP      r0,#0x100
00004a  d150              BNE      |L5.238|
00004c  e02c              B        |L5.168|
                  |L5.78|
;;;696      {
;;;697        case 128:
;;;698        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
00004e  2000              MOVS     r0,#0
000050  9016              STR      r0,[sp,#0x58]
;;;699        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000052  6820              LDR      r0,[r4,#0]
000054  ba00              REV      r0,r0
000056  900f              STR      r0,[sp,#0x3c]
;;;700        keyaddr+=4;
000058  1d24              ADDS     r4,r4,#4
;;;701        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
00005a  6820              LDR      r0,[r4,#0]
00005c  ba00              REV      r0,r0
00005e  9010              STR      r0,[sp,#0x40]
;;;702        keyaddr+=4;
000060  1d24              ADDS     r4,r4,#4
;;;703        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
000062  6820              LDR      r0,[r4,#0]
000064  ba00              REV      r0,r0
000066  9011              STR      r0,[sp,#0x44]
;;;704        keyaddr+=4;
000068  1d24              ADDS     r4,r4,#4
;;;705        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
00006a  6820              LDR      r0,[r4,#0]
00006c  ba00              REV      r0,r0
00006e  9012              STR      r0,[sp,#0x48]
;;;706        break;
000070  e03e              B        |L5.240|
                  |L5.114|
;;;707        case 192:
;;;708        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
000072  f44f7080          MOV      r0,#0x100
000076  9016              STR      r0,[sp,#0x58]
;;;709        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000078  6820              LDR      r0,[r4,#0]
00007a  ba00              REV      r0,r0
00007c  900d              STR      r0,[sp,#0x34]
;;;710        keyaddr+=4;
00007e  1d24              ADDS     r4,r4,#4
;;;711        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
000080  6820              LDR      r0,[r4,#0]
000082  ba00              REV      r0,r0
000084  900e              STR      r0,[sp,#0x38]
;;;712        keyaddr+=4;
000086  1d24              ADDS     r4,r4,#4
;;;713        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000088  6820              LDR      r0,[r4,#0]
00008a  ba00              REV      r0,r0
00008c  900f              STR      r0,[sp,#0x3c]
;;;714        keyaddr+=4;
00008e  1d24              ADDS     r4,r4,#4
;;;715        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000090  6820              LDR      r0,[r4,#0]
000092  ba00              REV      r0,r0
000094  9010              STR      r0,[sp,#0x40]
;;;716        keyaddr+=4;
000096  1d24              ADDS     r4,r4,#4
;;;717        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
000098  6820              LDR      r0,[r4,#0]
00009a  ba00              REV      r0,r0
00009c  9011              STR      r0,[sp,#0x44]
;;;718        keyaddr+=4;
00009e  1d24              ADDS     r4,r4,#4
;;;719        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
0000a0  6820              LDR      r0,[r4,#0]
0000a2  ba00              REV      r0,r0
0000a4  9012              STR      r0,[sp,#0x48]
;;;720        break;
0000a6  e023              B        |L5.240|
                  |L5.168|
;;;721        case 256:
;;;722        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
0000a8  f44f7000          MOV      r0,#0x200
0000ac  9016              STR      r0,[sp,#0x58]
;;;723        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
0000ae  6820              LDR      r0,[r4,#0]
0000b0  ba00              REV      r0,r0
0000b2  900b              STR      r0,[sp,#0x2c]
;;;724        keyaddr+=4;
0000b4  1d24              ADDS     r4,r4,#4
;;;725        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
0000b6  6820              LDR      r0,[r4,#0]
0000b8  ba00              REV      r0,r0
0000ba  900c              STR      r0,[sp,#0x30]
;;;726        keyaddr+=4;
0000bc  1d24              ADDS     r4,r4,#4
;;;727        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
0000be  6820              LDR      r0,[r4,#0]
0000c0  ba00              REV      r0,r0
0000c2  900d              STR      r0,[sp,#0x34]
;;;728        keyaddr+=4;
0000c4  1d24              ADDS     r4,r4,#4
;;;729        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
0000c6  6820              LDR      r0,[r4,#0]
0000c8  ba00              REV      r0,r0
0000ca  900e              STR      r0,[sp,#0x38]
;;;730        keyaddr+=4;
0000cc  1d24              ADDS     r4,r4,#4
;;;731        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
0000ce  6820              LDR      r0,[r4,#0]
0000d0  ba00              REV      r0,r0
0000d2  900f              STR      r0,[sp,#0x3c]
;;;732        keyaddr+=4;
0000d4  1d24              ADDS     r4,r4,#4
;;;733        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
0000d6  6820              LDR      r0,[r4,#0]
0000d8  ba00              REV      r0,r0
0000da  9010              STR      r0,[sp,#0x40]
;;;734        keyaddr+=4;
0000dc  1d24              ADDS     r4,r4,#4
;;;735        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
0000de  6820              LDR      r0,[r4,#0]
0000e0  ba00              REV      r0,r0
0000e2  9011              STR      r0,[sp,#0x44]
;;;736        keyaddr+=4;
0000e4  1d24              ADDS     r4,r4,#4
;;;737        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
0000e6  6820              LDR      r0,[r4,#0]
0000e8  ba00              REV      r0,r0
0000ea  9012              STR      r0,[sp,#0x48]
;;;738        break;
0000ec  e000              B        |L5.240|
                  |L5.238|
;;;739        default:
;;;740        break;
0000ee  bf00              NOP      
                  |L5.240|
0000f0  bf00              NOP                            ;706
;;;741      }
;;;742      
;;;743      /* CRYP Initialization Vectors */
;;;744      AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
0000f2  9804              LDR      r0,[sp,#0x10]
0000f4  6800              LDR      r0,[r0,#0]
0000f6  ba00              REV      r0,r0
0000f8  9007              STR      r0,[sp,#0x1c]
;;;745      ivaddr+=4;
0000fa  9804              LDR      r0,[sp,#0x10]
0000fc  1d00              ADDS     r0,r0,#4
0000fe  9004              STR      r0,[sp,#0x10]
;;;746      AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
000100  9804              LDR      r0,[sp,#0x10]
000102  6800              LDR      r0,[r0,#0]
000104  ba00              REV      r0,r0
000106  9008              STR      r0,[sp,#0x20]
;;;747      ivaddr+=4;
000108  9804              LDR      r0,[sp,#0x10]
00010a  1d00              ADDS     r0,r0,#4
00010c  9004              STR      r0,[sp,#0x10]
;;;748      AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
00010e  9804              LDR      r0,[sp,#0x10]
000110  6800              LDR      r0,[r0,#0]
000112  ba00              REV      r0,r0
000114  9009              STR      r0,[sp,#0x24]
;;;749      ivaddr+=4;
000116  9804              LDR      r0,[sp,#0x10]
000118  1d00              ADDS     r0,r0,#4
00011a  9004              STR      r0,[sp,#0x10]
;;;750      AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
00011c  9804              LDR      r0,[sp,#0x10]
00011e  6800              LDR      r0,[r0,#0]
000120  ba00              REV      r0,r0
000122  900a              STR      r0,[sp,#0x28]
;;;751      
;;;752      /*------------------ AES Encryption ------------------*/
;;;753      if(Mode == MODE_ENCRYPT) /* AES encryption */
000124  9817              LDR      r0,[sp,#0x5c]
000126  2801              CMP      r0,#1
000128  d170              BNE      |L5.524|
;;;754      {
;;;755        /* Flush IN/OUT FIFOs */
;;;756        CRYP_FIFOFlush();
00012a  f7fffffe          BL       CRYP_FIFOFlush
;;;757        
;;;758        /* Key Initialisation */
;;;759        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
00012e  a80b              ADD      r0,sp,#0x2c
000130  f7fffffe          BL       CRYP_KeyInit
;;;760        
;;;761        /* CRYP Initialization Vectors */
;;;762        CRYP_IVInit(&AES_CRYP_IVInitStructure);
000134  a807              ADD      r0,sp,#0x1c
000136  f7fffffe          BL       CRYP_IVInit
;;;763        
;;;764        /* Crypto Init for Key preparation for decryption process */
;;;765        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
00013a  2000              MOVS     r0,#0
00013c  9013              STR      r0,[sp,#0x4c]
;;;766        AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
00013e  f44f2000          MOV      r0,#0x80000
000142  9014              STR      r0,[sp,#0x50]
;;;767        AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
000144  2080              MOVS     r0,#0x80
000146  9015              STR      r0,[sp,#0x54]
;;;768        CRYP_Init(&AES_CRYP_InitStructure);
000148  a813              ADD      r0,sp,#0x4c
00014a  f7fffffe          BL       CRYP_Init
;;;769        
;;;770        /***************************** Init phase *********************************/
;;;771        /* Select init phase */
;;;772        CRYP_PhaseConfig(CRYP_Phase_Init);
00014e  2000              MOVS     r0,#0
000150  f7fffffe          BL       CRYP_PhaseConfig
;;;773        
;;;774        /* Enable Crypto processor */
;;;775        CRYP_Cmd(ENABLE);
000154  2001              MOVS     r0,#1
000156  f7fffffe          BL       CRYP_Cmd
;;;776        
;;;777        /* Wait for CRYPEN bit to be 0 */
;;;778        while(CRYP_GetCmdStatus() == ENABLE)
00015a  bf00              NOP      
                  |L5.348|
00015c  f7fffffe          BL       CRYP_GetCmdStatus
000160  2801              CMP      r0,#1
000162  d0fb              BEQ      |L5.348|
;;;779        {
;;;780        }
;;;781        
;;;782        /***************************** header phase *******************************/
;;;783        if(HLength != 0)
000164  9827              LDR      r0,[sp,#0x9c]
000166  2800              CMP      r0,#0
000168  d041              BEQ      |L5.494|
;;;784        {
;;;785          /* Select header phase */
;;;786          CRYP_PhaseConfig(CRYP_Phase_Header);
00016a  f44f3080          MOV      r0,#0x10000
00016e  f7fffffe          BL       CRYP_PhaseConfig
;;;787          
;;;788          /* Enable Crypto processor */
;;;789          CRYP_Cmd(ENABLE);
000172  2001              MOVS     r0,#1
000174  f7fffffe          BL       CRYP_Cmd
;;;790          
;;;791          if(CRYP_GetCmdStatus() == DISABLE)
000178  f7fffffe          BL       CRYP_GetCmdStatus
00017c  b918              CBNZ     r0,|L5.390|
;;;792          {
;;;793             /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;794                the CRYP peripheral (please check the device sales type. */
;;;795             return(ERROR);
00017e  2000              MOVS     r0,#0
                  |L5.384|
;;;796          }
;;;797          
;;;798          for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
;;;799          {
;;;800            /* Wait until the IFEM flag is reset */
;;;801            while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;802            {
;;;803            }
;;;804            
;;;805            /* Write the Input block in the IN FIFO */
;;;806            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;807            headeraddr+=4;
;;;808            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;809            headeraddr+=4;
;;;810            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;811            headeraddr+=4;
;;;812            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;813            headeraddr+=4;
;;;814          }
;;;815          
;;;816          /* Wait until the complete message has been processed */
;;;817          counter = 0;
;;;818          do
;;;819          {
;;;820            busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;821            counter++;
;;;822          }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;823    
;;;824          if (busystatus != RESET)
;;;825          {
;;;826            status = ERROR;
;;;827          }
;;;828        }
;;;829        
;;;830        /**************************** payload phase *******************************/
;;;831        if(ILength != 0)
;;;832        {
;;;833          /* Select payload phase */
;;;834          CRYP_PhaseConfig(CRYP_Phase_Payload);
;;;835          
;;;836          /* Enable Crypto processor */
;;;837          CRYP_Cmd(ENABLE);
;;;838          
;;;839          if(CRYP_GetCmdStatus() == DISABLE)
;;;840          {
;;;841            /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;842               the CRYP peripheral (please check the device sales type. */
;;;843            return(ERROR);
;;;844          }
;;;845          
;;;846          for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
;;;847          {
;;;848            /* Wait until the IFEM flag is reset */
;;;849            while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;850            {
;;;851            }
;;;852            /* Write the Input block in the IN FIFO */
;;;853            CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;854            inputaddr+=4;
;;;855            CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;856            inputaddr+=4;
;;;857            CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;858            inputaddr+=4;
;;;859            CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;860            inputaddr+=4;
;;;861            
;;;862            /* Wait until the complete message has been processed */
;;;863            counter = 0;
;;;864            do
;;;865            {
;;;866              busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;867              counter++;
;;;868            }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;869    
;;;870            if (busystatus != RESET)
;;;871            {
;;;872              status = ERROR;
;;;873            }
;;;874            else
;;;875            {
;;;876              /* Wait until the OFNE flag is reset */
;;;877              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;878              {
;;;879              }
;;;880              
;;;881              /* Read the Output block from the Output FIFO */
;;;882              *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;883              outputaddr+=4;
;;;884              *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;885              outputaddr+=4;
;;;886              *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;887              outputaddr+=4;
;;;888              *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;889              outputaddr+=4;
;;;890            }
;;;891          }
;;;892        }
;;;893        
;;;894        /***************************** final phase ********************************/
;;;895        /* Select final phase */
;;;896        CRYP_PhaseConfig(CRYP_Phase_Final);
;;;897        
;;;898        /* Enable Crypto processor */
;;;899        CRYP_Cmd(ENABLE);
;;;900        
;;;901        if(CRYP_GetCmdStatus() == DISABLE)
;;;902        {
;;;903          /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;904             the CRYP peripheral (please check the device sales type. */
;;;905          return(ERROR);
;;;906        }
;;;907        
;;;908        /* Write number of bits concatenated with header in the IN FIFO */
;;;909        CRYP_DataIn(__REV(headerlength>>32));
;;;910        CRYP_DataIn(__REV(headerlength));
;;;911        CRYP_DataIn(__REV(inputlength>>32));
;;;912        CRYP_DataIn(__REV(inputlength));
;;;913        /* Wait until the OFNE flag is reset */
;;;914        while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;915        {
;;;916        }
;;;917        
;;;918        tagaddr = (uint32_t)AuthTAG;
;;;919        /* Read the Auth TAG in the IN FIFO */
;;;920        *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;921        tagaddr+=4;
;;;922        *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;923        tagaddr+=4;
;;;924        *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;925        tagaddr+=4;
;;;926        *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;927        tagaddr+=4;
;;;928      }
;;;929      /*------------------ AES Decryption ------------------*/
;;;930      else /* AES decryption */
;;;931      {
;;;932        /* Flush IN/OUT FIFOs */
;;;933        CRYP_FIFOFlush();
;;;934        
;;;935        /* Key Initialisation */
;;;936        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
;;;937        
;;;938        /* CRYP Initialization Vectors */
;;;939        CRYP_IVInit(&AES_CRYP_IVInitStructure);
;;;940        
;;;941        /* Crypto Init for Key preparation for decryption process */
;;;942        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;943        AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
;;;944        AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
;;;945        CRYP_Init(&AES_CRYP_InitStructure);
;;;946        
;;;947        /***************************** Init phase *********************************/
;;;948        /* Select init phase */
;;;949        CRYP_PhaseConfig(CRYP_Phase_Init);
;;;950        
;;;951        /* Enable Crypto processor */
;;;952        CRYP_Cmd(ENABLE);
;;;953        
;;;954        /* Wait for CRYPEN bit to be 0 */
;;;955        while(CRYP_GetCmdStatus() == ENABLE)
;;;956        {
;;;957        }
;;;958        
;;;959        /***************************** header phase *******************************/
;;;960        if(HLength != 0)
;;;961        {
;;;962          /* Select header phase */
;;;963          CRYP_PhaseConfig(CRYP_Phase_Header);
;;;964          
;;;965          /* Enable Crypto processor */
;;;966          CRYP_Cmd(ENABLE);
;;;967          
;;;968          if(CRYP_GetCmdStatus() == DISABLE)
;;;969          {
;;;970            /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;971               the CRYP peripheral (please check the device sales type. */
;;;972            return(ERROR);
;;;973          }
;;;974          
;;;975          for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
;;;976          {
;;;977            /* Wait until the IFEM flag is reset */
;;;978            while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;979            {
;;;980            }
;;;981            
;;;982            /* Write the Input block in the IN FIFO */
;;;983            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;984            headeraddr+=4;
;;;985            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;986            headeraddr+=4;
;;;987            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;988            headeraddr+=4;
;;;989            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;990            headeraddr+=4;
;;;991          }
;;;992          
;;;993          /* Wait until the complete message has been processed */
;;;994          counter = 0;
;;;995          do
;;;996          {
;;;997            busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;998            counter++;
;;;999          }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1000   
;;;1001         if (busystatus != RESET)
;;;1002         {
;;;1003           status = ERROR;
;;;1004         }
;;;1005       }
;;;1006       
;;;1007       /**************************** payload phase *******************************/
;;;1008       if(ILength != 0)
;;;1009       {
;;;1010         /* Select payload phase */
;;;1011         CRYP_PhaseConfig(CRYP_Phase_Payload);
;;;1012   
;;;1013         /* Enable Crypto processor */
;;;1014         CRYP_Cmd(ENABLE);
;;;1015         
;;;1016         if(CRYP_GetCmdStatus() == DISABLE)
;;;1017         {
;;;1018           /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;1019              the CRYP peripheral (please check the device sales type. */
;;;1020           return(ERROR);
;;;1021         }
;;;1022         
;;;1023         for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
;;;1024         {
;;;1025           /* Wait until the IFEM flag is reset */
;;;1026           while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;1027           {
;;;1028           }
;;;1029           /* Write the Input block in the IN FIFO */
;;;1030           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1031           inputaddr+=4;
;;;1032           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1033           inputaddr+=4;
;;;1034           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1035           inputaddr+=4;
;;;1036           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1037           inputaddr+=4;
;;;1038           
;;;1039           /* Wait until the complete message has been processed */
;;;1040           counter = 0;
;;;1041           do
;;;1042           {
;;;1043             busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;1044             counter++;
;;;1045           }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1046   
;;;1047           if (busystatus != RESET)
;;;1048           {
;;;1049             status = ERROR;
;;;1050           }
;;;1051           else
;;;1052           {
;;;1053             /* Wait until the OFNE flag is reset */
;;;1054             while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1055             {
;;;1056             }
;;;1057             
;;;1058             /* Read the Output block from the Output FIFO */
;;;1059             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1060             outputaddr+=4;
;;;1061             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1062             outputaddr+=4;
;;;1063             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1064             outputaddr+=4;
;;;1065             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1066             outputaddr+=4;
;;;1067           }
;;;1068         }
;;;1069       }
;;;1070       
;;;1071       /***************************** final phase ********************************/
;;;1072       /* Select final phase */
;;;1073       CRYP_PhaseConfig(CRYP_Phase_Final);
;;;1074   
;;;1075       /* Enable Crypto processor */
;;;1076       CRYP_Cmd(ENABLE);
;;;1077       
;;;1078       if(CRYP_GetCmdStatus() == DISABLE)
;;;1079       {
;;;1080         /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;1081            the CRYP peripheral (please check the device sales type. */
;;;1082         return(ERROR);
;;;1083       }
;;;1084       
;;;1085       /* Write number of bits concatenated with header in the IN FIFO */
;;;1086       CRYP_DataIn(__REV(headerlength>>32));
;;;1087       CRYP_DataIn(__REV(headerlength));
;;;1088       CRYP_DataIn(__REV(inputlength>>32));
;;;1089       CRYP_DataIn(__REV(inputlength));
;;;1090       /* Wait until the OFNE flag is reset */
;;;1091       while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1092       {
;;;1093       }
;;;1094       
;;;1095       tagaddr = (uint32_t)AuthTAG;
;;;1096       /* Read the Auth TAG in the IN FIFO */
;;;1097       *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;1098       tagaddr+=4;
;;;1099       *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;1100       tagaddr+=4;
;;;1101       *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;1102       tagaddr+=4;
;;;1103       *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;1104       tagaddr+=4;
;;;1105     }
;;;1106     /* Disable Crypto */
;;;1107     CRYP_Cmd(DISABLE);
;;;1108   
;;;1109     return status;
;;;1110   }
000180  b01b              ADD      sp,sp,#0x6c
000182  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.390|
000186  f04f0a00          MOV      r10,#0                ;798
00018a  e017              B        |L5.444|
                  |L5.396|
00018c  bf00              NOP                            ;801
                  |L5.398|
00018e  2001              MOVS     r0,#1                 ;801
000190  f7fffffe          BL       CRYP_GetFlagStatus
000194  2800              CMP      r0,#0                 ;801
000196  d0fa              BEQ      |L5.398|
000198  6838              LDR      r0,[r7,#0]            ;806
00019a  f7fffffe          BL       CRYP_DataIn
00019e  1d3f              ADDS     r7,r7,#4              ;807
0001a0  6838              LDR      r0,[r7,#0]            ;808
0001a2  f7fffffe          BL       CRYP_DataIn
0001a6  1d3f              ADDS     r7,r7,#4              ;809
0001a8  6838              LDR      r0,[r7,#0]            ;810
0001aa  f7fffffe          BL       CRYP_DataIn
0001ae  1d3f              ADDS     r7,r7,#4              ;811
0001b0  6838              LDR      r0,[r7,#0]            ;812
0001b2  f7fffffe          BL       CRYP_DataIn
0001b6  1d3f              ADDS     r7,r7,#4              ;813
0001b8  f10a0a10          ADD      r10,r10,#0x10         ;798
                  |L5.444|
0001bc  9827              LDR      r0,[sp,#0x9c]         ;798
0001be  4582              CMP      r10,r0                ;798
0001c0  d3e4              BCC      |L5.396|
0001c2  2000              MOVS     r0,#0                 ;817
0001c4  9006              STR      r0,[sp,#0x18]         ;817
0001c6  bf00              NOP                            ;818
                  |L5.456|
0001c8  2010              MOVS     r0,#0x10              ;820
0001ca  f7fffffe          BL       CRYP_GetFlagStatus
0001ce  4681              MOV      r9,r0                 ;820
0001d0  9806              LDR      r0,[sp,#0x18]         ;821
0001d2  1c40              ADDS     r0,r0,#1              ;821
0001d4  9006              STR      r0,[sp,#0x18]         ;821
0001d6  9806              LDR      r0,[sp,#0x18]         ;822
0001d8  f5b03f80          CMP      r0,#0x10000           ;822
0001dc  d002              BEQ      |L5.484|
0001de  f1b90f00          CMP      r9,#0                 ;822
0001e2  d1f1              BNE      |L5.456|
                  |L5.484|
0001e4  f1b90f00          CMP      r9,#0                 ;824
0001e8  d001              BEQ      |L5.494|
0001ea  2000              MOVS     r0,#0                 ;826
0001ec  9005              STR      r0,[sp,#0x14]         ;826
                  |L5.494|
0001ee  9825              LDR      r0,[sp,#0x94]         ;831
0001f0  2800              CMP      r0,#0                 ;831
0001f2  d05a              BEQ      |L5.682|
0001f4  f44f3000          MOV      r0,#0x20000           ;834
0001f8  f7fffffe          BL       CRYP_PhaseConfig
0001fc  2001              MOVS     r0,#1                 ;837
0001fe  f7fffffe          BL       CRYP_Cmd
000202  f7fffffe          BL       CRYP_GetCmdStatus
000206  b910              CBNZ     r0,|L5.526|
000208  2000              MOVS     r0,#0                 ;843
00020a  e7b9              B        |L5.384|
                  |L5.524|
00020c  e089              B        |L5.802|
                  |L5.526|
00020e  f04f0a00          MOV      r10,#0                ;846
000212  e044              B        |L5.670|
                  |L5.532|
000214  bf00              NOP                            ;849
                  |L5.534|
000216  2001              MOVS     r0,#1                 ;849
000218  f7fffffe          BL       CRYP_GetFlagStatus
00021c  2800              CMP      r0,#0                 ;849
00021e  d0fa              BEQ      |L5.534|
000220  6828              LDR      r0,[r5,#0]            ;853
000222  f7fffffe          BL       CRYP_DataIn
000226  1d2d              ADDS     r5,r5,#4              ;854
000228  6828              LDR      r0,[r5,#0]            ;855
00022a  f7fffffe          BL       CRYP_DataIn
00022e  1d2d              ADDS     r5,r5,#4              ;856
000230  6828              LDR      r0,[r5,#0]            ;857
000232  f7fffffe          BL       CRYP_DataIn
000236  1d2d              ADDS     r5,r5,#4              ;858
000238  6828              LDR      r0,[r5,#0]            ;859
00023a  f7fffffe          BL       CRYP_DataIn
00023e  1d2d              ADDS     r5,r5,#4              ;860
000240  2000              MOVS     r0,#0                 ;863
000242  9006              STR      r0,[sp,#0x18]         ;863
000244  bf00              NOP                            ;864
                  |L5.582|
000246  2010              MOVS     r0,#0x10              ;866
000248  f7fffffe          BL       CRYP_GetFlagStatus
00024c  4681              MOV      r9,r0                 ;866
00024e  9806              LDR      r0,[sp,#0x18]         ;867
000250  1c40              ADDS     r0,r0,#1              ;867
000252  9006              STR      r0,[sp,#0x18]         ;867
000254  9806              LDR      r0,[sp,#0x18]         ;868
000256  f5b03f80          CMP      r0,#0x10000           ;868
00025a  d002              BEQ      |L5.610|
00025c  f1b90f00          CMP      r9,#0                 ;868
000260  d1f1              BNE      |L5.582|
                  |L5.610|
000262  f1b90f00          CMP      r9,#0                 ;870
000266  d002              BEQ      |L5.622|
000268  2000              MOVS     r0,#0                 ;872
00026a  9005              STR      r0,[sp,#0x14]         ;872
00026c  e015              B        |L5.666|
                  |L5.622|
00026e  bf00              NOP                            ;877
                  |L5.624|
000270  2004              MOVS     r0,#4                 ;877
000272  f7fffffe          BL       CRYP_GetFlagStatus
000276  2800              CMP      r0,#0                 ;877
000278  d0fa              BEQ      |L5.624|
00027a  f7fffffe          BL       CRYP_DataOut
00027e  6030              STR      r0,[r6,#0]            ;882
000280  1d36              ADDS     r6,r6,#4              ;883
000282  f7fffffe          BL       CRYP_DataOut
000286  6030              STR      r0,[r6,#0]            ;884
000288  1d36              ADDS     r6,r6,#4              ;885
00028a  f7fffffe          BL       CRYP_DataOut
00028e  6030              STR      r0,[r6,#0]            ;886
000290  1d36              ADDS     r6,r6,#4              ;887
000292  f7fffffe          BL       CRYP_DataOut
000296  6030              STR      r0,[r6,#0]            ;888
000298  1d36              ADDS     r6,r6,#4              ;889
                  |L5.666|
00029a  f10a0a10          ADD      r10,r10,#0x10         ;846
                  |L5.670|
00029e  9825              LDR      r0,[sp,#0x94]         ;846
0002a0  4582              CMP      r10,r0                ;846
0002a2  d202              BCS      |L5.682|
0002a4  9805              LDR      r0,[sp,#0x14]         ;846
0002a6  2800              CMP      r0,#0                 ;846
0002a8  d1b4              BNE      |L5.532|
                  |L5.682|
0002aa  f44f3040          MOV      r0,#0x30000           ;896
0002ae  f7fffffe          BL       CRYP_PhaseConfig
0002b2  2001              MOVS     r0,#1                 ;899
0002b4  f7fffffe          BL       CRYP_Cmd
0002b8  f7fffffe          BL       CRYP_GetCmdStatus
0002bc  b908              CBNZ     r0,|L5.706|
0002be  2000              MOVS     r0,#0                 ;905
0002c0  e75e              B        |L5.384|
                  |L5.706|
0002c2  9903              LDR      r1,[sp,#0xc]          ;909
0002c4  ba08              REV      r0,r1                 ;909
0002c6  f7fffffe          BL       CRYP_DataIn
0002ca  9802              LDR      r0,[sp,#8]            ;910
0002cc  ba00              REV      r0,r0                 ;910
0002ce  f7fffffe          BL       CRYP_DataIn
0002d2  9901              LDR      r1,[sp,#4]            ;911
0002d4  ba08              REV      r0,r1                 ;911
0002d6  f7fffffe          BL       CRYP_DataIn
0002da  9800              LDR      r0,[sp,#0]            ;912
0002dc  ba00              REV      r0,r0                 ;912
0002de  f7fffffe          BL       CRYP_DataIn
0002e2  bf00              NOP                            ;914
                  |L5.740|
0002e4  2004              MOVS     r0,#4                 ;914
0002e6  f7fffffe          BL       CRYP_GetFlagStatus
0002ea  2800              CMP      r0,#0                 ;914
0002ec  d0fa              BEQ      |L5.740|
0002ee  46d8              MOV      r8,r11                ;918
0002f0  f7fffffe          BL       CRYP_DataOut
0002f4  f8c80000          STR      r0,[r8,#0]            ;920
0002f8  f1080804          ADD      r8,r8,#4              ;921
0002fc  f7fffffe          BL       CRYP_DataOut
000300  f8c80000          STR      r0,[r8,#0]            ;922
000304  f1080804          ADD      r8,r8,#4              ;923
000308  f7fffffe          BL       CRYP_DataOut
00030c  f8c80000          STR      r0,[r8,#0]            ;924
000310  f1080804          ADD      r8,r8,#4              ;925
000314  f7fffffe          BL       CRYP_DataOut
000318  f8c80000          STR      r0,[r8,#0]            ;926
00031c  f1080804          ADD      r8,r8,#4              ;927
000320  e0f7              B        |L5.1298|
                  |L5.802|
000322  f7fffffe          BL       CRYP_FIFOFlush
000326  a80b              ADD      r0,sp,#0x2c           ;936
000328  f7fffffe          BL       CRYP_KeyInit
00032c  a807              ADD      r0,sp,#0x1c           ;939
00032e  f7fffffe          BL       CRYP_IVInit
000332  2004              MOVS     r0,#4                 ;942
000334  9013              STR      r0,[sp,#0x4c]         ;942
000336  0440              LSLS     r0,r0,#17             ;943
000338  9014              STR      r0,[sp,#0x50]         ;943
00033a  2080              MOVS     r0,#0x80              ;944
00033c  9015              STR      r0,[sp,#0x54]         ;944
00033e  a813              ADD      r0,sp,#0x4c           ;945
000340  f7fffffe          BL       CRYP_Init
000344  2000              MOVS     r0,#0                 ;949
000346  f7fffffe          BL       CRYP_PhaseConfig
00034a  2001              MOVS     r0,#1                 ;952
00034c  f7fffffe          BL       CRYP_Cmd
000350  bf00              NOP                            ;955
                  |L5.850|
000352  f7fffffe          BL       CRYP_GetCmdStatus
000356  2801              CMP      r0,#1                 ;955
000358  d0fb              BEQ      |L5.850|
00035a  9827              LDR      r0,[sp,#0x9c]         ;960
00035c  b3f0              CBZ      r0,|L5.988|
00035e  f44f3080          MOV      r0,#0x10000           ;963
000362  f7fffffe          BL       CRYP_PhaseConfig
000366  2001              MOVS     r0,#1                 ;966
000368  f7fffffe          BL       CRYP_Cmd
00036c  f7fffffe          BL       CRYP_GetCmdStatus
000370  b908              CBNZ     r0,|L5.886|
000372  2000              MOVS     r0,#0                 ;972
000374  e704              B        |L5.384|
                  |L5.886|
000376  f04f0a00          MOV      r10,#0                ;975
00037a  e017              B        |L5.940|
                  |L5.892|
00037c  bf00              NOP                            ;978
                  |L5.894|
00037e  2001              MOVS     r0,#1                 ;978
000380  f7fffffe          BL       CRYP_GetFlagStatus
000384  2800              CMP      r0,#0                 ;978
000386  d0fa              BEQ      |L5.894|
000388  6838              LDR      r0,[r7,#0]            ;983
00038a  f7fffffe          BL       CRYP_DataIn
00038e  1d3f              ADDS     r7,r7,#4              ;984
000390  6838              LDR      r0,[r7,#0]            ;985
000392  f7fffffe          BL       CRYP_DataIn
000396  1d3f              ADDS     r7,r7,#4              ;986
000398  6838              LDR      r0,[r7,#0]            ;987
00039a  f7fffffe          BL       CRYP_DataIn
00039e  1d3f              ADDS     r7,r7,#4              ;988
0003a0  6838              LDR      r0,[r7,#0]            ;989
0003a2  f7fffffe          BL       CRYP_DataIn
0003a6  1d3f              ADDS     r7,r7,#4              ;990
0003a8  f10a0a10          ADD      r10,r10,#0x10         ;975
                  |L5.940|
0003ac  9827              LDR      r0,[sp,#0x9c]         ;975
0003ae  4582              CMP      r10,r0                ;975
0003b0  d3e4              BCC      |L5.892|
0003b2  2000              MOVS     r0,#0                 ;994
0003b4  9006              STR      r0,[sp,#0x18]         ;994
0003b6  bf00              NOP                            ;995
                  |L5.952|
0003b8  2010              MOVS     r0,#0x10              ;997
0003ba  f7fffffe          BL       CRYP_GetFlagStatus
0003be  4681              MOV      r9,r0                 ;997
0003c0  9806              LDR      r0,[sp,#0x18]         ;998
0003c2  1c40              ADDS     r0,r0,#1              ;998
0003c4  9006              STR      r0,[sp,#0x18]         ;998
0003c6  9806              LDR      r0,[sp,#0x18]         ;999
0003c8  f5b03f80          CMP      r0,#0x10000           ;999
0003cc  d002              BEQ      |L5.980|
0003ce  f1b90f00          CMP      r9,#0                 ;999
0003d2  d1f1              BNE      |L5.952|
                  |L5.980|
0003d4  f1b90f00          CMP      r9,#0                 ;1001
0003d8  d003              BEQ      |L5.994|
0003da  e000              B        |L5.990|
                  |L5.988|
0003dc  e001              B        |L5.994|
                  |L5.990|
0003de  2000              MOVS     r0,#0                 ;1003
0003e0  9005              STR      r0,[sp,#0x14]         ;1003
                  |L5.994|
0003e2  9825              LDR      r0,[sp,#0x94]         ;1008
0003e4  2800              CMP      r0,#0                 ;1008
0003e6  d059              BEQ      |L5.1180|
0003e8  f44f3000          MOV      r0,#0x20000           ;1011
0003ec  f7fffffe          BL       CRYP_PhaseConfig
0003f0  2001              MOVS     r0,#1                 ;1014
0003f2  f7fffffe          BL       CRYP_Cmd
0003f6  f7fffffe          BL       CRYP_GetCmdStatus
0003fa  b908              CBNZ     r0,|L5.1024|
0003fc  2000              MOVS     r0,#0                 ;1020
0003fe  e6bf              B        |L5.384|
                  |L5.1024|
000400  f04f0a00          MOV      r10,#0                ;1023
000404  e044              B        |L5.1168|
                  |L5.1030|
000406  bf00              NOP                            ;1026
                  |L5.1032|
000408  2001              MOVS     r0,#1                 ;1026
00040a  f7fffffe          BL       CRYP_GetFlagStatus
00040e  2800              CMP      r0,#0                 ;1026
000410  d0fa              BEQ      |L5.1032|
000412  6828              LDR      r0,[r5,#0]            ;1030
000414  f7fffffe          BL       CRYP_DataIn
000418  1d2d              ADDS     r5,r5,#4              ;1031
00041a  6828              LDR      r0,[r5,#0]            ;1032
00041c  f7fffffe          BL       CRYP_DataIn
000420  1d2d              ADDS     r5,r5,#4              ;1033
000422  6828              LDR      r0,[r5,#0]            ;1034
000424  f7fffffe          BL       CRYP_DataIn
000428  1d2d              ADDS     r5,r5,#4              ;1035
00042a  6828              LDR      r0,[r5,#0]            ;1036
00042c  f7fffffe          BL       CRYP_DataIn
000430  1d2d              ADDS     r5,r5,#4              ;1037
000432  2000              MOVS     r0,#0                 ;1040
000434  9006              STR      r0,[sp,#0x18]         ;1040
000436  bf00              NOP                            ;1041
                  |L5.1080|
000438  2010              MOVS     r0,#0x10              ;1043
00043a  f7fffffe          BL       CRYP_GetFlagStatus
00043e  4681              MOV      r9,r0                 ;1043
000440  9806              LDR      r0,[sp,#0x18]         ;1044
000442  1c40              ADDS     r0,r0,#1              ;1044
000444  9006              STR      r0,[sp,#0x18]         ;1044
000446  9806              LDR      r0,[sp,#0x18]         ;1045
000448  f5b03f80          CMP      r0,#0x10000           ;1045
00044c  d002              BEQ      |L5.1108|
00044e  f1b90f00          CMP      r9,#0                 ;1045
000452  d1f1              BNE      |L5.1080|
                  |L5.1108|
000454  f1b90f00          CMP      r9,#0                 ;1047
000458  d002              BEQ      |L5.1120|
00045a  2000              MOVS     r0,#0                 ;1049
00045c  9005              STR      r0,[sp,#0x14]         ;1049
00045e  e015              B        |L5.1164|
                  |L5.1120|
000460  bf00              NOP                            ;1054
                  |L5.1122|
000462  2004              MOVS     r0,#4                 ;1054
000464  f7fffffe          BL       CRYP_GetFlagStatus
000468  2800              CMP      r0,#0                 ;1054
00046a  d0fa              BEQ      |L5.1122|
00046c  f7fffffe          BL       CRYP_DataOut
000470  6030              STR      r0,[r6,#0]            ;1059
000472  1d36              ADDS     r6,r6,#4              ;1060
000474  f7fffffe          BL       CRYP_DataOut
000478  6030              STR      r0,[r6,#0]            ;1061
00047a  1d36              ADDS     r6,r6,#4              ;1062
00047c  f7fffffe          BL       CRYP_DataOut
000480  6030              STR      r0,[r6,#0]            ;1063
000482  1d36              ADDS     r6,r6,#4              ;1064
000484  f7fffffe          BL       CRYP_DataOut
000488  6030              STR      r0,[r6,#0]            ;1065
00048a  1d36              ADDS     r6,r6,#4              ;1066
                  |L5.1164|
00048c  f10a0a10          ADD      r10,r10,#0x10         ;1023
                  |L5.1168|
000490  9825              LDR      r0,[sp,#0x94]         ;1023
000492  4582              CMP      r10,r0                ;1023
000494  d202              BCS      |L5.1180|
000496  9805              LDR      r0,[sp,#0x14]         ;1023
000498  2800              CMP      r0,#0                 ;1023
00049a  d1b4              BNE      |L5.1030|
                  |L5.1180|
00049c  f44f3040          MOV      r0,#0x30000           ;1073
0004a0  f7fffffe          BL       CRYP_PhaseConfig
0004a4  2001              MOVS     r0,#1                 ;1076
0004a6  f7fffffe          BL       CRYP_Cmd
0004aa  f7fffffe          BL       CRYP_GetCmdStatus
0004ae  b908              CBNZ     r0,|L5.1204|
0004b0  2000              MOVS     r0,#0                 ;1082
0004b2  e665              B        |L5.384|
                  |L5.1204|
0004b4  9903              LDR      r1,[sp,#0xc]          ;1086
0004b6  ba08              REV      r0,r1                 ;1086
0004b8  f7fffffe          BL       CRYP_DataIn
0004bc  9802              LDR      r0,[sp,#8]            ;1087
0004be  ba00              REV      r0,r0                 ;1087
0004c0  f7fffffe          BL       CRYP_DataIn
0004c4  9901              LDR      r1,[sp,#4]            ;1088
0004c6  ba08              REV      r0,r1                 ;1088
0004c8  f7fffffe          BL       CRYP_DataIn
0004cc  9800              LDR      r0,[sp,#0]            ;1089
0004ce  ba00              REV      r0,r0                 ;1089
0004d0  f7fffffe          BL       CRYP_DataIn
0004d4  bf00              NOP                            ;1091
                  |L5.1238|
0004d6  2004              MOVS     r0,#4                 ;1091
0004d8  f7fffffe          BL       CRYP_GetFlagStatus
0004dc  2800              CMP      r0,#0                 ;1091
0004de  d0fa              BEQ      |L5.1238|
0004e0  46d8              MOV      r8,r11                ;1095
0004e2  f7fffffe          BL       CRYP_DataOut
0004e6  f8c80000          STR      r0,[r8,#0]            ;1097
0004ea  f1080804          ADD      r8,r8,#4              ;1098
0004ee  f7fffffe          BL       CRYP_DataOut
0004f2  f8c80000          STR      r0,[r8,#0]            ;1099
0004f6  f1080804          ADD      r8,r8,#4              ;1100
0004fa  f7fffffe          BL       CRYP_DataOut
0004fe  f8c80000          STR      r0,[r8,#0]            ;1101
000502  f1080804          ADD      r8,r8,#4              ;1102
000506  f7fffffe          BL       CRYP_DataOut
00050a  f8c80000          STR      r0,[r8,#0]            ;1103
00050e  f1080804          ADD      r8,r8,#4              ;1104
                  |L5.1298|
000512  2000              MOVS     r0,#0                 ;1107
000514  f7fffffe          BL       CRYP_Cmd
000518  9805              LDR      r0,[sp,#0x14]         ;1109
00051a  e631              B        |L5.384|
;;;1111   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_cryp_aes.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REVSH|
#line 153
|__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____RRX|
#line 328
|__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
