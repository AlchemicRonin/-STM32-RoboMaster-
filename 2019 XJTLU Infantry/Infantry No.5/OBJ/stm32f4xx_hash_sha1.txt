; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_hash_sha1.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_hash_sha1.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_hash_sha1.crf ..\FWLIB\src\stm32f4xx_hash_sha1.c]
                          THUMB

                          AREA ||i.HASH_SHA1||, CODE, READONLY, ALIGN=1

                  HASH_SHA1 PROC
;;;92       */
;;;93     ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;94     {
000004  b08f              SUB      sp,sp,#0x3c
000006  4606              MOV      r6,r0
000008  460d              MOV      r5,r1
00000a  4617              MOV      r7,r2
;;;95       HASH_InitTypeDef SHA1_HASH_InitStructure;
;;;96       HASH_MsgDigest SHA1_MessageDigest;
;;;97       __IO uint16_t nbvalidbitsdata = 0;
00000c  2000              MOVS     r0,#0
00000e  9002              STR      r0,[sp,#8]
;;;98       uint32_t i = 0;
000010  4680              MOV      r8,r0
;;;99       __IO uint32_t counter = 0;
000012  9001              STR      r0,[sp,#4]
;;;100      uint32_t busystatus = 0;
000014  4681              MOV      r9,r0
;;;101      ErrorStatus status = SUCCESS;
000016  f04f0b01          MOV      r11,#1
;;;102      uint32_t inputaddr  = (uint32_t)Input;
00001a  46b2              MOV      r10,r6
;;;103      uint32_t outputaddr = (uint32_t)Output;
00001c  463c              MOV      r4,r7
;;;104    
;;;105      /* Number of valid bits in last word of the Input data */
;;;106      nbvalidbitsdata = 8 * (Ilen % 4);
00001e  07a8              LSLS     r0,r5,#30
000020  0ec0              LSRS     r0,r0,#27
000022  9002              STR      r0,[sp,#8]
;;;107    
;;;108      /* HASH peripheral initialization */
;;;109      HASH_DeInit();
000024  f7fffffe          BL       HASH_DeInit
;;;110    
;;;111      /* HASH Configuration */
;;;112      SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
000028  2000              MOVS     r0,#0
00002a  900b              STR      r0,[sp,#0x2c]
;;;113      SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
00002c  900c              STR      r0,[sp,#0x30]
;;;114      SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
00002e  2020              MOVS     r0,#0x20
000030  900d              STR      r0,[sp,#0x34]
;;;115      HASH_Init(&SHA1_HASH_InitStructure);
000032  a80b              ADD      r0,sp,#0x2c
000034  f7fffffe          BL       HASH_Init
;;;116    
;;;117      /* Configure the number of valid bits in last word of the data */
;;;118      HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
000038  f8bd0008          LDRH     r0,[sp,#8]
00003c  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;119    
;;;120      /* Write the Input block in the IN FIFO */
;;;121      for(i=0; i<Ilen; i+=4)
000040  bf00              NOP      
000042  e007              B        |L1.84|
                  |L1.68|
;;;122      {
;;;123        HASH_DataIn(*(uint32_t*)inputaddr);
000044  f8da0000          LDR      r0,[r10,#0]
000048  f7fffffe          BL       HASH_DataIn
;;;124        inputaddr+=4;
00004c  f10a0a04          ADD      r10,r10,#4
000050  f1080804          ADD      r8,r8,#4              ;121
                  |L1.84|
000054  45a8              CMP      r8,r5                 ;121
000056  d3f5              BCC      |L1.68|
;;;125      }
;;;126    
;;;127      /* Start the HASH processor */
;;;128      HASH_StartDigest();
000058  f7fffffe          BL       HASH_StartDigest
;;;129    
;;;130      /* wait until the Busy flag is RESET */
;;;131      do
00005c  bf00              NOP      
                  |L1.94|
;;;132      {
;;;133        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
00005e  2008              MOVS     r0,#8
000060  f7fffffe          BL       HASH_GetFlagStatus
000064  4681              MOV      r9,r0
;;;134        counter++;
000066  9801              LDR      r0,[sp,#4]
000068  1c40              ADDS     r0,r0,#1
00006a  9001              STR      r0,[sp,#4]
;;;135      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
00006c  9801              LDR      r0,[sp,#4]
00006e  f5b03f80          CMP      r0,#0x10000
000072  d002              BEQ      |L1.122|
000074  f1b90f00          CMP      r9,#0
000078  d1f1              BNE      |L1.94|
                  |L1.122|
;;;136    
;;;137      if (busystatus != RESET)
00007a  f1b90f00          CMP      r9,#0
00007e  d002              BEQ      |L1.134|
;;;138      {
;;;139         status = ERROR;
000080  f04f0b00          MOV      r11,#0
000084  e015              B        |L1.178|
                  |L1.134|
;;;140      }
;;;141      else
;;;142      {
;;;143        /* Read the message digest */
;;;144        HASH_GetDigest(&SHA1_MessageDigest);
000086  a803              ADD      r0,sp,#0xc
000088  f7fffffe          BL       HASH_GetDigest
;;;145        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
00008c  9803              LDR      r0,[sp,#0xc]
00008e  ba00              REV      r0,r0
000090  6020              STR      r0,[r4,#0]
;;;146        outputaddr+=4;
000092  1d24              ADDS     r4,r4,#4
;;;147        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
000094  9804              LDR      r0,[sp,#0x10]
000096  ba00              REV      r0,r0
000098  6020              STR      r0,[r4,#0]
;;;148        outputaddr+=4;
00009a  1d24              ADDS     r4,r4,#4
;;;149        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
00009c  9805              LDR      r0,[sp,#0x14]
00009e  ba00              REV      r0,r0
0000a0  6020              STR      r0,[r4,#0]
;;;150        outputaddr+=4;
0000a2  1d24              ADDS     r4,r4,#4
;;;151        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
0000a4  9806              LDR      r0,[sp,#0x18]
0000a6  ba00              REV      r0,r0
0000a8  6020              STR      r0,[r4,#0]
;;;152        outputaddr+=4;
0000aa  1d24              ADDS     r4,r4,#4
;;;153        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
0000ac  9807              LDR      r0,[sp,#0x1c]
0000ae  ba00              REV      r0,r0
0000b0  6020              STR      r0,[r4,#0]
                  |L1.178|
;;;154      }
;;;155      return status;
0000b2  4658              MOV      r0,r11
;;;156    }
0000b4  b00f              ADD      sp,sp,#0x3c
0000b6  e8bd8ff0          POP      {r4-r11,pc}
;;;157    
                          ENDP


                          AREA ||i.HMAC_SHA1||, CODE, READONLY, ALIGN=1

                  HMAC_SHA1 PROC
;;;168      */
;;;169    ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;170                          uint32_t Ilen, uint8_t Output[20])
;;;171    {
000004  b091              SUB      sp,sp,#0x44
000006  4681              MOV      r9,r0
000008  460f              MOV      r7,r1
00000a  4693              MOV      r11,r2
00000c  469a              MOV      r10,r3
;;;172      HASH_InitTypeDef SHA1_HASH_InitStructure;
;;;173      HASH_MsgDigest SHA1_MessageDigest;
;;;174      __IO uint16_t nbvalidbitsdata = 0;
00000e  2000              MOVS     r0,#0
000010  9004              STR      r0,[sp,#0x10]
;;;175      __IO uint16_t nbvalidbitskey = 0;
000012  9003              STR      r0,[sp,#0xc]
;;;176      uint32_t i = 0;
000014  2500              MOVS     r5,#0
;;;177      __IO uint32_t counter = 0;
000016  9002              STR      r0,[sp,#8]
;;;178      uint32_t busystatus = 0;
000018  2600              MOVS     r6,#0
;;;179      ErrorStatus status = SUCCESS;
00001a  2001              MOVS     r0,#1
00001c  9001              STR      r0,[sp,#4]
;;;180      uint32_t keyaddr    = (uint32_t)Key;
00001e  46c8              MOV      r8,r9
;;;181      uint32_t inputaddr  = (uint32_t)Input;
000020  f8cdb000          STR      r11,[sp,#0]
;;;182      uint32_t outputaddr = (uint32_t)Output;
000024  9c1a              LDR      r4,[sp,#0x68]
;;;183    
;;;184      /* Number of valid bits in last word of the Input data */
;;;185      nbvalidbitsdata = 8 * (Ilen % 4);
000026  ea4f708a          LSL      r0,r10,#30
00002a  0ec0              LSRS     r0,r0,#27
00002c  9004              STR      r0,[sp,#0x10]
;;;186    
;;;187      /* Number of valid bits in last word of the Key */
;;;188      nbvalidbitskey = 8 * (Keylen % 4);
00002e  07b8              LSLS     r0,r7,#30
000030  0ec0              LSRS     r0,r0,#27
000032  9003              STR      r0,[sp,#0xc]
;;;189    
;;;190      /* HASH peripheral initialization */
;;;191      HASH_DeInit();
000034  f7fffffe          BL       HASH_DeInit
;;;192    
;;;193      /* HASH Configuration */
;;;194      SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
000038  2000              MOVS     r0,#0
00003a  900d              STR      r0,[sp,#0x34]
;;;195      SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
00003c  2040              MOVS     r0,#0x40
00003e  900e              STR      r0,[sp,#0x38]
;;;196      SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
000040  2020              MOVS     r0,#0x20
000042  900f              STR      r0,[sp,#0x3c]
;;;197      if(Keylen > 64)
000044  2f40              CMP      r7,#0x40
000046  d902              BLS      |L2.78|
;;;198      {
;;;199        /* HMAC long Key */
;;;200        SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
000048  02c0              LSLS     r0,r0,#11
00004a  9010              STR      r0,[sp,#0x40]
00004c  e001              B        |L2.82|
                  |L2.78|
;;;201      }
;;;202      else
;;;203      {
;;;204        /* HMAC short Key */
;;;205        SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
00004e  2000              MOVS     r0,#0
000050  9010              STR      r0,[sp,#0x40]
                  |L2.82|
;;;206      }
;;;207      HASH_Init(&SHA1_HASH_InitStructure);
000052  a80d              ADD      r0,sp,#0x34
000054  f7fffffe          BL       HASH_Init
;;;208    
;;;209      /* Configure the number of valid bits in last word of the Key */
;;;210      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
000058  f8bd000c          LDRH     r0,[sp,#0xc]
00005c  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;211    
;;;212      /* Write the Key */
;;;213      for(i=0; i<Keylen; i+=4)
000060  2500              MOVS     r5,#0
000062  e006              B        |L2.114|
                  |L2.100|
;;;214      {
;;;215        HASH_DataIn(*(uint32_t*)keyaddr);
000064  f8d80000          LDR      r0,[r8,#0]
000068  f7fffffe          BL       HASH_DataIn
;;;216        keyaddr+=4;
00006c  f1080804          ADD      r8,r8,#4
000070  1d2d              ADDS     r5,r5,#4              ;213
                  |L2.114|
000072  42bd              CMP      r5,r7                 ;213
000074  d3f6              BCC      |L2.100|
;;;217      }
;;;218    
;;;219      /* Start the HASH processor */
;;;220      HASH_StartDigest();
000076  f7fffffe          BL       HASH_StartDigest
;;;221    
;;;222      /* wait until the Busy flag is RESET */
;;;223      do
00007a  bf00              NOP      
                  |L2.124|
;;;224      {
;;;225        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
00007c  2008              MOVS     r0,#8
00007e  f7fffffe          BL       HASH_GetFlagStatus
000082  4606              MOV      r6,r0
;;;226        counter++;
000084  9802              LDR      r0,[sp,#8]
000086  1c40              ADDS     r0,r0,#1
000088  9002              STR      r0,[sp,#8]
;;;227      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
00008a  9802              LDR      r0,[sp,#8]
00008c  f5b03f80          CMP      r0,#0x10000
000090  d001              BEQ      |L2.150|
000092  2e00              CMP      r6,#0
000094  d1f2              BNE      |L2.124|
                  |L2.150|
;;;228    
;;;229      if (busystatus != RESET)
000096  b116              CBZ      r6,|L2.158|
;;;230      {
;;;231         status = ERROR;
000098  2000              MOVS     r0,#0
00009a  9001              STR      r0,[sp,#4]
00009c  e061              B        |L2.354|
                  |L2.158|
;;;232      }
;;;233      else
;;;234      {
;;;235        /* Configure the number of valid bits in last word of the Input data */
;;;236        HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
00009e  f8bd0010          LDRH     r0,[sp,#0x10]
0000a2  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;237    
;;;238        /* Write the Input block in the IN FIFO */
;;;239        for(i=0; i<Ilen; i+=4)
0000a6  2500              MOVS     r5,#0
0000a8  e007              B        |L2.186|
                  |L2.170|
;;;240        {
;;;241          HASH_DataIn(*(uint32_t*)inputaddr);
0000aa  9900              LDR      r1,[sp,#0]
0000ac  6808              LDR      r0,[r1,#0]
0000ae  f7fffffe          BL       HASH_DataIn
;;;242          inputaddr+=4;
0000b2  9800              LDR      r0,[sp,#0]
0000b4  1d00              ADDS     r0,r0,#4
0000b6  9000              STR      r0,[sp,#0]
0000b8  1d2d              ADDS     r5,r5,#4              ;239
                  |L2.186|
0000ba  4555              CMP      r5,r10                ;239
0000bc  d3f5              BCC      |L2.170|
;;;243        }
;;;244    
;;;245        /* Start the HASH processor */
;;;246        HASH_StartDigest();
0000be  f7fffffe          BL       HASH_StartDigest
;;;247    
;;;248    
;;;249        /* wait until the Busy flag is RESET */
;;;250        counter =0;
0000c2  2000              MOVS     r0,#0
0000c4  9002              STR      r0,[sp,#8]
;;;251        do
0000c6  bf00              NOP      
                  |L2.200|
;;;252        {
;;;253          busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0000c8  2008              MOVS     r0,#8
0000ca  f7fffffe          BL       HASH_GetFlagStatus
0000ce  4606              MOV      r6,r0
;;;254          counter++;
0000d0  9802              LDR      r0,[sp,#8]
0000d2  1c40              ADDS     r0,r0,#1
0000d4  9002              STR      r0,[sp,#8]
;;;255        }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
0000d6  9802              LDR      r0,[sp,#8]
0000d8  f5b03f80          CMP      r0,#0x10000
0000dc  d001              BEQ      |L2.226|
0000de  2e00              CMP      r6,#0
0000e0  d1f2              BNE      |L2.200|
                  |L2.226|
;;;256    
;;;257        if (busystatus != RESET)
0000e2  b116              CBZ      r6,|L2.234|
;;;258        {
;;;259          status = ERROR;
0000e4  2000              MOVS     r0,#0
0000e6  9001              STR      r0,[sp,#4]
0000e8  e03b              B        |L2.354|
                  |L2.234|
;;;260        }
;;;261        else
;;;262        {  
;;;263          /* Configure the number of valid bits in last word of the Key */
;;;264          HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
0000ea  f8bd000c          LDRH     r0,[sp,#0xc]
0000ee  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;265    
;;;266          /* Write the Key */
;;;267          keyaddr = (uint32_t)Key;
0000f2  46c8              MOV      r8,r9
;;;268          for(i=0; i<Keylen; i+=4)
0000f4  2500              MOVS     r5,#0
0000f6  e006              B        |L2.262|
                  |L2.248|
;;;269          {
;;;270            HASH_DataIn(*(uint32_t*)keyaddr);
0000f8  f8d80000          LDR      r0,[r8,#0]
0000fc  f7fffffe          BL       HASH_DataIn
;;;271            keyaddr+=4;
000100  f1080804          ADD      r8,r8,#4
000104  1d2d              ADDS     r5,r5,#4              ;268
                  |L2.262|
000106  42bd              CMP      r5,r7                 ;268
000108  d3f6              BCC      |L2.248|
;;;272          }
;;;273    
;;;274          /* Start the HASH processor */
;;;275          HASH_StartDigest();
00010a  f7fffffe          BL       HASH_StartDigest
;;;276    
;;;277          /* wait until the Busy flag is RESET */
;;;278          counter =0;
00010e  2000              MOVS     r0,#0
000110  9002              STR      r0,[sp,#8]
;;;279          do
000112  bf00              NOP      
                  |L2.276|
;;;280          {
;;;281            busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
000114  2008              MOVS     r0,#8
000116  f7fffffe          BL       HASH_GetFlagStatus
00011a  4606              MOV      r6,r0
;;;282            counter++;
00011c  9802              LDR      r0,[sp,#8]
00011e  1c40              ADDS     r0,r0,#1
000120  9002              STR      r0,[sp,#8]
;;;283          }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
000122  9802              LDR      r0,[sp,#8]
000124  f5b03f80          CMP      r0,#0x10000
000128  d001              BEQ      |L2.302|
00012a  2e00              CMP      r6,#0
00012c  d1f2              BNE      |L2.276|
                  |L2.302|
;;;284    
;;;285          if (busystatus != RESET)
00012e  b116              CBZ      r6,|L2.310|
;;;286          {
;;;287            status = ERROR;
000130  2000              MOVS     r0,#0
000132  9001              STR      r0,[sp,#4]
000134  e015              B        |L2.354|
                  |L2.310|
;;;288          }
;;;289          else
;;;290          {
;;;291            /* Read the message digest */
;;;292            HASH_GetDigest(&SHA1_MessageDigest);
000136  a805              ADD      r0,sp,#0x14
000138  f7fffffe          BL       HASH_GetDigest
;;;293            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
00013c  9805              LDR      r0,[sp,#0x14]
00013e  ba00              REV      r0,r0
000140  6020              STR      r0,[r4,#0]
;;;294            outputaddr+=4;
000142  1d24              ADDS     r4,r4,#4
;;;295            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
000144  9806              LDR      r0,[sp,#0x18]
000146  ba00              REV      r0,r0
000148  6020              STR      r0,[r4,#0]
;;;296            outputaddr+=4;
00014a  1d24              ADDS     r4,r4,#4
;;;297            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
00014c  9807              LDR      r0,[sp,#0x1c]
00014e  ba00              REV      r0,r0
000150  6020              STR      r0,[r4,#0]
;;;298            outputaddr+=4;
000152  1d24              ADDS     r4,r4,#4
;;;299            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
000154  9808              LDR      r0,[sp,#0x20]
000156  ba00              REV      r0,r0
000158  6020              STR      r0,[r4,#0]
;;;300            outputaddr+=4;
00015a  1d24              ADDS     r4,r4,#4
;;;301            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
00015c  9809              LDR      r0,[sp,#0x24]
00015e  ba00              REV      r0,r0
000160  6020              STR      r0,[r4,#0]
                  |L2.354|
;;;302          }
;;;303        }  
;;;304      }
;;;305      return status;  
000162  9801              LDR      r0,[sp,#4]
;;;306    }
000164  b011              ADD      sp,sp,#0x44
000166  e8bd8ff0          POP      {r4-r11,pc}
;;;307    /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_hash_sha1.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REVSH|
#line 153
|__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hash_sha1_c_328c56b9____RRX|
#line 328
|__asm___21_stm32f4xx_hash_sha1_c_328c56b9____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
