; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_tim.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_tim.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_tim.crf ..\FWLIB\src\stm32f4xx_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;3203     */
;;;3204   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3205                          uint16_t TIM_ICFilter)
;;;3206   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3207     uint16_t tmpccmr1 = 0, tmpccer = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
;;;3208   
;;;3209     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3210     TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
00000a  8c06              LDRH     r6,[r0,#0x20]
00000c  f64f77fe          MOV      r7,#0xfffe
000010  403e              ANDS     r6,r6,r7
000012  8406              STRH     r6,[r0,#0x20]
;;;3211     tmpccmr1 = TIMx->CCMR1;
000014  8b01              LDRH     r1,[r0,#0x18]
;;;3212     tmpccer = TIMx->CCER;
000016  8c02              LDRH     r2,[r0,#0x20]
;;;3213   
;;;3214     /* Select the Input and set the filter */
;;;3215     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
000018  f64f760c          MOV      r6,#0xff0c
00001c  4031              ANDS     r1,r1,r6
;;;3216     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00001e  1c7e              ADDS     r6,r7,#1
000020  ea061603          AND      r6,r6,r3,LSL #4
000024  432e              ORRS     r6,r6,r5
000026  4331              ORRS     r1,r1,r6
;;;3217   
;;;3218     /* Select the Polarity and set the CC1E Bit */
;;;3219     tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000028  f64f76f5          MOV      r6,#0xfff5
00002c  4032              ANDS     r2,r2,r6
;;;3220     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
00002e  f0440601          ORR      r6,r4,#1
000032  4332              ORRS     r2,r2,r6
;;;3221   
;;;3222     /* Write to TIMx CCMR1 and CCER registers */
;;;3223     TIMx->CCMR1 = tmpccmr1;
000034  8301              STRH     r1,[r0,#0x18]
;;;3224     TIMx->CCER = tmpccer;
000036  8402              STRH     r2,[r0,#0x20]
;;;3225   }
000038  bdf0              POP      {r4-r7,pc}
;;;3226   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;3244     */
;;;3245   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3246                          uint16_t TIM_ICFilter)
;;;3247   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3248     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3249   
;;;3250     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3251     TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f7cef          MOV      r12,#0xffef
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3252     tmpccmr1 = TIMx->CCMR1;
000018  8b01              LDRH     r1,[r0,#0x18]
;;;3253     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3254     tmp = (uint16_t)(TIM_ICPolarity << 4);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea071604          AND      r6,r7,r4,LSL #4
;;;3255   
;;;3256     /* Select the Input and set the filter */
;;;3257     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;3258     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea073703          AND      r7,r7,r3,LSL #12
000032  4339              ORRS     r1,r1,r7
;;;3259     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea072705          AND      r7,r7,r5,LSL #8
00003c  4339              ORRS     r1,r1,r7
;;;3260   
;;;3261     /* Select the Polarity and set the CC2E Bit */
;;;3262     tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00003e  f64f775f          MOV      r7,#0xff5f
000042  403a              ANDS     r2,r2,r7
;;;3263     tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
000044  f0460710          ORR      r7,r6,#0x10
000048  433a              ORRS     r2,r2,r7
;;;3264   
;;;3265     /* Write to TIMx CCMR1 and CCER registers */
;;;3266     TIMx->CCMR1 = tmpccmr1 ;
00004a  8301              STRH     r1,[r0,#0x18]
;;;3267     TIMx->CCER = tmpccer;
00004c  8402              STRH     r2,[r0,#0x20]
;;;3268   }
00004e  bdf0              POP      {r4-r7,pc}
;;;3269   
                          ENDP


                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=1

                  TI3_Config PROC
;;;3286     */
;;;3287   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3288                          uint16_t TIM_ICFilter)
;;;3289   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3290     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3291   
;;;3292     /* Disable the Channel 3: Reset the CC3E Bit */
;;;3293     TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f6cff          MOV      r12,#0xfeff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3294     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;3295     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3296     tmp = (uint16_t)(TIM_ICPolarity << 8);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea072604          AND      r6,r7,r4,LSL #8
;;;3297   
;;;3298     /* Select the Input and set the filter */
;;;3299     tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
000024  f64f770c          MOV      r7,#0xff0c
000028  4039              ANDS     r1,r1,r7
;;;3300     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea071703          AND      r7,r7,r3,LSL #4
000032  432f              ORRS     r7,r7,r5
000034  4339              ORRS     r1,r1,r7
;;;3301   
;;;3302     /* Select the Polarity and set the CC3E Bit */
;;;3303     tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
000036  f24f57ff          MOV      r7,#0xf5ff
00003a  403a              ANDS     r2,r2,r7
;;;3304     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
00003c  f4467780          ORR      r7,r6,#0x100
000040  433a              ORRS     r2,r2,r7
;;;3305   
;;;3306     /* Write to TIMx CCMR2 and CCER registers */
;;;3307     TIMx->CCMR2 = tmpccmr2;
000042  8381              STRH     r1,[r0,#0x1c]
;;;3308     TIMx->CCER = tmpccer;
000044  8402              STRH     r2,[r0,#0x20]
;;;3309   }
000046  bdf0              POP      {r4-r7,pc}
;;;3310   
                          ENDP


                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=1

                  TI4_Config PROC
;;;3327     */
;;;3328   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3329                          uint16_t TIM_ICFilter)
;;;3330   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3331     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3332   
;;;3333     /* Disable the Channel 4: Reset the CC4E Bit */
;;;3334     TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64e7cff          MOV      r12,#0xefff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3335     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;3336     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3337     tmp = (uint16_t)(TIM_ICPolarity << 12);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea073604          AND      r6,r7,r4,LSL #12
;;;3338   
;;;3339     /* Select the Input and set the filter */
;;;3340     tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;3341     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea072705          AND      r7,r7,r5,LSL #8
000032  4339              ORRS     r1,r1,r7
;;;3342     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea073703          AND      r7,r7,r3,LSL #12
00003c  4339              ORRS     r1,r1,r7
;;;3343   
;;;3344     /* Select the Polarity and set the CC4E Bit */
;;;3345     tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
00003e  f64577ff          MOV      r7,#0x5fff
000042  403a              ANDS     r2,r2,r7
;;;3346     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
000044  f4465780          ORR      r7,r6,#0x1000
000048  433a              ORRS     r2,r2,r7
;;;3347   
;;;3348     /* Write to TIMx CCMR2 and CCER registers */
;;;3349     TIMx->CCMR2 = tmpccmr2;
00004a  8381              STRH     r1,[r0,#0x1c]
;;;3350     TIMx->CCER = tmpccer ;
00004c  8402              STRH     r2,[r0,#0x20]
;;;3351   }
00004e  bdf0              POP      {r4-r7,pc}
;;;3352   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;521      */
;;;522    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;523    {
;;;524      /* Check the parameters */
;;;525      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;526      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;527    
;;;528      if (NewState != DISABLE)
;;;529      {
;;;530        /* Set the ARR Preload Bit */
;;;531        TIMx->CR1 |= TIM_CR1_ARPE;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;532      }
;;;533      else
;;;534      {
;;;535        /* Reset the ARR Preload Bit */
;;;536        TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L5.22|
;;;537      }
;;;538    }
000016  4770              BX       lr
;;;539    
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;2220     */
;;;2221   void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;2222   {
;;;2223     /* Check the parameters */
;;;2224     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2225     assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;2226     assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;2227     assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;2228     assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;2229     assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;2230     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;2231   
;;;2232     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;2233        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;2234     TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  431a              ORRS     r2,r2,r3
000006  888b              LDRH     r3,[r1,#4]
000008  431a              ORRS     r2,r2,r3
00000a  88cb              LDRH     r3,[r1,#6]
00000c  431a              ORRS     r2,r2,r3
00000e  890b              LDRH     r3,[r1,#8]
000010  431a              ORRS     r2,r2,r3
000012  894b              LDRH     r3,[r1,#0xa]
000014  431a              ORRS     r2,r2,r3
000016  898b              LDRH     r3,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  f8a02044          STRH     r2,[r0,#0x44]
;;;2235                TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;2236                TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;2237                TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;2238   }
00001e  4770              BX       lr
;;;2239   
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;2245     */
;;;2246   void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;2247   {
;;;2248     /* Set the default configuration */
;;;2249     TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;2250     TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;2251     TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;2252     TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;2253     TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;2254     TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;2255     TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;2256   }
000010  4770              BX       lr
;;;2257   
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;2314     */
;;;2315   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;2316   { 
;;;2317     /* Check the parameters */
;;;2318     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2319     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2320     if (NewState != DISABLE)
;;;2321     {
;;;2322       /* Set the CCPC Bit */
;;;2323       TIMx->CR2 |= TIM_CR2_CCPC;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420201          ORR      r2,r2,#1
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;2324     }
;;;2325     else
;;;2326     {
;;;2327       /* Reset the CCPC Bit */
;;;2328       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;2329     }
;;;2330   }
000016  4770              BX       lr
;;;2331   /**
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1785     */
;;;1786   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b530              PUSH     {r4,r5,lr}
;;;1787   {
;;;1788     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1789   
;;;1790     /* Check the parameters */
;;;1791     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;1792     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1793     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1794   
;;;1795     tmp = CCER_CCE_SET << TIM_Channel;
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1796   
;;;1797     /* Reset the CCxE Bit */
;;;1798     TIMx->CCER &= (uint16_t)~ tmp;
00000a  8c04              LDRH     r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  8404              STRH     r4,[r0,#0x20]
;;;1799   
;;;1800     /* Set or reset the CCxE Bit */ 
;;;1801     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000010  8c04              LDRH     r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  b2ad              UXTH     r5,r5
000018  432c              ORRS     r4,r4,r5
00001a  8404              STRH     r4,[r0,#0x20]
;;;1802   }
00001c  bd30              POP      {r4,r5,pc}
;;;1803   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;1815     */
;;;1816   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b530              PUSH     {r4,r5,lr}
;;;1817   {
;;;1818     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1819   
;;;1820     /* Check the parameters */
;;;1821     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1822     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1823     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1824   
;;;1825     tmp = CCER_CCNE_SET << TIM_Channel;
000004  2404              MOVS     r4,#4
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1826   
;;;1827     /* Reset the CCxNE Bit */
;;;1828     TIMx->CCER &= (uint16_t) ~tmp;
00000a  8c04              LDRH     r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  8404              STRH     r4,[r0,#0x20]
;;;1829   
;;;1830     /* Set or reset the CCxNE Bit */ 
;;;1831     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000010  8c04              LDRH     r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  b2ad              UXTH     r5,r5
000018  432c              ORRS     r4,r4,r5
00001a  8404              STRH     r4,[r0,#0x20]
;;;1832   }
00001c  bd30              POP      {r4,r5,pc}
;;;1833   /**
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2484     */
;;;2485   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43ca              MVNS     r2,r1
;;;2486   {  
;;;2487     /* Check the parameters */
;;;2488     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2489      
;;;2490     /* Clear the flags */
;;;2491     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8202              STRH     r2,[r0,#0x10]
;;;2492   }
000004  4770              BX       lr
;;;2493   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2553     */
;;;2554   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43ca              MVNS     r2,r1
;;;2555   {
;;;2556     /* Check the parameters */
;;;2557     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2558   
;;;2559     /* Clear the IT pending Bit */
;;;2560     TIMx->SR = (uint16_t)~TIM_IT;
000002  8202              STRH     r2,[r0,#0x10]
;;;2561   }
000004  4770              BX       lr
;;;2562   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1475     */
;;;1476   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1477   {
;;;1478     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1479   
;;;1480     /* Check the parameters */
;;;1481     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1482     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1483   
;;;1484     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1485   
;;;1486     /* Reset the OC1CE Bit */
;;;1487     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1488   
;;;1489     /* Enable or Disable the Output Compare Clear Bit */
;;;1490     tmpccmr1 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1491   
;;;1492     /* Write to TIMx CCMR1 register */
;;;1493     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1494   }
000010  4770              BX       lr
;;;1495   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1505     */
;;;1506   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1507   {
;;;1508     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1509   
;;;1510     /* Check the parameters */
;;;1511     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1512     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1513   
;;;1514     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1515   
;;;1516     /* Reset the OC2CE Bit */
;;;1517     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1518   
;;;1519     /* Enable or Disable the Output Compare Clear Bit */
;;;1520     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1521   
;;;1522     /* Write to TIMx CCMR1 register */
;;;1523     TIMx->CCMR1 = tmpccmr1;
000014  8301              STRH     r1,[r0,#0x18]
;;;1524   }
000016  4770              BX       lr
;;;1525   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1534     */
;;;1535   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1536   {
;;;1537     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1538   
;;;1539     /* Check the parameters */
;;;1540     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1541     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1542   
;;;1543     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1544   
;;;1545     /* Reset the OC3CE Bit */
;;;1546     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1547   
;;;1548     /* Enable or Disable the Output Compare Clear Bit */
;;;1549     tmpccmr2 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1550   
;;;1551     /* Write to TIMx CCMR2 register */
;;;1552     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1553   }
000010  4770              BX       lr
;;;1554   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1563     */
;;;1564   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1565   {
;;;1566     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1567   
;;;1568     /* Check the parameters */
;;;1569     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1570     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1571   
;;;1572     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1573   
;;;1574     /* Reset the OC4CE Bit */
;;;1575     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1576   
;;;1577     /* Enable or Disable the Output Compare Clear Bit */
;;;1578     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1579   
;;;1580     /* Write to TIMx CCMR2 register */
;;;1581     TIMx->CCMR2 = tmpccmr2;
000014  8381              STRH     r1,[r0,#0x1c]
;;;1582   }
000016  4770              BX       lr
;;;1583   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;591      */
;;;592    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;593    {
;;;594      /* Check the parameters */
;;;595      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;596      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;597      
;;;598      if (NewState != DISABLE)
;;;599      {
;;;600        /* Enable the TIM Counter */
;;;601        TIMx->CR1 |= TIM_CR1_CEN;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;602      }
;;;603      else
;;;604      {
;;;605        /* Disable the TIM Counter */
;;;606        TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L17.22|
;;;607      }
;;;608    }
000016  4770              BX       lr
;;;609    /**
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;382      */
;;;383    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  460a              MOV      r2,r1
;;;384    {
;;;385      uint16_t tmpcr1 = 0;
000002  2100              MOVS     r1,#0
;;;386    
;;;387      /* Check the parameters */
;;;388      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;389      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;390    
;;;391      tmpcr1 = TIMx->CR1;
000004  8801              LDRH     r1,[r0,#0]
;;;392    
;;;393      /* Reset the CMS and DIR Bits */
;;;394      tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;395    
;;;396      /* Set the Counter Mode */
;;;397      tmpcr1 |= TIM_CounterMode;
00000c  4311              ORRS     r1,r1,r2
;;;398    
;;;399      /* Write to TIMx CR1 register */
;;;400      TIMx->CR1 = tmpcr1;
00000e  8001              STRH     r1,[r0,#0]
;;;401    }
000010  4770              BX       lr
;;;402    
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;2264     */
;;;2265   void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b131              CBZ      r1,|L19.16|
;;;2266   {
;;;2267     /* Check the parameters */
;;;2268     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2269     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2270   
;;;2271     if (NewState != DISABLE)
;;;2272     {
;;;2273       /* Enable the TIM Main Output */
;;;2274       TIMx->BDTR |= TIM_BDTR_MOE;
000002  f8b02044          LDRH     r2,[r0,#0x44]
000006  f4424200          ORR      r2,r2,#0x8000
00000a  f8a02044          STRH     r2,[r0,#0x44]
00000e  e005              B        |L19.28|
                  |L19.16|
;;;2275     }
;;;2276     else
;;;2277     {
;;;2278       /* Disable the TIM Main Output */
;;;2279       TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
000010  f8b02044          LDRH     r2,[r0,#0x44]
000014  f3c2020e          UBFX     r2,r2,#0,#15
000018  f8a02044          STRH     r2,[r0,#0x44]
                  |L19.28|
;;;2280     }  
;;;2281   }
00001c  4770              BX       lr
;;;2282   
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;2617     */
;;;2618   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;2619   { 
;;;2620     /* Check the parameters */
;;;2621     assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
;;;2622     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2623     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2624     
;;;2625     if (NewState != DISABLE)
;;;2626     {
;;;2627       /* Enable the DMA sources */
;;;2628       TIMx->DIER |= TIM_DMASource; 
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L20.16|
                  |L20.10|
;;;2629     }
;;;2630     else
;;;2631     {
;;;2632       /* Disable the DMA sources */
;;;2633       TIMx->DIER &= (uint16_t)~TIM_DMASource;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L20.16|
;;;2634     }
;;;2635   }
000010  4770              BX       lr
;;;2636   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;2590     */
;;;2591   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  ea410302          ORR      r3,r1,r2
;;;2592   {
;;;2593     /* Check the parameters */
;;;2594     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2595     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2596     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2597   
;;;2598     /* Set the DMA Base and the DMA Burst Length */
;;;2599     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000004  f8a03048          STRH     r3,[r0,#0x48]
;;;2600   }
000008  4770              BX       lr
;;;2601   
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;199      */
;;;200    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;201    {
000002  4604              MOV      r4,r0
;;;202      /* Check the parameters */
;;;203      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;204     
;;;205      if (TIMx == TIM1)
000004  4855              LDR      r0,|L22.348|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L22.28|
;;;206      {
;;;207        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;208        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  2100              MOVS     r1,#0
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e09d              B        |L22.344|
                  |L22.28|
;;;209      } 
;;;210      else if (TIMx == TIM2) 
00001c  f1b44f80          CMP      r4,#0x40000000
000020  d108              BNE      |L22.52|
;;;211      {     
;;;212        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;213        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e091              B        |L22.344|
                  |L22.52|
;;;214      }  
;;;215      else if (TIMx == TIM3)
000034  484a              LDR      r0,|L22.352|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L22.76|
;;;216      { 
;;;217        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;218        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000042  2100              MOVS     r1,#0
000044  2002              MOVS     r0,#2
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004a  e085              B        |L22.344|
                  |L22.76|
;;;219      }  
;;;220      else if (TIMx == TIM4)
00004c  4845              LDR      r0,|L22.356|
00004e  4284              CMP      r4,r0
000050  d108              BNE      |L22.100|
;;;221      { 
;;;222        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000052  2101              MOVS     r1,#1
000054  2004              MOVS     r0,#4
000056  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;223        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00005a  2100              MOVS     r1,#0
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000062  e079              B        |L22.344|
                  |L22.100|
;;;224      }  
;;;225      else if (TIMx == TIM5)
000064  4840              LDR      r0,|L22.360|
000066  4284              CMP      r4,r0
000068  d108              BNE      |L22.124|
;;;226      {      
;;;227        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;228        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000072  2100              MOVS     r1,#0
000074  2008              MOVS     r0,#8
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007a  e06d              B        |L22.344|
                  |L22.124|
;;;229      }  
;;;230      else if (TIMx == TIM6)  
00007c  483b              LDR      r0,|L22.364|
00007e  4284              CMP      r4,r0
000080  d108              BNE      |L22.148|
;;;231      {    
;;;232        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000082  2101              MOVS     r1,#1
000084  2010              MOVS     r0,#0x10
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;233        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
00008a  2100              MOVS     r1,#0
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000092  e061              B        |L22.344|
                  |L22.148|
;;;234      }  
;;;235      else if (TIMx == TIM7)
000094  4836              LDR      r0,|L22.368|
000096  4284              CMP      r4,r0
000098  d108              BNE      |L22.172|
;;;236      {      
;;;237        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2020              MOVS     r0,#0x20
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;238        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  2020              MOVS     r0,#0x20
0000a6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000aa  e055              B        |L22.344|
                  |L22.172|
;;;239      }  
;;;240      else if (TIMx == TIM8)
0000ac  4831              LDR      r0,|L22.372|
0000ae  4284              CMP      r4,r0
0000b0  d108              BNE      |L22.196|
;;;241      {      
;;;242        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  2002              MOVS     r0,#2
0000b6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;243        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
0000ba  2100              MOVS     r1,#0
0000bc  2002              MOVS     r0,#2
0000be  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000c2  e049              B        |L22.344|
                  |L22.196|
;;;244      }  
;;;245      else if (TIMx == TIM9)
0000c4  482c              LDR      r0,|L22.376|
0000c6  4284              CMP      r4,r0
0000c8  d109              BNE      |L22.222|
;;;246      {      
;;;247        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
0000ca  2101              MOVS     r1,#1
0000cc  0408              LSLS     r0,r1,#16
0000ce  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;248        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
0000d2  2100              MOVS     r1,#0
0000d4  f44f3080          MOV      r0,#0x10000
0000d8  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000dc  e03c              B        |L22.344|
                  |L22.222|
;;;249       }  
;;;250      else if (TIMx == TIM10)
0000de  4827              LDR      r0,|L22.380|
0000e0  4284              CMP      r4,r0
0000e2  d109              BNE      |L22.248|
;;;251      {      
;;;252        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000e4  2101              MOVS     r1,#1
0000e6  0448              LSLS     r0,r1,#17
0000e8  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;253        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
0000ec  2100              MOVS     r1,#0
0000ee  f44f3000          MOV      r0,#0x20000
0000f2  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000f6  e02f              B        |L22.344|
                  |L22.248|
;;;254      }  
;;;255      else if (TIMx == TIM11) 
0000f8  4821              LDR      r0,|L22.384|
0000fa  4284              CMP      r4,r0
0000fc  d109              BNE      |L22.274|
;;;256      {     
;;;257        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000fe  2101              MOVS     r1,#1
000100  0488              LSLS     r0,r1,#18
000102  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;258        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
000106  2100              MOVS     r1,#0
000108  f44f2080          MOV      r0,#0x40000
00010c  f7fffffe          BL       RCC_APB2PeriphResetCmd
000110  e022              B        |L22.344|
                  |L22.274|
;;;259      }  
;;;260      else if (TIMx == TIM12)
000112  481c              LDR      r0,|L22.388|
000114  4284              CMP      r4,r0
000116  d108              BNE      |L22.298|
;;;261      {      
;;;262        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
000118  2101              MOVS     r1,#1
00011a  2040              MOVS     r0,#0x40
00011c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;263        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
000120  2100              MOVS     r1,#0
000122  2040              MOVS     r0,#0x40
000124  f7fffffe          BL       RCC_APB1PeriphResetCmd
000128  e016              B        |L22.344|
                  |L22.298|
;;;264      }  
;;;265      else if (TIMx == TIM13) 
00012a  4817              LDR      r0,|L22.392|
00012c  4284              CMP      r4,r0
00012e  d108              BNE      |L22.322|
;;;266      {       
;;;267        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
000130  2101              MOVS     r1,#1
000132  2080              MOVS     r0,#0x80
000134  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;268        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
000138  2100              MOVS     r1,#0
00013a  2080              MOVS     r0,#0x80
00013c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000140  e00a              B        |L22.344|
                  |L22.322|
;;;269      }  
;;;270      else
;;;271      { 
;;;272        if (TIMx == TIM14) 
000142  4812              LDR      r0,|L22.396|
000144  4284              CMP      r4,r0
000146  d107              BNE      |L22.344|
;;;273        {     
;;;274          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000148  2101              MOVS     r1,#1
00014a  1580              ASRS     r0,r0,#22
00014c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;275          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
000150  2100              MOVS     r1,#0
000152  15a0              ASRS     r0,r4,#22
000154  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L22.344|
;;;276        }   
;;;277      }
;;;278    }
000158  bd10              POP      {r4,pc}
;;;279    
                          ENDP

00015a  0000              DCW      0x0000
                  |L22.348|
                          DCD      0x40010000
                  |L22.352|
                          DCD      0x40000400
                  |L22.356|
                          DCD      0x40000800
                  |L22.360|
                          DCD      0x40000c00
                  |L22.364|
                          DCD      0x40001000
                  |L22.368|
                          DCD      0x40001400
                  |L22.372|
                          DCD      0x40010400
                  |L22.376|
                          DCD      0x40014000
                  |L22.380|
                          DCD      0x40014400
                  |L22.384|
                          DCD      0x40014800
                  |L22.388|
                          DCD      0x40001800
                  |L22.392|
                          DCD      0x40001c00
                  |L22.396|
                          DCD      0x40002000

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;2773     */
;;;2774   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2775                               uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2776   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;2777     uint16_t tmpsmcr = 0;
00000c  2400              MOVS     r4,#0
;;;2778   
;;;2779     /* Check the parameters */
;;;2780     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2781     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2782     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2783     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2784     /* Configure the ETR Clock source */
;;;2785     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000e  4643              MOV      r3,r8
000010  463a              MOV      r2,r7
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       TIM_ETRConfig
;;;2786     
;;;2787     /* Get the TIMx SMCR register value */
;;;2788     tmpsmcr = TIMx->SMCR;
00001a  892c              LDRH     r4,[r5,#8]
;;;2789   
;;;2790     /* Reset the SMS Bits */
;;;2791     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
00001c  f64f70f8          MOV      r0,#0xfff8
000020  4004              ANDS     r4,r4,r0
;;;2792   
;;;2793     /* Select the External clock mode1 */
;;;2794     tmpsmcr |= TIM_SlaveMode_External1;
000022  f0440407          ORR      r4,r4,#7
;;;2795   
;;;2796     /* Select the Trigger selection : ETRF */
;;;2797     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000026  f64f708f          MOV      r0,#0xff8f
00002a  4004              ANDS     r4,r4,r0
;;;2798     tmpsmcr |= TIM_TS_ETRF;
00002c  f0440470          ORR      r4,r4,#0x70
;;;2799   
;;;2800     /* Write to TIMx SMCR */
;;;2801     TIMx->SMCR = tmpsmcr;
000030  812c              STRH     r4,[r5,#8]
;;;2802   }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;2803   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;2820     */
;;;2821   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;2822                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2823   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;2824     /* Check the parameters */
;;;2825     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2826     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2827     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2828     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2829   
;;;2830     /* Configure the ETR Clock source */
;;;2831     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463b              MOV      r3,r7
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TIM_ETRConfig
;;;2832   
;;;2833     /* Enable the External clock mode2 */
;;;2834     TIMx->SMCR |= TIM_SMCR_ECE;
000016  8920              LDRH     r0,[r4,#8]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  8120              STRH     r0,[r4,#8]
;;;2835   }
00001e  bdf0              POP      {r4-r7,pc}
;;;2836   /**
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;3011     */
;;;3012   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  b530              PUSH     {r4,r5,lr}
;;;3013                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;3014   {
000002  460c              MOV      r4,r1
;;;3015     uint16_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;3016   
;;;3017     /* Check the parameters */
;;;3018     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3019     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3020     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3021     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3022   
;;;3023     tmpsmcr = TIMx->SMCR;
000006  8901              LDRH     r1,[r0,#8]
;;;3024   
;;;3025     /* Reset the ETR Bits */
;;;3026     tmpsmcr &= SMCR_ETR_MASK;
000008  b2c9              UXTB     r1,r1
;;;3027   
;;;3028     /* Set the Prescaler, the Filter value and the Polarity */
;;;3029     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
00000a  f64f75ff          MOV      r5,#0xffff
00000e  ea052503          AND      r5,r5,r3,LSL #8
000012  4315              ORRS     r5,r5,r2
000014  4325              ORRS     r5,r5,r4
000016  4329              ORRS     r1,r1,r5
;;;3030   
;;;3031     /* Write to TIMx SMCR */
;;;3032     TIMx->SMCR = tmpsmcr;
000018  8101              STRH     r1,[r0,#8]
;;;3033   }
00001a  bd30              POP      {r4,r5,pc}
;;;3034   /**
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;3069     */
;;;3070   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3071                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;3072   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
000006  461e              MOV      r6,r3
;;;3073     uint16_t tmpsmcr = 0;
000008  2100              MOVS     r1,#0
;;;3074     uint16_t tmpccmr1 = 0;
00000a  2200              MOVS     r2,#0
;;;3075     uint16_t tmpccer = 0;
00000c  2300              MOVS     r3,#0
;;;3076       
;;;3077     /* Check the parameters */
;;;3078     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3079     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;3080     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;3081     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;3082   
;;;3083     /* Get the TIMx SMCR register value */
;;;3084     tmpsmcr = TIMx->SMCR;
00000e  8901              LDRH     r1,[r0,#8]
;;;3085   
;;;3086     /* Get the TIMx CCMR1 register value */
;;;3087     tmpccmr1 = TIMx->CCMR1;
000010  8b02              LDRH     r2,[r0,#0x18]
;;;3088   
;;;3089     /* Get the TIMx CCER register value */
;;;3090     tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;3091   
;;;3092     /* Set the encoder Mode */
;;;3093     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
000014  f64f77f8          MOV      r7,#0xfff8
000018  4039              ANDS     r1,r1,r7
;;;3094     tmpsmcr |= TIM_EncoderMode;
00001a  4321              ORRS     r1,r1,r4
;;;3095   
;;;3096     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3097     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
00001c  f64f47fc          MOV      r7,#0xfcfc
000020  403a              ANDS     r2,r2,r7
;;;3098     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000022  f2401701          MOV      r7,#0x101
000026  433a              ORRS     r2,r2,r7
;;;3099   
;;;3100     /* Set the TI1 and the TI2 Polarities */
;;;3101     tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
000028  f64f77dd          MOV      r7,#0xffdd
00002c  403b              ANDS     r3,r3,r7
;;;3102     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00002e  f64f77ff          MOV      r7,#0xffff
000032  ea071706          AND      r7,r7,r6,LSL #4
000036  432f              ORRS     r7,r7,r5
000038  433b              ORRS     r3,r3,r7
;;;3103   
;;;3104     /* Write to TIMx SMCR */
;;;3105     TIMx->SMCR = tmpsmcr;
00003a  8101              STRH     r1,[r0,#8]
;;;3106   
;;;3107     /* Write to TIMx CCMR1 */
;;;3108     TIMx->CCMR1 = tmpccmr1;
00003c  8302              STRH     r2,[r0,#0x18]
;;;3109   
;;;3110     /* Write to TIMx CCER */
;;;3111     TIMx->CCER = tmpccer;
00003e  8403              STRH     r3,[r0,#0x20]
;;;3112   }
000040  bdf0              POP      {r4-r7,pc}
;;;3113   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1123     */
;;;1124   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1125   {
;;;1126     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1127   
;;;1128     /* Check the parameters */
;;;1129     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1130     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1131     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1132   
;;;1133     /* Reset the OC1M Bits */
;;;1134     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1135   
;;;1136     /* Configure The Forced output Mode */
;;;1137     tmpccmr1 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1138   
;;;1139     /* Write to TIMx CCMR1 register */
;;;1140     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1141   }
000010  4770              BX       lr
;;;1142   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1152     */
;;;1153   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1154   {
;;;1155     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1156   
;;;1157     /* Check the parameters */
;;;1158     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1159     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1160     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1161   
;;;1162     /* Reset the OC2M Bits */
;;;1163     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1164   
;;;1165     /* Configure The Forced output Mode */
;;;1166     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1167   
;;;1168     /* Write to TIMx CCMR1 register */
;;;1169     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1170   }
000018  4770              BX       lr
;;;1171   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1180     */
;;;1181   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1182   {
;;;1183     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1184   
;;;1185     /* Check the parameters */
;;;1186     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1187     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1188   
;;;1189     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1190   
;;;1191     /* Reset the OC1M Bits */
;;;1192     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1193   
;;;1194     /* Configure The Forced output Mode */
;;;1195     tmpccmr2 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1196   
;;;1197     /* Write to TIMx CCMR2 register */
;;;1198     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1199   }
000010  4770              BX       lr
;;;1200   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1209     */
;;;1210   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1211   {
;;;1212     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1213   
;;;1214     /* Check the parameters */
;;;1215     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1216     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1217     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1218   
;;;1219     /* Reset the OC2M Bits */
;;;1220     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1221   
;;;1222     /* Configure The Forced output Mode */
;;;1223     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1224   
;;;1225     /* Write to TIMx CCMR2 register */
;;;1226     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1227   }
000018  4770              BX       lr
;;;1228   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;2409     */
;;;2410   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;2411   { 
;;;2412     /* Check the parameters */
;;;2413     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2414     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;2415    
;;;2416     /* Set the event sources */
;;;2417     TIMx->EGR = TIM_EventSource;
;;;2418   }
000002  4770              BX       lr
;;;2419   
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2031     */
;;;2032   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2033   {
;;;2034     /* Check the parameters */
;;;2035     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2036   
;;;2037     /* Get the Capture 1 Register value */
;;;2038     return TIMx->CCR1;
000002  6b48              LDR      r0,[r1,#0x34]
;;;2039   }
000004  4770              BX       lr
;;;2040   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2046     */
;;;2047   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2048   {
;;;2049     /* Check the parameters */
;;;2050     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2051   
;;;2052     /* Get the Capture 2 Register value */
;;;2053     return TIMx->CCR2;
000002  6b88              LDR      r0,[r1,#0x38]
;;;2054   }
000004  4770              BX       lr
;;;2055   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2060     */
;;;2061   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2062   {
;;;2063     /* Check the parameters */
;;;2064     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2065   
;;;2066     /* Get the Capture 3 Register value */
;;;2067     return TIMx->CCR3;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;2068   }
000004  4770              BX       lr
;;;2069   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2074     */
;;;2075   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2076   {
;;;2077     /* Check the parameters */
;;;2078     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2079   
;;;2080     /* Get the Capture 4 Register value */
;;;2081     return TIMx->CCR4;
000002  6c08              LDR      r0,[r1,#0x40]
;;;2082   }
000004  4770              BX       lr
;;;2083   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;437      */
;;;438    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;439    {
;;;440      /* Check the parameters */
;;;441      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;442    
;;;443      /* Get the Counter Register value */
;;;444      return TIMx->CNT;
000002  6a48              LDR      r0,[r1,#0x24]
;;;445    }
000004  4770              BX       lr
;;;446    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2442     */
;;;2443   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2444   { 
;;;2445     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2446     /* Check the parameters */
;;;2447     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2448     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2449   
;;;2450     
;;;2451     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a13              LDRH     r3,[r2,#0x10]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L37.14|
;;;2452     {
;;;2453       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L37.16|
                  |L37.14|
;;;2454     }
;;;2455     else
;;;2456     {
;;;2457       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L37.16|
;;;2458     }
;;;2459     return bitstatus;
;;;2460   }
000010  4770              BX       lr
;;;2461   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2512     */
;;;2513   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2514   {
000002  4602              MOV      r2,r0
;;;2515     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;2516     uint16_t itstatus = 0x0, itenable = 0x0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;2517     /* Check the parameters */
;;;2518     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2519     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2520      
;;;2521     itstatus = TIMx->SR & TIM_IT;
00000a  8a15              LDRH     r5,[r2,#0x10]
00000c  ea050301          AND      r3,r5,r1
;;;2522     
;;;2523     itenable = TIMx->DIER & TIM_IT;
000010  8995              LDRH     r5,[r2,#0xc]
000012  ea050401          AND      r4,r5,r1
;;;2524     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000016  b113              CBZ      r3,|L38.30|
000018  b10c              CBZ      r4,|L38.30|
;;;2525     {
;;;2526       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L38.32|
                  |L38.30|
;;;2527     }
;;;2528     else
;;;2529     {
;;;2530       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L38.32|
;;;2531     }
;;;2532     return bitstatus;
;;;2533   }
000020  bd30              POP      {r4,r5,pc}
;;;2534   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;451      */
;;;452    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;453    {
;;;454      /* Check the parameters */
;;;455      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;456    
;;;457      /* Get the Prescaler Register value */
;;;458      return TIMx->PSC;
000002  8d08              LDRH     r0,[r1,#0x28]
;;;459    }
000004  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;1899     */
;;;1900   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1901   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1902     /* Check the parameters */
;;;1903     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1904     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1905     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1906     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1907     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1908     
;;;1909     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  8820              LDRH     r0,[r4,#0]
000008  b950              CBNZ     r0,|L40.32|
;;;1910     {
;;;1911       /* TI1 Configuration */
;;;1912       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00000a  8923              LDRH     r3,[r4,#8]
00000c  88a2              LDRH     r2,[r4,#4]
00000e  8861              LDRH     r1,[r4,#2]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       TI1_Config
;;;1913                  TIM_ICInitStruct->TIM_ICSelection,
;;;1914                  TIM_ICInitStruct->TIM_ICFilter);
;;;1915       /* Set the Input Capture Prescaler value */
;;;1916       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000016  88e1              LDRH     r1,[r4,#6]
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       TIM_SetIC1Prescaler
00001e  e025              B        |L40.108|
                  |L40.32|
;;;1917     }
;;;1918     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000020  8820              LDRH     r0,[r4,#0]
000022  2804              CMP      r0,#4
000024  d10a              BNE      |L40.60|
;;;1919     {
;;;1920       /* TI2 Configuration */
;;;1921       assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1922       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI2_Config
;;;1923                  TIM_ICInitStruct->TIM_ICSelection,
;;;1924                  TIM_ICInitStruct->TIM_ICFilter);
;;;1925       /* Set the Input Capture Prescaler value */
;;;1926       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC2Prescaler
00003a  e017              B        |L40.108|
                  |L40.60|
;;;1927     }
;;;1928     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00003c  8820              LDRH     r0,[r4,#0]
00003e  2808              CMP      r0,#8
000040  d10a              BNE      |L40.88|
;;;1929     {
;;;1930       /* TI3 Configuration */
;;;1931       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1932       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000042  8923              LDRH     r3,[r4,#8]
000044  88a2              LDRH     r2,[r4,#4]
000046  8861              LDRH     r1,[r4,#2]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TI3_Config
;;;1933                  TIM_ICInitStruct->TIM_ICSelection,
;;;1934                  TIM_ICInitStruct->TIM_ICFilter);
;;;1935       /* Set the Input Capture Prescaler value */
;;;1936       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00004e  88e1              LDRH     r1,[r4,#6]
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       TIM_SetIC3Prescaler
000056  e009              B        |L40.108|
                  |L40.88|
;;;1937     }
;;;1938     else
;;;1939     {
;;;1940       /* TI4 Configuration */
;;;1941       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1942       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000058  8923              LDRH     r3,[r4,#8]
00005a  88a2              LDRH     r2,[r4,#4]
00005c  8861              LDRH     r1,[r4,#2]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TI4_Config
;;;1943                  TIM_ICInitStruct->TIM_ICSelection,
;;;1944                  TIM_ICInitStruct->TIM_ICFilter);
;;;1945       /* Set the Input Capture Prescaler value */
;;;1946       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000064  88e1              LDRH     r1,[r4,#6]
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L40.108|
;;;1947     }
;;;1948   }
00006c  bd70              POP      {r4-r6,pc}
;;;1949   
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;1955     */
;;;1956   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;1957   {
;;;1958     /* Set the default configuration */
;;;1959     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;1960     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;1961     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2101              MOVS     r1,#1
000008  8081              STRH     r1,[r0,#4]
;;;1962     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;1963     TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000e  8101              STRH     r1,[r0,#8]
;;;1964   }
000010  4770              BX       lr
;;;1965   
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;2371     */
;;;2372   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L42.10|
;;;2373   {  
;;;2374     /* Check the parameters */
;;;2375     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2376     assert_param(IS_TIM_IT(TIM_IT));
;;;2377     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2378     
;;;2379     if (NewState != DISABLE)
;;;2380     {
;;;2381       /* Enable the Interrupt sources */
;;;2382       TIMx->DIER |= TIM_IT;
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L42.16|
                  |L42.10|
;;;2383     }
;;;2384     else
;;;2385     {
;;;2386       /* Disable the Interrupt sources */
;;;2387       TIMx->DIER &= (uint16_t)~TIM_IT;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L42.16|
;;;2388     }
;;;2389   }
000010  4770              BX       lr
;;;2390   
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;2703     */
;;;2704   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b530              PUSH     {r4,r5,lr}
;;;2705   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2706     /* Check the parameters */
;;;2707     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2708     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2709   
;;;2710     /* Select the Internal Trigger */
;;;2711     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIM_SelectInputTrigger
;;;2712   
;;;2713     /* Select the External clock mode1 */
;;;2714     TIMx->SMCR |= TIM_SlaveMode_External1;
00000e  8920              LDRH     r0,[r4,#8]
000010  f0400007          ORR      r0,r0,#7
000014  8120              STRH     r0,[r4,#8]
;;;2715   }
000016  bd30              POP      {r4,r5,pc}
;;;2716   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;2682     */
;;;2683   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;2684   {
;;;2685     /* Check the parameters */
;;;2686     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2687   
;;;2688     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2689     TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
000002  f64f72f8          MOV      r2,#0xfff8
000006  4011              ANDS     r1,r1,r2
000008  8101              STRH     r1,[r0,#8]
;;;2690   }
00000a  4770              BX       lr
;;;2691   
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1354     */
;;;1355   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1356   {
;;;1357     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1358   
;;;1359     /* Check the parameters */
;;;1360     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1361     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1362   
;;;1363     /* Get the TIMx CCMR1 register value */
;;;1364     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1365   
;;;1366     /* Reset the OC1FE Bit */
;;;1367     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1368   
;;;1369     /* Enable or Disable the Output Compare Fast Bit */
;;;1370     tmpccmr1 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1371   
;;;1372     /* Write to TIMx CCMR1 */
;;;1373     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1374   }
000010  4770              BX       lr
;;;1375   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;672      */
;;;673    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;674    {
;;;675      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;676       
;;;677      /* Check the parameters */
;;;678      assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;679      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;680      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;681      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;682    
;;;683      /* Disable the Channel 1: Reset the CC1E Bit */
;;;684      TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76fe          MOV      r6,#0xfffe
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;685      
;;;686      /* Get the TIMx CCER register value */
;;;687      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;688      /* Get the TIMx CR2 register value */
;;;689      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;690      
;;;691      /* Get the TIMx CCMR1 register value */
;;;692      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;693        
;;;694      /* Reset the Output Compare Mode Bits */
;;;695      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;696      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
00001e  1eb5              SUBS     r5,r6,#2
000020  402c              ANDS     r4,r4,r5
;;;697      /* Select the Output Compare Mode */
;;;698      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000022  880d              LDRH     r5,[r1,#0]
000024  432c              ORRS     r4,r4,r5
;;;699      
;;;700      /* Reset the Output Polarity level */
;;;701      tmpccer &= (uint16_t)~TIM_CCER_CC1P;
000026  1e75              SUBS     r5,r6,#1
000028  402a              ANDS     r2,r2,r5
;;;702      /* Set the Output Compare Polarity */
;;;703      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00002a  898d              LDRH     r5,[r1,#0xc]
00002c  432a              ORRS     r2,r2,r5
;;;704      
;;;705      /* Set the Output State */
;;;706      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00002e  884d              LDRH     r5,[r1,#2]
000030  432a              ORRS     r2,r2,r5
;;;707        
;;;708      if((TIMx == TIM1) || (TIMx == TIM8))
000032  4d10              LDR      r5,|L46.116|
000034  42a8              CMP      r0,r5
000036  d002              BEQ      |L46.62|
000038  4d0f              LDR      r5,|L46.120|
00003a  42a8              CMP      r0,r5
00003c  d113              BNE      |L46.102|
                  |L46.62|
;;;709      {
;;;710        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;711        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;712        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;713        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;714        
;;;715        /* Reset the Output N Polarity level */
;;;716        tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
00003e  f64f75f7          MOV      r5,#0xfff7
000042  402a              ANDS     r2,r2,r5
;;;717        /* Set the Output N Polarity */
;;;718        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000044  89cd              LDRH     r5,[r1,#0xe]
000046  432a              ORRS     r2,r2,r5
;;;719        /* Reset the Output N State */
;;;720        tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
000048  f64f75fb          MOV      r5,#0xfffb
00004c  402a              ANDS     r2,r2,r5
;;;721        
;;;722        /* Set the Output N State */
;;;723        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
00004e  888d              LDRH     r5,[r1,#4]
000050  432a              ORRS     r2,r2,r5
;;;724        /* Reset the Output Compare and Output Compare N IDLE State */
;;;725        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
000052  f64f65ff          MOV      r5,#0xfeff
000056  402b              ANDS     r3,r3,r5
;;;726        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
000058  f64f55ff          MOV      r5,#0xfdff
00005c  402b              ANDS     r3,r3,r5
;;;727        /* Set the Output Idle state */
;;;728        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00005e  8a0d              LDRH     r5,[r1,#0x10]
000060  432b              ORRS     r3,r3,r5
;;;729        /* Set the Output N Idle state */
;;;730        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000062  8a4d              LDRH     r5,[r1,#0x12]
000064  432b              ORRS     r3,r3,r5
                  |L46.102|
;;;731      }
;;;732      /* Write to TIMx CR2 */
;;;733      TIMx->CR2 = tmpcr2;
000066  8083              STRH     r3,[r0,#4]
;;;734      
;;;735      /* Write to TIMx CCMR1 */
;;;736      TIMx->CCMR1 = tmpccmrx;
000068  8304              STRH     r4,[r0,#0x18]
;;;737      
;;;738      /* Set the Capture Compare Register value */
;;;739      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
00006a  688d              LDR      r5,[r1,#8]
00006c  6345              STR      r5,[r0,#0x34]
;;;740      
;;;741      /* Write to TIMx CCER */
;;;742      TIMx->CCER = tmpccer;
00006e  8402              STRH     r2,[r0,#0x20]
;;;743    }
000070  bd70              POP      {r4-r6,pc}
;;;744    
                          ENDP

000072  0000              DCW      0x0000
                  |L46.116|
                          DCD      0x40010000
                  |L46.120|
                          DCD      0x40010400

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1619     */
;;;1620   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1621   {
;;;1622     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1623     /* Check the parameters */
;;;1624     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1625     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1626      
;;;1627     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1628   
;;;1629     /* Set or Reset the CC1NP Bit */
;;;1630     tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1631     tmpccer |= TIM_OCNPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;1632   
;;;1633     /* Write to TIMx CCER register */
;;;1634     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;1635   }
000010  4770              BX       lr
;;;1636   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1592     */
;;;1593   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1594   {
;;;1595     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1596   
;;;1597     /* Check the parameters */
;;;1598     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1599     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1600   
;;;1601     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1602   
;;;1603     /* Set or Reset the CC1P Bit */
;;;1604     tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
000006  f64f73fd          MOV      r3,#0xfffd
00000a  4019              ANDS     r1,r1,r3
;;;1605     tmpccer |= TIM_OCPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;1606   
;;;1607     /* Write to TIMx CCER register */
;;;1608     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;1609   }
000010  4770              BX       lr
;;;1610   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1237     */
;;;1238   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1239   {
;;;1240     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1241   
;;;1242     /* Check the parameters */
;;;1243     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1244     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1245   
;;;1246     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1247   
;;;1248     /* Reset the OC1PE Bit */
;;;1249     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1250   
;;;1251     /* Enable or Disable the Output Compare Preload feature */
;;;1252     tmpccmr1 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1253   
;;;1254     /* Write to TIMx CCMR1 register */
;;;1255     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1256   }
000010  4770              BX       lr
;;;1257   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1385     */
;;;1386   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1387   {
;;;1388     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1389   
;;;1390     /* Check the parameters */
;;;1391     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1392     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1393   
;;;1394     /* Get the TIMx CCMR1 register value */
;;;1395     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1396   
;;;1397     /* Reset the OC2FE Bit */
;;;1398     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1399   
;;;1400     /* Enable or Disable the Output Compare Fast Bit */
;;;1401     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1402   
;;;1403     /* Write to TIMx CCMR1 */
;;;1404     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1405   }
000018  4770              BX       lr
;;;1406   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;753      */
;;;754    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;755    {
;;;756      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;757       
;;;758      /* Check the parameters */
;;;759      assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;760      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;761      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;762      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;763    
;;;764      /* Disable the Channel 2: Reset the CC2E Bit */
;;;765      TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76ef          MOV      r6,#0xffef
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;766      
;;;767      /* Get the TIMx CCER register value */  
;;;768      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;769      /* Get the TIMx CR2 register value */
;;;770      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;771      
;;;772      /* Get the TIMx CCMR1 register value */
;;;773      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;774        
;;;775      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;776      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402c              ANDS     r4,r4,r5
;;;777      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
00001e  f64f45ff          MOV      r5,#0xfcff
000022  402c              ANDS     r4,r4,r5
;;;778      
;;;779      /* Select the Output Compare Mode */
;;;780      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000024  880d              LDRH     r5,[r1,#0]
000026  f64f76ff          MOV      r6,#0xffff
00002a  ea062505          AND      r5,r6,r5,LSL #8
00002e  432c              ORRS     r4,r4,r5
;;;781      
;;;782      /* Reset the Output Polarity level */
;;;783      tmpccer &= (uint16_t)~TIM_CCER_CC2P;
000030  f64f75df          MOV      r5,#0xffdf
000034  402a              ANDS     r2,r2,r5
;;;784      /* Set the Output Compare Polarity */
;;;785      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000036  898d              LDRH     r5,[r1,#0xc]
000038  ea061505          AND      r5,r6,r5,LSL #4
00003c  432a              ORRS     r2,r2,r5
;;;786      
;;;787      /* Set the Output State */
;;;788      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
00003e  884d              LDRH     r5,[r1,#2]
000040  ea061505          AND      r5,r6,r5,LSL #4
000044  432a              ORRS     r2,r2,r5
;;;789        
;;;790      if((TIMx == TIM1) || (TIMx == TIM8))
000046  4d15              LDR      r5,|L51.156|
000048  42a8              CMP      r0,r5
00004a  d002              BEQ      |L51.82|
00004c  4d14              LDR      r5,|L51.160|
00004e  42a8              CMP      r0,r5
000050  d11d              BNE      |L51.142|
                  |L51.82|
;;;791      {
;;;792        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;793        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;794        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;795        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;796        
;;;797        /* Reset the Output N Polarity level */
;;;798        tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
000052  f64f757f          MOV      r5,#0xff7f
000056  402a              ANDS     r2,r2,r5
;;;799        /* Set the Output N Polarity */
;;;800        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000058  89cd              LDRH     r5,[r1,#0xe]
00005a  f64f76ff          MOV      r6,#0xffff
00005e  ea061505          AND      r5,r6,r5,LSL #4
000062  432a              ORRS     r2,r2,r5
;;;801        /* Reset the Output N State */
;;;802        tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
000064  f64f75bf          MOV      r5,#0xffbf
000068  402a              ANDS     r2,r2,r5
;;;803        
;;;804        /* Set the Output N State */
;;;805        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
00006a  888d              LDRH     r5,[r1,#4]
00006c  ea061505          AND      r5,r6,r5,LSL #4
000070  432a              ORRS     r2,r2,r5
;;;806        /* Reset the Output Compare and Output Compare N IDLE State */
;;;807        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
000072  f64f35ff          MOV      r5,#0xfbff
000076  402b              ANDS     r3,r3,r5
;;;808        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
000078  f24f75ff          MOV      r5,#0xf7ff
00007c  402b              ANDS     r3,r3,r5
;;;809        /* Set the Output Idle state */
;;;810        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
00007e  8a0d              LDRH     r5,[r1,#0x10]
000080  ea060585          AND      r5,r6,r5,LSL #2
000084  432b              ORRS     r3,r3,r5
;;;811        /* Set the Output N Idle state */
;;;812        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000086  8a4d              LDRH     r5,[r1,#0x12]
000088  ea060585          AND      r5,r6,r5,LSL #2
00008c  432b              ORRS     r3,r3,r5
                  |L51.142|
;;;813      }
;;;814      /* Write to TIMx CR2 */
;;;815      TIMx->CR2 = tmpcr2;
00008e  8083              STRH     r3,[r0,#4]
;;;816      
;;;817      /* Write to TIMx CCMR1 */
;;;818      TIMx->CCMR1 = tmpccmrx;
000090  8304              STRH     r4,[r0,#0x18]
;;;819      
;;;820      /* Set the Capture Compare Register value */
;;;821      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000092  688d              LDR      r5,[r1,#8]
000094  6385              STR      r5,[r0,#0x38]
;;;822      
;;;823      /* Write to TIMx CCER */
;;;824      TIMx->CCER = tmpccer;
000096  8402              STRH     r2,[r0,#0x20]
;;;825    }
000098  bd70              POP      {r4-r6,pc}
;;;826    
                          ENDP

00009a  0000              DCW      0x0000
                  |L51.156|
                          DCD      0x40010000
                  |L51.160|
                          DCD      0x40010400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1673     */
;;;1674   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1675   {
;;;1676     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1677   
;;;1678     /* Check the parameters */
;;;1679     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1680     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1681     
;;;1682     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1683   
;;;1684     /* Set or Reset the CC2NP Bit */
;;;1685     tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1686     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;1687   
;;;1688     /* Write to TIMx CCER register */
;;;1689     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1690   }
000018  4770              BX       lr
;;;1691   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1646     */
;;;1647   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1648   {
;;;1649     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1650   
;;;1651     /* Check the parameters */
;;;1652     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1653     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1654   
;;;1655     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1656   
;;;1657     /* Set or Reset the CC2P Bit */
;;;1658     tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
000006  f64f73df          MOV      r3,#0xffdf
00000a  4019              ANDS     r1,r1,r3
;;;1659     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;1660   
;;;1661     /* Write to TIMx CCER register */
;;;1662     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1663   }
000018  4770              BX       lr
;;;1664   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1267     */
;;;1268   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1269   {
;;;1270     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1271   
;;;1272     /* Check the parameters */
;;;1273     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1274     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1275   
;;;1276     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1277   
;;;1278     /* Reset the OC2PE Bit */
;;;1279     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1280   
;;;1281     /* Enable or Disable the Output Compare Preload feature */
;;;1282     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1283   
;;;1284     /* Write to TIMx CCMR1 register */
;;;1285     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1286   }
000018  4770              BX       lr
;;;1287   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1415     */
;;;1416   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1417   {
;;;1418     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1419     
;;;1420     /* Check the parameters */
;;;1421     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1422     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1423   
;;;1424     /* Get the TIMx CCMR2 register value */
;;;1425     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1426   
;;;1427     /* Reset the OC3FE Bit */
;;;1428     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1429   
;;;1430     /* Enable or Disable the Output Compare Fast Bit */
;;;1431     tmpccmr2 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1432   
;;;1433     /* Write to TIMx CCMR2 */
;;;1434     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1435   }
000010  4770              BX       lr
;;;1436   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;834      */
;;;835    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;836    {
;;;837      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;838       
;;;839      /* Check the parameters */
;;;840      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;841      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;842      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;843      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;844    
;;;845      /* Disable the Channel 3: Reset the CC2E Bit */
;;;846      TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f66ff          MOV      r6,#0xfeff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;847      
;;;848      /* Get the TIMx CCER register value */
;;;849      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;850      /* Get the TIMx CR2 register value */
;;;851      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;852      
;;;853      /* Get the TIMx CCMR2 register value */
;;;854      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;855        
;;;856      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;857      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;858      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
00001e  f64f75fc          MOV      r5,#0xfffc
000022  402c              ANDS     r4,r4,r5
;;;859      /* Select the Output Compare Mode */
;;;860      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000024  880d              LDRH     r5,[r1,#0]
000026  432c              ORRS     r4,r4,r5
;;;861      
;;;862      /* Reset the Output Polarity level */
;;;863      tmpccer &= (uint16_t)~TIM_CCER_CC3P;
000028  f64f55ff          MOV      r5,#0xfdff
00002c  402a              ANDS     r2,r2,r5
;;;864      /* Set the Output Compare Polarity */
;;;865      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00002e  898d              LDRH     r5,[r1,#0xc]
000030  f64f76ff          MOV      r6,#0xffff
000034  ea062505          AND      r5,r6,r5,LSL #8
000038  432a              ORRS     r2,r2,r5
;;;866      
;;;867      /* Set the Output State */
;;;868      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
00003a  884d              LDRH     r5,[r1,#2]
00003c  ea062505          AND      r5,r6,r5,LSL #8
000040  432a              ORRS     r2,r2,r5
;;;869        
;;;870      if((TIMx == TIM1) || (TIMx == TIM8))
000042  4d15              LDR      r5,|L56.152|
000044  42a8              CMP      r0,r5
000046  d002              BEQ      |L56.78|
000048  4d14              LDR      r5,|L56.156|
00004a  42a8              CMP      r0,r5
00004c  d11d              BNE      |L56.138|
                  |L56.78|
;;;871      {
;;;872        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;873        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;874        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;875        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;876        
;;;877        /* Reset the Output N Polarity level */
;;;878        tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
00004e  f24f75ff          MOV      r5,#0xf7ff
000052  402a              ANDS     r2,r2,r5
;;;879        /* Set the Output N Polarity */
;;;880        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000054  89cd              LDRH     r5,[r1,#0xe]
000056  f64f76ff          MOV      r6,#0xffff
00005a  ea062505          AND      r5,r6,r5,LSL #8
00005e  432a              ORRS     r2,r2,r5
;;;881        /* Reset the Output N State */
;;;882        tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
000060  f64f35ff          MOV      r5,#0xfbff
000064  402a              ANDS     r2,r2,r5
;;;883        
;;;884        /* Set the Output N State */
;;;885        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
000066  888d              LDRH     r5,[r1,#4]
000068  ea062505          AND      r5,r6,r5,LSL #8
00006c  432a              ORRS     r2,r2,r5
;;;886        /* Reset the Output Compare and Output Compare N IDLE State */
;;;887        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
00006e  f64e75ff          MOV      r5,#0xefff
000072  402b              ANDS     r3,r3,r5
;;;888        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
000074  f64d75ff          MOV      r5,#0xdfff
000078  402b              ANDS     r3,r3,r5
;;;889        /* Set the Output Idle state */
;;;890        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
00007a  8a0d              LDRH     r5,[r1,#0x10]
00007c  ea061505          AND      r5,r6,r5,LSL #4
000080  432b              ORRS     r3,r3,r5
;;;891        /* Set the Output N Idle state */
;;;892        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000082  8a4d              LDRH     r5,[r1,#0x12]
000084  ea061505          AND      r5,r6,r5,LSL #4
000088  432b              ORRS     r3,r3,r5
                  |L56.138|
;;;893      }
;;;894      /* Write to TIMx CR2 */
;;;895      TIMx->CR2 = tmpcr2;
00008a  8083              STRH     r3,[r0,#4]
;;;896      
;;;897      /* Write to TIMx CCMR2 */
;;;898      TIMx->CCMR2 = tmpccmrx;
00008c  8384              STRH     r4,[r0,#0x1c]
;;;899      
;;;900      /* Set the Capture Compare Register value */
;;;901      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00008e  688d              LDR      r5,[r1,#8]
000090  63c5              STR      r5,[r0,#0x3c]
;;;902      
;;;903      /* Write to TIMx CCER */
;;;904      TIMx->CCER = tmpccer;
000092  8402              STRH     r2,[r0,#0x20]
;;;905    }
000094  bd70              POP      {r4-r6,pc}
;;;906    
                          ENDP

000096  0000              DCW      0x0000
                  |L56.152|
                          DCD      0x40010000
                  |L56.156|
                          DCD      0x40010400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1727     */
;;;1728   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1729   {
;;;1730     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1731    
;;;1732     /* Check the parameters */
;;;1733     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1734     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1735       
;;;1736     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1737   
;;;1738     /* Set or Reset the CC3NP Bit */
;;;1739     tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1740     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1741   
;;;1742     /* Write to TIMx CCER register */
;;;1743     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1744   }
000018  4770              BX       lr
;;;1745   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1700     */
;;;1701   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1702   {
;;;1703     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1704   
;;;1705     /* Check the parameters */
;;;1706     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1707     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1708   
;;;1709     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1710   
;;;1711     /* Set or Reset the CC3P Bit */
;;;1712     tmpccer &= (uint16_t)~TIM_CCER_CC3P;
000006  f64f53ff          MOV      r3,#0xfdff
00000a  4019              ANDS     r1,r1,r3
;;;1713     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1714   
;;;1715     /* Write to TIMx CCER register */
;;;1716     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1717   }
000018  4770              BX       lr
;;;1718   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1296     */
;;;1297   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1298   {
;;;1299     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1300   
;;;1301     /* Check the parameters */
;;;1302     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1303     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1304   
;;;1305     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1306   
;;;1307     /* Reset the OC3PE Bit */
;;;1308     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1309   
;;;1310     /* Enable or Disable the Output Compare Preload feature */
;;;1311     tmpccmr2 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1312   
;;;1313     /* Write to TIMx CCMR2 register */
;;;1314     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1315   }
000010  4770              BX       lr
;;;1316   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1445     */
;;;1446   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1447   {
;;;1448     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1449   
;;;1450     /* Check the parameters */
;;;1451     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1452     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1453   
;;;1454     /* Get the TIMx CCMR2 register value */
;;;1455     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1456   
;;;1457     /* Reset the OC4FE Bit */
;;;1458     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1459   
;;;1460     /* Enable or Disable the Output Compare Fast Bit */
;;;1461     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1462   
;;;1463     /* Write to TIMx CCMR2 */
;;;1464     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1465   }
000018  4770              BX       lr
;;;1466   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;914      */
;;;915    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;916    {
;;;917      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;918       
;;;919      /* Check the parameters */
;;;920      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;921      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;922      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;923      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;924    
;;;925      /* Disable the Channel 4: Reset the CC4E Bit */
;;;926      TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64e76ff          MOV      r6,#0xefff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;927      
;;;928      /* Get the TIMx CCER register value */
;;;929      tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;930      /* Get the TIMx CR2 register value */
;;;931      tmpcr2 =  TIMx->CR2;
000014  8884              LDRH     r4,[r0,#4]
;;;932      
;;;933      /* Get the TIMx CCMR2 register value */
;;;934      tmpccmrx = TIMx->CCMR2;
000016  8b82              LDRH     r2,[r0,#0x1c]
;;;935        
;;;936      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;937      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402a              ANDS     r2,r2,r5
;;;938      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
00001e  f64f45ff          MOV      r5,#0xfcff
000022  402a              ANDS     r2,r2,r5
;;;939      
;;;940      /* Select the Output Compare Mode */
;;;941      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000024  880d              LDRH     r5,[r1,#0]
000026  f64f76ff          MOV      r6,#0xffff
00002a  ea062505          AND      r5,r6,r5,LSL #8
00002e  432a              ORRS     r2,r2,r5
;;;942      
;;;943      /* Reset the Output Polarity level */
;;;944      tmpccer &= (uint16_t)~TIM_CCER_CC4P;
000030  f64d75ff          MOV      r5,#0xdfff
000034  402b              ANDS     r3,r3,r5
;;;945      /* Set the Output Compare Polarity */
;;;946      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000036  898d              LDRH     r5,[r1,#0xc]
000038  ea063505          AND      r5,r6,r5,LSL #12
00003c  432b              ORRS     r3,r3,r5
;;;947      
;;;948      /* Set the Output State */
;;;949      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
00003e  884d              LDRH     r5,[r1,#2]
000040  ea063505          AND      r5,r6,r5,LSL #12
000044  432b              ORRS     r3,r3,r5
;;;950      
;;;951      if((TIMx == TIM1) || (TIMx == TIM8))
000046  4d0a              LDR      r5,|L61.112|
000048  42a8              CMP      r0,r5
00004a  d002              BEQ      |L61.82|
00004c  4d09              LDR      r5,|L61.116|
00004e  42a8              CMP      r0,r5
000050  d108              BNE      |L61.100|
                  |L61.82|
;;;952      {
;;;953        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;954        /* Reset the Output Compare IDLE State */
;;;955        tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
000052  f64b75ff          MOV      r5,#0xbfff
000056  402c              ANDS     r4,r4,r5
;;;956        /* Set the Output Idle state */
;;;957        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000058  8a0d              LDRH     r5,[r1,#0x10]
00005a  f64f76ff          MOV      r6,#0xffff
00005e  ea061585          AND      r5,r6,r5,LSL #6
000062  432c              ORRS     r4,r4,r5
                  |L61.100|
;;;958      }
;;;959      /* Write to TIMx CR2 */
;;;960      TIMx->CR2 = tmpcr2;
000064  8084              STRH     r4,[r0,#4]
;;;961      
;;;962      /* Write to TIMx CCMR2 */  
;;;963      TIMx->CCMR2 = tmpccmrx;
000066  8382              STRH     r2,[r0,#0x1c]
;;;964        
;;;965      /* Set the Capture Compare Register value */
;;;966      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000068  688d              LDR      r5,[r1,#8]
00006a  6405              STR      r5,[r0,#0x40]
;;;967      
;;;968      /* Write to TIMx CCER */
;;;969      TIMx->CCER = tmpccer;
00006c  8403              STRH     r3,[r0,#0x20]
;;;970    }
00006e  bd70              POP      {r4-r6,pc}
;;;971    
                          ENDP

                  |L61.112|
                          DCD      0x40010000
                  |L61.116|
                          DCD      0x40010400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1754     */
;;;1755   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1756   {
;;;1757     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1758   
;;;1759     /* Check the parameters */
;;;1760     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1761     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1762   
;;;1763     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1764   
;;;1765     /* Set or Reset the CC4P Bit */
;;;1766     tmpccer &= (uint16_t)~TIM_CCER_CC4P;
000006  f64d73ff          MOV      r3,#0xdfff
00000a  4019              ANDS     r1,r1,r3
;;;1767     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea033302          AND      r3,r3,r2,LSL #12
000014  4319              ORRS     r1,r1,r3
;;;1768   
;;;1769     /* Write to TIMx CCER register */
;;;1770     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1771   }
000018  4770              BX       lr
;;;1772   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1325     */
;;;1326   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1327   {
;;;1328     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1329   
;;;1330     /* Check the parameters */
;;;1331     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1332     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1333   
;;;1334     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1335   
;;;1336     /* Reset the OC4PE Bit */
;;;1337     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1338   
;;;1339     /* Enable or Disable the Output Compare Preload feature */
;;;1340     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1341   
;;;1342     /* Write to TIMx CCMR2 register */
;;;1343     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1344   }
000018  4770              BX       lr
;;;1345   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;977      */
;;;978    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;979    {
;;;980      /* Set the default configuration */
;;;981      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;982      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;983      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;984      TIM_OCInitStruct->TIM_Pulse = 0x00000000;
000008  6081              STR      r1,[r0,#8]
;;;985      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8181              STRH     r1,[r0,#0xc]
;;;986      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  81c1              STRH     r1,[r0,#0xe]
;;;987      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8201              STRH     r1,[r0,#0x10]
;;;988      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  8241              STRH     r1,[r0,#0x12]
;;;989    }
000012  4770              BX       lr
;;;990    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;1974     */
;;;1975   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1976   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1977     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000008  2600              MOVS     r6,#0
;;;1978     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
00000a  2701              MOVS     r7,#1
;;;1979   
;;;1980     /* Check the parameters */
;;;1981     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1982   
;;;1983     /* Select the Opposite Input Polarity */
;;;1984     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000c  8860              LDRH     r0,[r4,#2]
00000e  b908              CBNZ     r0,|L65.20|
;;;1985     {
;;;1986       icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
000012  e000              B        |L65.22|
                  |L65.20|
;;;1987     }
;;;1988     else
;;;1989     {
;;;1990       icoppositepolarity = TIM_ICPolarity_Rising;
000014  2600              MOVS     r6,#0
                  |L65.22|
;;;1991     }
;;;1992     /* Select the Opposite Input */
;;;1993     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000016  88a0              LDRH     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L65.32|
;;;1994     {
;;;1995       icoppositeselection = TIM_ICSelection_IndirectTI;
00001c  2702              MOVS     r7,#2
00001e  e000              B        |L65.34|
                  |L65.32|
;;;1996     }
;;;1997     else
;;;1998     {
;;;1999       icoppositeselection = TIM_ICSelection_DirectTI;
000020  2701              MOVS     r7,#1
                  |L65.34|
;;;2000     }
;;;2001     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000022  8820              LDRH     r0,[r4,#0]
000024  b9a0              CBNZ     r0,|L65.80|
;;;2002     {
;;;2003       /* TI1 Configuration */
;;;2004       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI1_Config
;;;2005                  TIM_ICInitStruct->TIM_ICFilter);
;;;2006       /* Set the Input Capture Prescaler value */
;;;2007       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC1Prescaler
;;;2008       /* TI2 Configuration */
;;;2009       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00003a  8923              LDRH     r3,[r4,#8]
00003c  463a              MOV      r2,r7
00003e  4631              MOV      r1,r6
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       TI2_Config
;;;2010       /* Set the Input Capture Prescaler value */
;;;2011       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000046  88e1              LDRH     r1,[r4,#6]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TIM_SetIC2Prescaler
00004e  e013              B        |L65.120|
                  |L65.80|
;;;2012     }
;;;2013     else
;;;2014     { 
;;;2015       /* TI2 Configuration */
;;;2016       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000050  8923              LDRH     r3,[r4,#8]
000052  88a2              LDRH     r2,[r4,#4]
000054  8861              LDRH     r1,[r4,#2]
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       TI2_Config
;;;2017                  TIM_ICInitStruct->TIM_ICFilter);
;;;2018       /* Set the Input Capture Prescaler value */
;;;2019       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005c  88e1              LDRH     r1,[r4,#6]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TIM_SetIC2Prescaler
;;;2020       /* TI1 Configuration */
;;;2021       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000064  8923              LDRH     r3,[r4,#8]
000066  463a              MOV      r2,r7
000068  4631              MOV      r1,r6
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       TI1_Config
;;;2022       /* Set the Input Capture Prescaler value */
;;;2023       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000070  88e1              LDRH     r1,[r4,#6]
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L65.120|
;;;2024     }
;;;2025   }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;2026   
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;359      */
;;;360    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;361    {
;;;362      /* Check the parameters */
;;;363      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;364      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;365      /* Set the Prescaler value */
;;;366      TIMx->PSC = Prescaler;
;;;367      /* Set or reset the UG Bit */
;;;368      TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;369    }
000004  4770              BX       lr
;;;370    
                          ENDP


                          AREA ||i.TIM_RemapConfig||, CODE, READONLY, ALIGN=1

                  TIM_RemapConfig PROC
;;;3172     */
;;;3173   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
000000  f8a01050          STRH     r1,[r0,#0x50]
;;;3174   {
;;;3175    /* Check the parameters */
;;;3176     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;3177     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;3178   
;;;3179     /* Set the Timer remapping configuration */
;;;3180     TIMx->OR =  TIM_Remap;
;;;3181   }
000004  4770              BX       lr
;;;3182   /**
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;2643     */
;;;2644   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L68.12|
;;;2645   {
;;;2646     /* Check the parameters */
;;;2647     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2648     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2649   
;;;2650     if (NewState != DISABLE)
;;;2651     {
;;;2652       /* Set the CCDS Bit */
;;;2653       TIMx->CR2 |= TIM_CR2_CCDS;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420208          ORR      r2,r2,#8
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L68.22|
                  |L68.12|
;;;2654     }
;;;2655     else
;;;2656     {
;;;2657       /* Reset the CCDS Bit */
;;;2658       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L68.22|
;;;2659     }
;;;2660   }
000016  4770              BX       lr
;;;2661   /**
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;2289     */
;;;2290   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L69.12|
;;;2291   {
;;;2292     /* Check the parameters */
;;;2293     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2294     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2295   
;;;2296     if (NewState != DISABLE)
;;;2297     {
;;;2298       /* Set the COM Bit */
;;;2299       TIMx->CR2 |= TIM_CR2_CCUS;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420204          ORR      r2,r2,#4
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L69.22|
                  |L69.12|
;;;2300     }
;;;2301     else
;;;2302     {
;;;2303       /* Reset the COM Bit */
;;;2304       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L69.22|
;;;2305     }
;;;2306   }
000016  4770              BX       lr
;;;2307   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;3121     */
;;;3122   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L70.12|
;;;3123   {
;;;3124     /* Check the parameters */
;;;3125     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3126     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3127   
;;;3128     if (NewState != DISABLE)
;;;3129     {
;;;3130       /* Set the TI1S Bit */
;;;3131       TIMx->CR2 |= TIM_CR2_TI1S;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420280          ORR      r2,r2,#0x80
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L70.22|
                  |L70.12|
;;;3132     }
;;;3133     else
;;;3134     {
;;;3135       /* Reset the TI1S Bit */
;;;3136       TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L70.22|
;;;3137     }
;;;3138   }
000016  4770              BX       lr
;;;3139   /**
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;2891     */
;;;2892   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  460a              MOV      r2,r1
;;;2893   {
;;;2894     uint16_t tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;2895   
;;;2896     /* Check the parameters */
;;;2897     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;2898     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2899   
;;;2900     /* Get the TIMx SMCR register value */
;;;2901     tmpsmcr = TIMx->SMCR;
000004  8901              LDRH     r1,[r0,#8]
;;;2902   
;;;2903     /* Reset the TS Bits */
;;;2904     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;2905   
;;;2906     /* Set the Input Trigger source */
;;;2907     tmpsmcr |= TIM_InputTriggerSource;
00000c  4311              ORRS     r1,r1,r2
;;;2908   
;;;2909     /* Write to TIMx SMCR */
;;;2910     TIMx->SMCR = tmpsmcr;
00000e  8101              STRH     r1,[r0,#8]
;;;2911   }
000010  4770              BX       lr
;;;2912   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2981     */
;;;2982   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2983   {
;;;2984     /* Check the parameters */
;;;2985     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2986     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2987   
;;;2988     /* Reset the MSM Bit */
;;;2989     TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
000002  f64f737f          MOV      r3,#0xff7f
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2990     
;;;2991     /* Set or Reset the MSM Bit */
;;;2992     TIMx->SMCR |= TIM_MasterSlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2993   }
000010  4770              BX       lr
;;;2994   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;1013     */
;;;1014   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b570              PUSH     {r4-r6,lr}
;;;1015   {
000002  4603              MOV      r3,r0
;;;1016     uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;1017     uint16_t tmp1 = 0;
000006  2400              MOVS     r4,#0
;;;1018   
;;;1019     /* Check the parameters */
;;;1020     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1021     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1022     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1023   
;;;1024     tmp = (uint32_t) TIMx;
000008  4618              MOV      r0,r3
;;;1025     tmp += CCMR_OFFSET;
00000a  3018              ADDS     r0,r0,#0x18
;;;1026   
;;;1027     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
00000c  2501              MOVS     r5,#1
00000e  408d              LSLS     r5,r5,r1
000010  b2ac              UXTH     r4,r5
;;;1028   
;;;1029     /* Disable the Channel: Reset the CCxE Bit */
;;;1030     TIMx->CCER &= (uint16_t) ~tmp1;
000012  8c1d              LDRH     r5,[r3,#0x20]
000014  43a5              BICS     r5,r5,r4
000016  841d              STRH     r5,[r3,#0x20]
;;;1031   
;;;1032     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000018  b109              CBZ      r1,|L73.30|
00001a  2908              CMP      r1,#8
00001c  d10a              BNE      |L73.52|
                  |L73.30|
;;;1033     {
;;;1034       tmp += (TIM_Channel>>1);
00001e  eb000061          ADD      r0,r0,r1,ASR #1
;;;1035   
;;;1036       /* Reset the OCxM bits in the CCMRx register */
;;;1037       *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
000022  6805              LDR      r5,[r0,#0]
000024  f64f768f          MOV      r6,#0xff8f
000028  4035              ANDS     r5,r5,r6
00002a  6005              STR      r5,[r0,#0]
;;;1038      
;;;1039       /* Configure the OCxM bits in the CCMRx register */
;;;1040       *(__IO uint32_t *) tmp |= TIM_OCMode;
00002c  6805              LDR      r5,[r0,#0]
00002e  4315              ORRS     r5,r5,r2
000030  6005              STR      r5,[r0,#0]
000032  e00f              B        |L73.84|
                  |L73.52|
;;;1041     }
;;;1042     else
;;;1043     {
;;;1044       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000034  1f0d              SUBS     r5,r1,#4
000036  f3c5054e          UBFX     r5,r5,#1,#15
00003a  4428              ADD      r0,r0,r5
;;;1045   
;;;1046       /* Reset the OCxM bits in the CCMRx register */
;;;1047       *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
00003c  6805              LDR      r5,[r0,#0]
00003e  f64876ff          MOV      r6,#0x8fff
000042  4035              ANDS     r5,r5,r6
000044  6005              STR      r5,[r0,#0]
;;;1048       
;;;1049       /* Configure the OCxM bits in the CCMRx register */
;;;1050       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000046  6805              LDR      r5,[r0,#0]
000048  f64f76ff          MOV      r6,#0xffff
00004c  ea062602          AND      r6,r6,r2,LSL #8
000050  4335              ORRS     r5,r5,r6
000052  6005              STR      r5,[r0,#0]
                  |L73.84|
;;;1051     }
;;;1052   }
000054  bd70              POP      {r4-r6,pc}
;;;1053   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;548      */
;;;549    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;550    {
;;;551      /* Check the parameters */
;;;552      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;553      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;554    
;;;555      /* Reset the OPM Bit */
;;;556      TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
000002  f64f73f7          MOV      r3,#0xfff7
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;557    
;;;558      /* Configure the OPM Mode */
;;;559      TIMx->CR1 |= TIM_OPMode;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;560    }
000010  4770              BX       lr
;;;561    
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2934     */
;;;2935   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2936   {
;;;2937     /* Check the parameters */
;;;2938     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2939     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2940   
;;;2941     /* Reset the MMS Bits */
;;;2942     TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
000002  f64f738f          MOV      r3,#0xff8f
000006  401a              ANDS     r2,r2,r3
000008  8082              STRH     r2,[r0,#4]
;;;2943     /* Select the TRGO source */
;;;2944     TIMx->CR2 |=  TIM_TRGOSource;
00000a  8882              LDRH     r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  8082              STRH     r2,[r0,#4]
;;;2945   }
000010  4770              BX       lr
;;;2946   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2958     */
;;;2959   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2960   {
;;;2961     /* Check the parameters */
;;;2962     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2963     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2964   
;;;2965     /* Reset the SMS Bits */
;;;2966     TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
000002  f64f73f8          MOV      r3,#0xfff8
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2967   
;;;2968     /* Select the Slave Mode */
;;;2969     TIMx->SMCR |= TIM_SlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2970   }
000010  4770              BX       lr
;;;2971   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;423      */
;;;424    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000000  62c1              STR      r1,[r0,#0x2c]
;;;425    {
;;;426      /* Check the parameters */
;;;427      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;428      
;;;429      /* Set the Autoreload Register value */
;;;430      TIMx->ARR = Autoreload;
;;;431    }
000002  4770              BX       lr
;;;432    
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;571      */
;;;572    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;573    {
;;;574      /* Check the parameters */
;;;575      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;576      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;577    
;;;578      /* Reset the CKD Bits */
;;;579      TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
000002  f64f43ff          MOV      r3,#0xfcff
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;580    
;;;581      /* Set the CKD value */
;;;582      TIMx->CR1 |= TIM_CKD;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;583    }
000010  4770              BX       lr
;;;584    
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;1059     */
;;;1060   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000000  6341              STR      r1,[r0,#0x34]
;;;1061   {
;;;1062     /* Check the parameters */
;;;1063     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1064   
;;;1065     /* Set the Capture Compare1 Register value */
;;;1066     TIMx->CCR1 = Compare1;
;;;1067   }
000002  4770              BX       lr
;;;1068   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;1075     */
;;;1076   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
000000  6381              STR      r1,[r0,#0x38]
;;;1077   {
;;;1078     /* Check the parameters */
;;;1079     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1080   
;;;1081     /* Set the Capture Compare2 Register value */
;;;1082     TIMx->CCR2 = Compare2;
;;;1083   }
000002  4770              BX       lr
;;;1084   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;1090     */
;;;1091   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
000000  63c1              STR      r1,[r0,#0x3c]
;;;1092   {
;;;1093     /* Check the parameters */
;;;1094     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1095   
;;;1096     /* Set the Capture Compare3 Register value */
;;;1097     TIMx->CCR3 = Compare3;
;;;1098   }
000002  4770              BX       lr
;;;1099   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;1105     */
;;;1106   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
000000  6401              STR      r1,[r0,#0x40]
;;;1107   {
;;;1108     /* Check the parameters */
;;;1109     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1110   
;;;1111     /* Set the Capture Compare4 Register value */
;;;1112     TIMx->CCR4 = Compare4;
;;;1113   }
000002  4770              BX       lr
;;;1114   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;408      */
;;;409    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000000  6241              STR      r1,[r0,#0x24]
;;;410    {
;;;411      /* Check the parameters */
;;;412       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;413    
;;;414      /* Set the Counter Register value */
;;;415      TIMx->CNT = Counter;
;;;416    }
000002  4770              BX       lr
;;;417    
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2094     */
;;;2095   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2096   {
;;;2097     /* Check the parameters */
;;;2098     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2099     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2100   
;;;2101     /* Reset the IC1PSC Bits */
;;;2102     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2103   
;;;2104     /* Set the IC1PSC value */
;;;2105     TIMx->CCMR1 |= TIM_ICPSC;
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  430a              ORRS     r2,r2,r1
00000e  8302              STRH     r2,[r0,#0x18]
;;;2106   }
000010  4770              BX       lr
;;;2107   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2119     */
;;;2120   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2121   {
;;;2122     /* Check the parameters */
;;;2123     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2124     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2125   
;;;2126     /* Reset the IC2PSC Bits */
;;;2127     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2128   
;;;2129     /* Set the IC2PSC value */
;;;2130     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8302              STRH     r2,[r0,#0x18]
;;;2131   }
000018  4770              BX       lr
;;;2132   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2143     */
;;;2144   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2145   {
;;;2146     /* Check the parameters */
;;;2147     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2148     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2149   
;;;2150     /* Reset the IC3PSC Bits */
;;;2151     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2152   
;;;2153     /* Set the IC3PSC value */
;;;2154     TIMx->CCMR2 |= TIM_ICPSC;
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  430a              ORRS     r2,r2,r1
00000e  8382              STRH     r2,[r0,#0x1c]
;;;2155   }
000010  4770              BX       lr
;;;2156   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2167     */
;;;2168   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2169   {  
;;;2170     /* Check the parameters */
;;;2171     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2172     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2173   
;;;2174     /* Reset the IC4PSC Bits */
;;;2175     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2176   
;;;2177     /* Set the IC4PSC value */
;;;2178     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8382              STRH     r2,[r0,#0x1c]
;;;2179   }
000018  4770              BX       lr
;;;2180   /**
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;2733     */
;;;2734   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2735                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2736   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2737     /* Check the parameters */
;;;2738     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2739     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2740     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2741   
;;;2742     /* Configure the Timer Input Clock Source */
;;;2743     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00000c  2d60              CMP      r5,#0x60
00000e  d106              BNE      |L88.30|
;;;2744     {
;;;2745       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000010  463b              MOV      r3,r7
000012  2201              MOVS     r2,#1
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TI2_Config
00001c  e005              B        |L88.42|
                  |L88.30|
;;;2746     }
;;;2747     else
;;;2748     {
;;;2749       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00001e  463b              MOV      r3,r7
000020  2201              MOVS     r2,#1
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TI1_Config
                  |L88.42|
;;;2750     }
;;;2751     /* Select the Trigger source */
;;;2752     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TIM_SelectInputTrigger
;;;2753     /* Select the External clock mode1 */
;;;2754     TIMx->SMCR |= TIM_SlaveMode_External1;
000032  8920              LDRH     r0,[r4,#8]
000034  f0400007          ORR      r0,r0,#7
000038  8120              STRH     r0,[r4,#8]
;;;2755   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;2756   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;287      */
;;;288    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  2200              MOVS     r2,#0
;;;289    {
;;;290      uint16_t tmpcr1 = 0;
;;;291    
;;;292      /* Check the parameters */
;;;293      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;294      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;295      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;296    
;;;297      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;298    
;;;299      if((TIMx == TIM1) || (TIMx == TIM8)||
000004  4b18              LDR      r3,|L89.104|
000006  4298              CMP      r0,r3
000008  d00e              BEQ      |L89.40|
00000a  4b18              LDR      r3,|L89.108|
00000c  4298              CMP      r0,r3
00000e  d00b              BEQ      |L89.40|
;;;300         (TIMx == TIM2) || (TIMx == TIM3)||
000010  f1b04f80          CMP      r0,#0x40000000
000014  d008              BEQ      |L89.40|
000016  4b16              LDR      r3,|L89.112|
000018  4298              CMP      r0,r3
00001a  d005              BEQ      |L89.40|
;;;301         (TIMx == TIM4) || (TIMx == TIM5)) 
00001c  4b15              LDR      r3,|L89.116|
00001e  4298              CMP      r0,r3
000020  d002              BEQ      |L89.40|
000022  4b15              LDR      r3,|L89.120|
000024  4298              CMP      r0,r3
000026  d104              BNE      |L89.50|
                  |L89.40|
;;;302      {
;;;303        /* Select the Counter Mode */
;;;304        tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
000028  f64f738f          MOV      r3,#0xff8f
00002c  401a              ANDS     r2,r2,r3
;;;305        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00002e  884b              LDRH     r3,[r1,#2]
000030  431a              ORRS     r2,r2,r3
                  |L89.50|
;;;306      }
;;;307     
;;;308      if((TIMx != TIM6) && (TIMx != TIM7))
000032  4b12              LDR      r3,|L89.124|
000034  4298              CMP      r0,r3
000036  d007              BEQ      |L89.72|
000038  4b11              LDR      r3,|L89.128|
00003a  4298              CMP      r0,r3
00003c  d004              BEQ      |L89.72|
;;;309      {
;;;310        /* Set the clock division */
;;;311        tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
00003e  f64f43ff          MOV      r3,#0xfcff
000042  401a              ANDS     r2,r2,r3
;;;312        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
000044  890b              LDRH     r3,[r1,#8]
000046  431a              ORRS     r2,r2,r3
                  |L89.72|
;;;313      }
;;;314    
;;;315      TIMx->CR1 = tmpcr1;
000048  8002              STRH     r2,[r0,#0]
;;;316    
;;;317      /* Set the Autoreload value */
;;;318      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
00004a  684b              LDR      r3,[r1,#4]
00004c  62c3              STR      r3,[r0,#0x2c]
;;;319     
;;;320      /* Set the Prescaler value */
;;;321      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
00004e  880b              LDRH     r3,[r1,#0]
000050  8503              STRH     r3,[r0,#0x28]
;;;322        
;;;323      if ((TIMx == TIM1) || (TIMx == TIM8))  
000052  4b05              LDR      r3,|L89.104|
000054  4298              CMP      r0,r3
000056  d002              BEQ      |L89.94|
000058  4b04              LDR      r3,|L89.108|
00005a  4298              CMP      r0,r3
00005c  d101              BNE      |L89.98|
                  |L89.94|
;;;324      {
;;;325        /* Set the Repetition Counter value */
;;;326        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
00005e  7a8b              LDRB     r3,[r1,#0xa]
000060  8603              STRH     r3,[r0,#0x30]
                  |L89.98|
;;;327      }
;;;328    
;;;329      /* Generate an update event to reload the Prescaler 
;;;330         and the repetition counter(only for TIM1 and TIM8) value immediately */
;;;331      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
000062  2301              MOVS     r3,#1
000064  8283              STRH     r3,[r0,#0x14]
;;;332    }
000066  4770              BX       lr
;;;333    
                          ENDP

                  |L89.104|
                          DCD      0x40010000
                  |L89.108|
                          DCD      0x40010400
                  |L89.112|
                          DCD      0x40000400
                  |L89.116|
                          DCD      0x40000800
                  |L89.120|
                          DCD      0x40000c00
                  |L89.124|
                          DCD      0x40001000
                  |L89.128|
                          DCD      0x40001400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;339      */
;;;340    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;341    {
;;;342      /* Set the default configuration */
;;;343      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
000004  6041              STR      r1,[r0,#4]
;;;344      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;345      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  8101              STRH     r1,[r0,#8]
;;;346      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;347      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7281              STRB     r1,[r0,#0xa]
;;;348    }
000010  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;467      */
;;;468    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L91.12|
;;;469    {
;;;470      /* Check the parameters */
;;;471      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;472      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;473    
;;;474      if (NewState != DISABLE)
;;;475      {
;;;476        /* Set the Update Disable Bit */
;;;477        TIMx->CR1 |= TIM_CR1_UDIS;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L91.22|
                  |L91.12|
;;;478      }
;;;479      else
;;;480      {
;;;481        /* Reset the Update Disable Bit */
;;;482        TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L91.22|
;;;483      }
;;;484    }
000016  4770              BX       lr
;;;485    
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;496      */
;;;497    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  b121              CBZ      r1,|L92.12|
;;;498    {
;;;499      /* Check the parameters */
;;;500      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;501      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;502    
;;;503      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;504      {
;;;505        /* Set the URS Bit */
;;;506        TIMx->CR1 |= TIM_CR1_URS;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420204          ORR      r2,r2,#4
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L92.22|
                  |L92.12|
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Reset the URS Bit */
;;;511        TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L92.22|
;;;512      }
;;;513    }
000016  4770              BX       lr
;;;514    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___15_stm32f4xx_tim_c_c458916b____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REVSH|
#line 153
|__asm___15_stm32f4xx_tim_c_c458916b____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____RRX|
#line 328
|__asm___15_stm32f4xx_tim_c_c458916b____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
