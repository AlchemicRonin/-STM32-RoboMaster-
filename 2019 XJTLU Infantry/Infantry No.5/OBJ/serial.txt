; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\serial.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\serial.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\serial.crf ..\BSP\serial.c]
                          THUMB

                          AREA ||i.DMA2_Stream1_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA2_Stream1_IRQHandler PROC
;;;120    
;;;121    void DMA2_Stream1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123    	if(DMA_GetFlagStatus(DMA2_Stream1,DMA_FLAG_TCIF1)!=RESET)
000002  490f              LDR      r1,|L1.64|
000004  480f              LDR      r0,|L1.68|
000006  f7fffffe          BL       DMA_GetFlagStatus
00000a  b1c0              CBZ      r0,|L1.62|
;;;124    	{
;;;125    		DMA_Cmd(DMA2_Stream1, DISABLE); //关闭DMA,防止处理其间有数据		
00000c  2100              MOVS     r1,#0
00000e  480d              LDR      r0,|L1.68|
000010  f7fffffe          BL       DMA_Cmd
;;;126    		DMA_ClearFlag(DMA2_Stream1,DMA_FLAG_TCIF1 | DMA_FLAG_FEIF1 | DMA_FLAG_DMEIF1 | DMA_FLAG_TEIF1 | DMA_FLAG_HTIF1);//清除DMA2_Steam7传输完成标志
000014  490c              LDR      r1,|L1.72|
000016  480b              LDR      r0,|L1.68|
000018  f7fffffe          BL       DMA_ClearFlag
;;;127    		DMA_ClearITPendingBit(DMA2_Stream1, DMA_IT_TCIF1);		
00001c  490b              LDR      r1,|L1.76|
00001e  4809              LDR      r0,|L1.68|
000020  f7fffffe          BL       DMA_ClearITPendingBit
;;;128    		memcpy(SEE_rx_data,SEE_RXBuff,18);
000024  2212              MOVS     r2,#0x12
000026  490a              LDR      r1,|L1.80|
000028  480a              LDR      r0,|L1.84|
00002a  f7fffffe          BL       __aeabi_memcpy
;;;129    		getVisionData(SEE_rx_data,&enemy_position);
00002e  490a              LDR      r1,|L1.88|
000030  4808              LDR      r0,|L1.84|
000032  f7fffffe          BL       getVisionData
;;;130    		DMA_Cmd(DMA2_Stream1, ENABLE); 
000036  2101              MOVS     r1,#1
000038  4802              LDR      r0,|L1.68|
00003a  f7fffffe          BL       DMA_Cmd
                  |L1.62|
;;;131    	}
;;;132    }
00003e  bd10              POP      {r4,pc}
;;;133    
                          ENDP

                  |L1.64|
                          DCD      0x10000800
                  |L1.68|
                          DCD      0x40026428
                  |L1.72|
                          DCD      0x10000f40
                  |L1.76|
                          DCD      0x10008800
                  |L1.80|
                          DCD      SEE_RXBuff
                  |L1.84|
                          DCD      SEE_rx_data
                  |L1.88|
                          DCD      enemy_position

                          AREA ||i.getVisionData||, CODE, READONLY, ALIGN=2

                  getVisionData PROC
;;;149    u8 vision_flag = 0;
;;;150    void getVisionData(u8* data,VisionData* enemy_position)
000000  b570              PUSH     {r4-r6,lr}
;;;151    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;152    //	usart_see++;
;;;153    	if(data[0] == 0xA5 && Verify_CRC16_Check_Sum(data,18)) 
000006  7828              LDRB     r0,[r5,#0]
000008  28a5              CMP      r0,#0xa5
00000a  d153              BNE      |L2.180|
00000c  2112              MOVS     r1,#0x12
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       Verify_CRC16_Check_Sum
000014  2800              CMP      r0,#0
000016  d04d              BEQ      |L2.180|
;;;154    	{
;;;155    		enemy_position->mode = data[1];
000018  7868              LDRB     r0,[r5,#1]
00001a  7020              STRB     r0,[r4,#0]
;;;156    		
;;;157    		enemy_position->SEE_pitch_angle.c[0] = data[2];
00001c  78a8              LDRB     r0,[r5,#2]
00001e  7120              STRB     r0,[r4,#4]
;;;158    		enemy_position->SEE_pitch_angle.c[1] = data[3];
000020  78e9              LDRB     r1,[r5,#3]
000022  7161              STRB     r1,[r4,#5]
;;;159    		
;;;160    		enemy_position->SEE_yaw_angle.c[0] = data[4];
000024  7928              LDRB     r0,[r5,#4]
000026  70a0              STRB     r0,[r4,#2]
;;;161    		enemy_position->SEE_yaw_angle.c[1] = data[5];
000028  7969              LDRB     r1,[r5,#5]
00002a  70e1              STRB     r1,[r4,#3]
;;;162    		
;;;163    		enemy_position->SEE_yaw_speed.c[0] = data[6];
00002c  79a8              LDRB     r0,[r5,#6]
00002e  71a0              STRB     r0,[r4,#6]
;;;164    		enemy_position->SEE_yaw_speed.c[1] = data[7];
000030  79e9              LDRB     r1,[r5,#7]
000032  71e1              STRB     r1,[r4,#7]
;;;165    		
;;;166    		enemy_position->SEE_shoot_speed.c[0] = data[8];
000034  7a28              LDRB     r0,[r5,#8]
000036  7220              STRB     r0,[r4,#8]
;;;167    		enemy_position->SEE_shoot_speed.c[1] = data[9];
000038  7a69              LDRB     r1,[r5,#9]
00003a  7261              STRB     r1,[r4,#9]
;;;168    		enemy_position->SEE_shoot_speed.c[2] = data[10];
00003c  7aa9              LDRB     r1,[r5,#0xa]
00003e  72a1              STRB     r1,[r4,#0xa]
;;;169    		enemy_position->SEE_shoot_speed.c[3] = data[11];
000040  7ae9              LDRB     r1,[r5,#0xb]
000042  72e1              STRB     r1,[r4,#0xb]
;;;170    		
;;;171    		enemy_position->z.c[0] = data[12];
000044  7b28              LDRB     r0,[r5,#0xc]
000046  7620              STRB     r0,[r4,#0x18]
;;;172    		enemy_position->z.c[1] = data[13];
000048  7b69              LDRB     r1,[r5,#0xd]
00004a  7661              STRB     r1,[r4,#0x19]
;;;173    		enemy_position->z.c[2] = data[14];
00004c  7ba9              LDRB     r1,[r5,#0xe]
00004e  76a1              STRB     r1,[r4,#0x1a]
;;;174    		enemy_position->z.c[3] = data[15];
000050  7be9              LDRB     r1,[r5,#0xf]
000052  76e1              STRB     r1,[r4,#0x1b]
;;;175    		
;;;176    
;;;177    		FOA.yaw_offset   = (float)enemy_position->SEE_yaw_angle.d / 10.0f;
000054  f9b40002          LDRSH    r0,[r4,#2]
000058  ee000a10          VMOV     s0,r0
00005c  eeb80ac0          VCVT.F32.S32 s0,s0
000060  eef20a04          VMOV.F32 s1,#10.00000000
000064  ee801a20          VDIV.F32 s2,s0,s1
000068  4813              LDR      r0,|L2.184|
00006a  ed801a00          VSTR     s2,[r0,#0]
;;;178    		FOA.pitch_offset = (float)enemy_position->SEE_pitch_angle.d / 10.0f;
00006e  f9b40004          LDRSH    r0,[r4,#4]
000072  ee000a10          VMOV     s0,r0
000076  eeb80ac0          VCVT.F32.S32 s0,s0
00007a  eef20a04          VMOV.F32 s1,#10.00000000
00007e  ee801a20          VDIV.F32 s2,s0,s1
000082  480d              LDR      r0,|L2.184|
000084  ed801a01          VSTR     s2,[r0,#4]
;;;179    		
;;;180    		
;;;181    		out[VISUAL_YAW_OFFSET] = Calculate_Current_Value_For_Err(&pid[VISUAL_YAW_OFFSET], FOA.yaw_offset);
000088  edd00a00          VLDR     s1,[r0,#0]
00008c  eeb00a60          VMOV.F32 s0,s1
000090  480a              LDR      r0,|L2.188|
000092  f7fffffe          BL       Calculate_Current_Value_For_Err
000096  480a              LDR      r0,|L2.192|
000098  ed800a0c          VSTR     s0,[r0,#0x30]
;;;182    		out[VISUAL_PITCH_OFFSET] = Calculate_Current_Value_For_Err(&pid[VISUAL_PITCH_OFFSET], FOA.pitch_offset);
00009c  4806              LDR      r0,|L2.184|
00009e  edd00a01          VLDR     s1,[r0,#4]
0000a2  eeb00a60          VMOV.F32 s0,s1
0000a6  4805              LDR      r0,|L2.188|
0000a8  304c              ADDS     r0,r0,#0x4c
0000aa  f7fffffe          BL       Calculate_Current_Value_For_Err
0000ae  4804              LDR      r0,|L2.192|
0000b0  ed800a0d          VSTR     s0,[r0,#0x34]
                  |L2.180|
;;;183    
;;;184    	}	
;;;185    	
;;;186    }
0000b4  bd70              POP      {r4-r6,pc}
;;;187    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L2.184|
                          DCD      ||FOA||
                  |L2.188|
                          DCD      pid+0x390
                  |L2.192|
                          DCD      out

                          AREA ||i.miniPC_uart6_init||, CODE, READONLY, ALIGN=2

                  miniPC_uart6_init PROC
;;;29     
;;;30     void miniPC_uart6_init(void)
000000  b500              PUSH     {lr}
;;;31     {
000002  b097              SUB      sp,sp,#0x5c
;;;32       //GPIO端口设置
;;;33     	GPIO_InitTypeDef GPIO_InitStructure;
;;;34     	USART_InitTypeDef USART_InitStructure;
;;;35     	NVIC_InitTypeDef NVIC_InitStructure;		//dma用到中断
;;;36     	DMA_InitTypeDef  DMA_InitStructure;
;;;37     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG,ENABLE); //使能GPIOA时钟
000004  2101              MOVS     r1,#1
000006  2040              MOVS     r0,#0x40
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;38     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, ENABLE);;//使能USART1时钟
00000c  2101              MOVS     r1,#1
00000e  2020              MOVS     r0,#0x20
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;39     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE); //DMA2时钟使能 ---********************
000014  2101              MOVS     r1,#1
000016  0588              LSLS     r0,r1,#22
000018  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;40      
;;;41     	//串口1对应引脚复用映射
;;;42     	GPIO_PinAFConfig(GPIOG, GPIO_PinSource9, GPIO_AF_USART6); //GPIOA9复用为USART1
00001c  2208              MOVS     r2,#8
00001e  2109              MOVS     r1,#9
000020  484d              LDR      r0,|L3.344|
000022  f7fffffe          BL       GPIO_PinAFConfig
;;;43     	GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_USART6); //GPIOA10复用为USART1
000026  2208              MOVS     r2,#8
000028  210e              MOVS     r1,#0xe
00002a  484b              LDR      r0,|L3.344|
00002c  f7fffffe          BL       GPIO_PinAFConfig
;;;44     	
;;;45     	//USART1端口配置
;;;46         GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_9;         
000030  f44f7000          MOV      r0,#0x200
000034  9015              STR      r0,[sp,#0x54]
;;;47         GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;       
000036  2002              MOVS     r0,#2
000038  f88d0058          STRB     r0,[sp,#0x58]
;;;48         GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;  
00003c  2000              MOVS     r0,#0
00003e  f88d005a          STRB     r0,[sp,#0x5a]
;;;49         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;   
000042  2003              MOVS     r0,#3
000044  f88d0059          STRB     r0,[sp,#0x59]
;;;50         GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;       
000048  2001              MOVS     r0,#1
00004a  f88d005b          STRB     r0,[sp,#0x5b]
;;;51         GPIO_Init(GPIOG, &GPIO_InitStructure);  /* TXIO */  
00004e  a915              ADD      r1,sp,#0x54
000050  4841              LDR      r0,|L3.344|
000052  f7fffffe          BL       GPIO_Init
;;;52     
;;;53         GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_14;                
000056  f44f4080          MOV      r0,#0x4000
00005a  9015              STR      r0,[sp,#0x54]
;;;54         GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
00005c  2002              MOVS     r0,#2
00005e  f88d0058          STRB     r0,[sp,#0x58]
;;;55     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;  
000062  2000              MOVS     r0,#0
000064  f88d005a          STRB     r0,[sp,#0x5a]
;;;56         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;   
000068  2003              MOVS     r0,#3
00006a  f88d0059          STRB     r0,[sp,#0x59]
;;;57         GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;       
00006e  2001              MOVS     r0,#1
000070  f88d005b          STRB     r0,[sp,#0x5b]
;;;58         GPIO_Init(GPIOG, &GPIO_InitStructure);  /* RXIO */
000074  a915              ADD      r1,sp,#0x54
000076  4838              LDR      r0,|L3.344|
000078  f7fffffe          BL       GPIO_Init
;;;59     
;;;60       //USART1 初始化设置
;;;61     	USART_DeInit(USART6);
00007c  4837              LDR      r0,|L3.348|
00007e  f7fffffe          BL       USART_DeInit
;;;62     	USART_InitStructure.USART_BaudRate = 115200;//波特率设置
000082  f44f30e1          MOV      r0,#0x1c200
000086  9011              STR      r0,[sp,#0x44]
;;;63     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000088  2000              MOVS     r0,#0
00008a  f8ad0048          STRH     r0,[sp,#0x48]
;;;64     	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
00008e  f8ad004a          STRH     r0,[sp,#0x4a]
;;;65     	USART_InitStructure.USART_Parity = USART_Parity_No;//无校验
000092  f8ad004c          STRH     r0,[sp,#0x4c]
;;;66     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000096  200c              MOVS     r0,#0xc
000098  f8ad004e          STRH     r0,[sp,#0x4e]
;;;67     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
00009c  2000              MOVS     r0,#0
00009e  f8ad0050          STRH     r0,[sp,#0x50]
;;;68     	USART_Init(USART6, &USART_InitStructure); //初始化串口1
0000a2  a911              ADD      r1,sp,#0x44
0000a4  482d              LDR      r0,|L3.348|
0000a6  f7fffffe          BL       USART_Init
;;;69     	
;;;70     	USART_Cmd(USART6, ENABLE);  //使能串口1
0000aa  2101              MOVS     r1,#1
0000ac  482b              LDR      r0,|L3.348|
0000ae  f7fffffe          BL       USART_Cmd
;;;71     	
;;;72     	USART_DMACmd(USART6,USART_DMAReq_Rx,ENABLE);  //使能串口1的DMA接收     
0000b2  2201              MOVS     r2,#1
0000b4  2140              MOVS     r1,#0x40
0000b6  4829              LDR      r0,|L3.348|
0000b8  f7fffffe          BL       USART_DMACmd
;;;73     	
;;;74     	
;;;75     	NVIC_InitStructure.NVIC_IRQChannel = DMA2_Stream1_IRQn;//DMA1 数据流5 中断通道*******
0000bc  2039              MOVS     r0,#0x39
0000be  f88d0040          STRB     r0,[sp,#0x40]
;;;76     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;//抢占优先级3
0000c2  2000              MOVS     r0,#0
0000c4  f88d0041          STRB     r0,[sp,#0x41]
;;;77     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;		//子优先级3
0000c8  2001              MOVS     r0,#1
0000ca  f88d0042          STRB     r0,[sp,#0x42]
;;;78     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
0000ce  f88d0043          STRB     r0,[sp,#0x43]
;;;79     	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
0000d2  a810              ADD      r0,sp,#0x40
0000d4  f7fffffe          BL       NVIC_Init
;;;80     	
;;;81     	
;;;82     	
;;;83       /* 配置 DMA Stream */
;;;84     	DMA_DeInit(DMA2_Stream1); 	
0000d8  4821              LDR      r0,|L3.352|
0000da  f7fffffe          BL       DMA_DeInit
;;;85     	while (DMA_GetCmdStatus(DMA2_Stream1) != DISABLE);//等待DMA可配置
0000de  bf00              NOP      
                  |L3.224|
0000e0  481f              LDR      r0,|L3.352|
0000e2  f7fffffe          BL       DMA_GetCmdStatus
0000e6  2800              CMP      r0,#0
0000e8  d1fa              BNE      |L3.224|
;;;86     	DMA_InitStructure.DMA_Channel = DMA_Channel_5;  //通道选择
0000ea  f04f6020          MOV      r0,#0xa000000
0000ee  9001              STR      r0,[sp,#4]
;;;87     	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&(USART6->DR);//DMA外设地址****************************
0000f0  481a              LDR      r0,|L3.348|
0000f2  1d00              ADDS     r0,r0,#4
0000f4  9002              STR      r0,[sp,#8]
;;;88     	DMA_InitStructure.DMA_Memory0BaseAddr = (u32)SEE_RXBuff;//DMA 存储器0地址 内存地址
0000f6  481b              LDR      r0,|L3.356|
0000f8  9003              STR      r0,[sp,#0xc]
;;;89     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;//外设到存储器模式*******************************
0000fa  2000              MOVS     r0,#0
0000fc  9004              STR      r0,[sp,#0x10]
;;;90     	DMA_InitStructure.DMA_BufferSize = SEE_RX_BUF_SIZE;//数据传输量 
0000fe  2012              MOVS     r0,#0x12
000100  9005              STR      r0,[sp,#0x14]
;;;91     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设非增量模式
000102  2000              MOVS     r0,#0
000104  9006              STR      r0,[sp,#0x18]
;;;92     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//存储器增量模式
000106  f44f6080          MOV      r0,#0x400
00010a  9007              STR      r0,[sp,#0x1c]
;;;93     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//外设数据长度:8位
00010c  2000              MOVS     r0,#0
00010e  9008              STR      r0,[sp,#0x20]
;;;94     	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;//存储器数据长度:8位
000110  9009              STR      r0,[sp,#0x24]
;;;95     	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
000112  900a              STR      r0,[sp,#0x28]
;;;96     	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;//中等优先级**********
000114  f44f3040          MOV      r0,#0x30000
000118  900b              STR      r0,[sp,#0x2c]
;;;97     	DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
00011a  2000              MOVS     r0,#0
00011c  900c              STR      r0,[sp,#0x30]
;;;98     	DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;//***************
00011e  900d              STR      r0,[sp,#0x34]
;;;99     	DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;//存储器突发单次传输*****
000120  900e              STR      r0,[sp,#0x38]
;;;100    	DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;//外设突发单次传输
000122  900f              STR      r0,[sp,#0x3c]
;;;101    
;;;102    	DMA_Init(DMA2_Stream1, &DMA_InitStructure);//初始化DMA2 Stream5	
000124  a901              ADD      r1,sp,#4
000126  480e              LDR      r0,|L3.352|
000128  f7fffffe          BL       DMA_Init
;;;103    	DMA_ITConfig(DMA2_Stream1,DMA_IT_TC,ENABLE);
00012c  2201              MOVS     r2,#1
00012e  2110              MOVS     r1,#0x10
000130  480b              LDR      r0,|L3.352|
000132  f7fffffe          BL       DMA_ITConfig
;;;104    	DMA_Cmd(DMA2_Stream1,ENABLE);
000136  2101              MOVS     r1,#1
000138  4809              LDR      r0,|L3.352|
00013a  f7fffffe          BL       DMA_Cmd
;;;105    	
;;;106    	
;;;107    	//视觉信息初始化防止编译器未定义错误
;;;108    	enemy_position.mode = 0;
00013e  2000              MOVS     r0,#0
000140  4909              LDR      r1,|L3.360|
000142  7008              STRB     r0,[r1,#0]
;;;109    	enemy_position.SEE_pitch_angle.d = 0;
000144  8088              STRH     r0,[r1,#4]
;;;110    	enemy_position.SEE_yaw_angle.d = 0;
000146  8048              STRH     r0,[r1,#2]
;;;111    	enemy_position.SEE_shoot_speed.f = 0;
000148  ed9f0a08          VLDR     s0,|L3.364|
00014c  4608              MOV      r0,r1
00014e  ed800a02          VSTR     s0,[r0,#8]
;;;112    
;;;113    	
;;;114    	
;;;115    }
000152  b017              ADD      sp,sp,#0x5c
000154  bd00              POP      {pc}
;;;116    
                          ENDP

000156  0000              DCW      0x0000
                  |L3.344|
                          DCD      0x40021800
                  |L3.348|
                          DCD      0x40011400
                  |L3.352|
                          DCD      0x40026428
                  |L3.356|
                          DCD      SEE_RXBuff
                  |L3.360|
                          DCD      enemy_position
                  |L3.364|
00016c  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.miniPC_uart6_tx||, CODE, READONLY, ALIGN=2

                  miniPC_uart6_tx PROC
;;;135    
;;;136    void miniPC_uart6_tx(u8 *USART_RX_BUF ,int len)
000000  b570              PUSH     {r4-r6,lr}
;;;137    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;138    			int t;
;;;139    			for(t=0;t<len;t++)
000006  2400              MOVS     r4,#0
000008  e00b              B        |L4.34|
                  |L4.10|
;;;140    			{
;;;141    				USART_SendData(USART6, USART_RX_BUF[t]);         //向串口1发送数据
00000a  5d29              LDRB     r1,[r5,r4]
00000c  4806              LDR      r0,|L4.40|
00000e  f7fffffe          BL       USART_SendData
;;;142    				while(USART_GetFlagStatus(USART6,USART_FLAG_TC)!=SET);//等待发送结束
000012  bf00              NOP      
                  |L4.20|
000014  2140              MOVS     r1,#0x40
000016  4804              LDR      r0,|L4.40|
000018  f7fffffe          BL       USART_GetFlagStatus
00001c  2801              CMP      r0,#1
00001e  d1f9              BNE      |L4.20|
000020  1c64              ADDS     r4,r4,#1              ;139
                  |L4.34|
000022  42b4              CMP      r4,r6                 ;139
000024  dbf1              BLT      |L4.10|
;;;143    			}
;;;144    }
000026  bd70              POP      {r4-r6,pc}
;;;145    int64_t usart_see = 0;
                          ENDP

                  |L4.40|
                          DCD      0x40011400

                          AREA ||i.usart_IIRLowPass||, CODE, READONLY, ALIGN=2

                  usart_IIRLowPass PROC
;;;187    
;;;188    float usart_IIRLowPass(float x)
000000  b510              PUSH     {r4,lr}
;;;189    {
000002  ed2d8b04          VPUSH    {d8-d9}
000006  eeb08a40          VMOV.F32 s16,s0
;;;190    	int i;
;;;191    	//运算之前Buf向前移动一个位置，以保存之前Buf的数据；
;;;192    	for(i = 3; i > 0; i--)
00000a  2403              MOVS     r4,#3
00000c  e016              B        |L5.60|
                  |L5.14|
;;;193    	{
;;;194    		usart_yBuf[i] = usart_yBuf[i-1];
00000e  1e60              SUBS     r0,r4,#1
000010  4957              LDR      r1,|L5.368|
000012  eb0100c0          ADD      r0,r1,r0,LSL #3
000016  ed900b00          VLDR     d0,[r0,#0]
00001a  4608              MOV      r0,r1
00001c  eb0000c4          ADD      r0,r0,r4,LSL #3
000020  ed800b00          VSTR     d0,[r0,#0]
;;;195    		usart_xBuf[i] = usart_xBuf[i-1];
000024  1e60              SUBS     r0,r4,#1
000026  4953              LDR      r1,|L5.372|
000028  eb0100c0          ADD      r0,r1,r0,LSL #3
00002c  ed900b00          VLDR     d0,[r0,#0]
000030  4608              MOV      r0,r1
000032  eb0000c4          ADD      r0,r0,r4,LSL #3
000036  ed800b00          VSTR     d0,[r0,#0]
00003a  1e64              SUBS     r4,r4,#1              ;192
                  |L5.60|
00003c  2c00              CMP      r4,#0                 ;192
00003e  dce6              BGT      |L5.14|
;;;196    	}
;;;197    	usart_xBuf[0] = x;
000040  ee180a10          VMOV     r0,s16
000044  f7fffffe          BL       __aeabi_f2d
000048  4a4a              LDR      r2,|L5.372|
00004a  c203              STM      r2!,{r0,r1}
;;;198    	usart_yBuf[0] = 0;
00004c  ed9f0b4a          VLDR     d0,|L5.376|
000050  4847              LDR      r0,|L5.368|
000052  ed800b00          VSTR     d0,[r0,#0]
;;;199    	for(i = 1;i < 4;i++)
000056  2401              MOVS     r4,#1
000058  e052              B        |L5.256|
                  |L5.90|
;;;200    	{
;;;201    		usart_yBuf[0] = usart_yBuf[0] + b[i]*usart_xBuf[i];
00005a  4846              LDR      r0,|L5.372|
00005c  eb0000c4          ADD      r0,r0,r4,LSL #3
000060  ed902b00          VLDR     d2,[r0,#0]
000064  eeb00a42          VMOV.F32 s0,s4
000068  eef00a62          VMOV.F32 s1,s5
00006c  4844              LDR      r0,|L5.384|
00006e  eb0000c4          ADD      r0,r0,r4,LSL #3
000072  ed902b00          VLDR     d2,[r0,#0]
000076  eeb01a42          VMOV.F32 s2,s4
00007a  eef01a62          VMOV.F32 s3,s5
00007e  ec532b10          VMOV     r2,r3,d0
000082  ec510b11          VMOV     r0,r1,d1
000086  f7fffffe          BL       __aeabi_dmul
00008a  ec410b19          VMOV     d9,r0,r1
00008e  4838              LDR      r0,|L5.368|
000090  ed901b00          VLDR     d1,[r0,#0]
000094  eeb00a41          VMOV.F32 s0,s2
000098  eef00a61          VMOV.F32 s1,s3
00009c  ec532b10          VMOV     r2,r3,d0
0000a0  ec510b19          VMOV     r0,r1,d9
0000a4  f7fffffe          BL       __aeabi_dadd
0000a8  4a31              LDR      r2,|L5.368|
0000aa  c203              STM      r2!,{r0,r1}
;;;202    		usart_yBuf[0] = usart_yBuf[0] - a[i]*usart_yBuf[i];
0000ac  4830              LDR      r0,|L5.368|
0000ae  eb0000c4          ADD      r0,r0,r4,LSL #3
0000b2  ed902b00          VLDR     d2,[r0,#0]
0000b6  eeb00a42          VMOV.F32 s0,s4
0000ba  eef00a62          VMOV.F32 s1,s5
0000be  4831              LDR      r0,|L5.388|
0000c0  eb0000c4          ADD      r0,r0,r4,LSL #3
0000c4  ed902b00          VLDR     d2,[r0,#0]
0000c8  eeb01a42          VMOV.F32 s2,s4
0000cc  eef01a62          VMOV.F32 s3,s5
0000d0  ec532b10          VMOV     r2,r3,d0
0000d4  ec510b11          VMOV     r0,r1,d1
0000d8  f7fffffe          BL       __aeabi_dmul
0000dc  ec410b19          VMOV     d9,r0,r1
0000e0  4823              LDR      r0,|L5.368|
0000e2  ed901b00          VLDR     d1,[r0,#0]
0000e6  eeb00a41          VMOV.F32 s0,s2
0000ea  eef00a61          VMOV.F32 s1,s3
0000ee  ec532b10          VMOV     r2,r3,d0
0000f2  ec510b19          VMOV     r0,r1,d9
0000f6  f7fffffe          BL       __aeabi_drsub
0000fa  4a1d              LDR      r2,|L5.368|
0000fc  c203              STM      r2!,{r0,r1}
0000fe  1c64              ADDS     r4,r4,#1              ;199
                  |L5.256|
000100  2c04              CMP      r4,#4                 ;199
000102  dbaa              BLT      |L5.90|
;;;203    	}
;;;204    	usart_yBuf[0] = usart_yBuf[0] + b[0]*usart_xBuf[0];
000104  481b              LDR      r0,|L5.372|
000106  ed902b00          VLDR     d2,[r0,#0]
00010a  eeb00a42          VMOV.F32 s0,s4
00010e  eef00a62          VMOV.F32 s1,s5
000112  481b              LDR      r0,|L5.384|
000114  ed902b00          VLDR     d2,[r0,#0]
000118  eeb01a42          VMOV.F32 s2,s4
00011c  eef01a62          VMOV.F32 s3,s5
000120  ec532b10          VMOV     r2,r3,d0
000124  ec510b11          VMOV     r0,r1,d1
000128  f7fffffe          BL       __aeabi_dmul
00012c  ec410b19          VMOV     d9,r0,r1
000130  480f              LDR      r0,|L5.368|
000132  ed901b00          VLDR     d1,[r0,#0]
000136  eeb00a41          VMOV.F32 s0,s2
00013a  eef00a61          VMOV.F32 s1,s3
00013e  ec532b10          VMOV     r2,r3,d0
000142  ec510b19          VMOV     r0,r1,d9
000146  f7fffffe          BL       __aeabi_dadd
00014a  4a09              LDR      r2,|L5.368|
00014c  c203              STM      r2!,{r0,r1}
;;;205    	return usart_yBuf[0];
00014e  4808              LDR      r0,|L5.368|
000150  ed901b00          VLDR     d1,[r0,#0]
000154  eeb00a41          VMOV.F32 s0,s2
000158  eef00a61          VMOV.F32 s1,s3
00015c  ec510b10          VMOV     r0,r1,d0
000160  f7fffffe          BL       __aeabi_d2f
000164  ee000a10          VMOV     s0,r0
;;;206    }
000168  ecbd8b04          VPOP     {d8-d9}
00016c  bd10              POP      {r4,pc}
                          ENDP

00016e  0000              DCW      0x0000
                  |L5.368|
                          DCD      usart_yBuf
                  |L5.372|
                          DCD      usart_xBuf
                  |L5.376|
000178  00000000          DCFD     0x0000000000000000 ; 0
00017c  00000000
                  |L5.384|
                          DCD      b
                  |L5.388|
                          DCD      a

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  SEE_RXBuff
                          %        18
                  SEE_rx_data
                          %        18
                  enemy_position
                          %        28
                  usart_xBuf
                          %        32
                  usart_yBuf
                          %        32

                          AREA ||.data||, DATA, ALIGN=3

                  ||FOA||
000000  00000000          DCFS     0x00000000 ; 0
000004  00000000          DCFS     0x00000000 ; 0
                  b
000008  dc374df5          DCFD     0x3ecf8a89dc374df5 ; 3.76e-06
00000c  3ecf8a89
000010  0170ee55          DCFD     0x3ee7a2890170ee55 ; 1.1270000000000001e-05
000014  3ee7a289
000018  0170ee55          DCFD     0x3ee7a2890170ee55 ; 1.1270000000000001e-05
00001c  3ee7a289
000020  dc374df5          DCFD     0x3ecf8a89dc374df5 ; 3.76e-06
000024  3ecf8a89
                  a
000028  00000000          DCFD     0x3ff0000000000000 ; 1
00002c  3ff00000
000030  b6ae7d56          DCFD     0xc0077f62b6ae7d56 ; -2.9371999999999998
000034  c0077f62
000038  930be0df          DCFD     0x400702a9930be0df ; 2.8763000000000001
00003c  400702a9
000040  71758e22          DCFD     0xbfee0d1b71758e22 ; -0.93910000000000005
000044  bfee0d1b
                  mode
000048  0000              DCB      0x00,0x00
                  SEE_yaw_angle
00004a  0000              DCB      0x00,0x00
                  SEE_pitch_angle
00004c  00000000          DCB      0x00,0x00,0x00,0x00
                  z
                          DCD      0x00000000
                          DCD      0x00000000
                  usart_see
000058  00000000          DCQ      0x0000000000000000
00005c  00000000
                  yaw_yaw
000060  0000              DCW      0x0000
                  pitch_pitch
000062  0000              DCW      0x0000
                  vision_flag
000064  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\BSP\\serial.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_serial_c_FOA____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___8_serial_c_FOA____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_serial_c_FOA____REVSH|
#line 153
|__asm___8_serial_c_FOA____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_serial_c_FOA____RRX|
#line 328
|__asm___8_serial_c_FOA____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
