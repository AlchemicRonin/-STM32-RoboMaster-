; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f4xx_i2c.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_i2c.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\stm32f4xx_i2c.crf ..\FWLIB\src\stm32f4xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;717      */
;;;718    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L1.12|
;;;719    {
;;;720      /* Check the parameters */
;;;721      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;722      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;723      if (NewState != DISABLE)
;;;724      {
;;;725        /* Enable the selected I2C ARP */
;;;726        I2Cx->CR1 |= I2C_CR1_ENARP;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420210          ORR      r2,r2,#0x10
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L1.22|
                  |L1.12|
;;;727      }
;;;728      else
;;;729      {
;;;730        /* Disable the selected I2C ARP */
;;;731        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73ef          MOV      r3,#0xffef
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L1.22|
;;;732      }
;;;733    }
000016  4770              BX       lr
;;;734    /**
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;477      */
;;;478    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L2.12|
;;;479    {
;;;480      /* Check the parameters */
;;;481      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;482      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;483      if (NewState != DISABLE)
;;;484      {
;;;485        /* Enable the acknowledgement */
;;;486        I2Cx->CR1 |= I2C_CR1_ACK;
000002  8802              LDRH     r2,[r0,#0]
000004  f4426280          ORR      r2,r2,#0x400
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L2.22|
                  |L2.12|
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Disable the acknowledgement */
;;;491        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f33ff          MOV      r3,#0xfbff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L2.22|
;;;492      }
;;;493    }
000016  4770              BX       lr
;;;494    
                          ENDP


                          AREA ||i.I2C_AnalogFilterCmd||, CODE, READONLY, ALIGN=1

                  I2C_AnalogFilterCmd PROC
;;;341      */
;;;342    void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b129              CBZ      r1,|L3.14|
;;;343    {
;;;344      /* Check the parameters */
;;;345      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;346      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;347      if (NewState != DISABLE)
;;;348      {
;;;349        /* Enable the analog filter */
;;;350        I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
000002  8c82              LDRH     r2,[r0,#0x24]
000004  f64f73ef          MOV      r3,#0xffef
000008  401a              ANDS     r2,r2,r3
00000a  8482              STRH     r2,[r0,#0x24]
00000c  e003              B        |L3.22|
                  |L3.14|
;;;351      }
;;;352      else
;;;353      {
;;;354        /* Disable the analog filter */
;;;355        I2Cx->FLTR |= I2C_FLTR_ANOFF;
00000e  8c82              LDRH     r2,[r0,#0x24]
000010  f0420210          ORR      r2,r2,#0x10
000014  8482              STRH     r2,[r0,#0x24]
                  |L3.22|
;;;356      }
;;;357    }
000016  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;854      */
;;;855    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;856    {
;;;857      /* Check the parameters */
;;;858      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;859      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;860      if (NewState != DISABLE)
;;;861      {
;;;862        /* Enable the selected I2C PEC calculation */
;;;863        I2Cx->CR1 |= I2C_CR1_ENPEC;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420220          ORR      r2,r2,#0x20
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L4.22|
                  |L4.12|
;;;864      }
;;;865      else
;;;866      {
;;;867        /* Disable the selected I2C PEC calculation */
;;;868        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73df          MOV      r3,#0xffdf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L4.22|
;;;869      }
;;;870    }
000016  4770              BX       lr
;;;871    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1157     */
;;;1158   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  b570              PUSH     {r4-r6,lr}
;;;1159   {
000002  4602              MOV      r2,r0
;;;1160     uint32_t lastevent = 0;
000004  2400              MOVS     r4,#0
;;;1161     uint32_t flag1 = 0, flag2 = 0;
000006  2500              MOVS     r5,#0
000008  2300              MOVS     r3,#0
;;;1162     ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;1163   
;;;1164     /* Check the parameters */
;;;1165     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1166     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1167   
;;;1168     /* Read the I2Cx status register */
;;;1169     flag1 = I2Cx->SR1;
00000c  8a95              LDRH     r5,[r2,#0x14]
;;;1170     flag2 = I2Cx->SR2;
00000e  8b13              LDRH     r3,[r2,#0x18]
;;;1171     flag2 = flag2 << 16;
000010  041b              LSLS     r3,r3,#16
;;;1172   
;;;1173     /* Get the last event value from I2C status register */
;;;1174     lastevent = (flag1 | flag2) & FLAG_MASK;
000012  ea450603          ORR      r6,r5,r3
000016  f026447f          BIC      r4,r6,#0xff000000
;;;1175   
;;;1176     /* Check whether the last event contains the I2C_EVENT */
;;;1177     if ((lastevent & I2C_EVENT) == I2C_EVENT)
00001a  ea040601          AND      r6,r4,r1
00001e  428e              CMP      r6,r1
000020  d101              BNE      |L5.38|
;;;1178     {
;;;1179       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1180       status = SUCCESS;
000022  2001              MOVS     r0,#1
000024  e000              B        |L5.40|
                  |L5.38|
;;;1181     }
;;;1182     else
;;;1183     {
;;;1184       /* ERROR: last event is different from I2C_EVENT */
;;;1185       status = ERROR;
000026  2000              MOVS     r0,#0
                  |L5.40|
;;;1186     }
;;;1187     /* Return status */
;;;1188     return status;
;;;1189   }
000028  bd70              POP      {r4-r6,pc}
;;;1190   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1337     */
;;;1338   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  2200              MOVS     r2,#0
;;;1339   {
;;;1340     uint32_t flagpos = 0;
;;;1341     /* Check the parameters */
;;;1342     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1343     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1344     /* Get the I2C flag position */
;;;1345     flagpos = I2C_FLAG & FLAG_MASK;
000002  f021427f          BIC      r2,r1,#0xff000000
;;;1346     /* Clear the selected I2C flag */
;;;1347     I2Cx->SR1 = (uint16_t)~flagpos;
000006  43d3              MVNS     r3,r2
000008  8283              STRH     r3,[r0,#0x14]
;;;1348   }
00000a  4770              BX       lr
;;;1349   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1431     */
;;;1432   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  2200              MOVS     r2,#0
;;;1433   {
;;;1434     uint32_t flagpos = 0;
;;;1435     /* Check the parameters */
;;;1436     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1437     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1438   
;;;1439     /* Get the I2C flag position */
;;;1440     flagpos = I2C_IT & FLAG_MASK;
000002  f021427f          BIC      r2,r1,#0xff000000
;;;1441   
;;;1442     /* Clear the selected I2C flag */
;;;1443     I2Cx->SR1 = (uint16_t)~flagpos;
000006  43d3              MVNS     r3,r2
000008  8283              STRH     r3,[r0,#0x14]
;;;1444   }
00000a  4770              BX       lr
;;;1445   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;312      */
;;;313    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;314    {
;;;315      /* Check the parameters */
;;;316      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;317      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;318      if (NewState != DISABLE)
;;;319      {
;;;320        /* Enable the selected I2C peripheral */
;;;321        I2Cx->CR1 |= I2C_CR1_PE;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;322      }
;;;323      else
;;;324      {
;;;325        /* Disable the selected I2C peripheral */
;;;326        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L8.22|
;;;327      }
;;;328    }
000016  4770              BX       lr
;;;329    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;909      */
;;;910    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L9.12|
;;;911    {
;;;912      /* Check the parameters */
;;;913      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;914      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;915      if (NewState != DISABLE)
;;;916      {
;;;917        /* Enable the selected I2C DMA requests */
;;;918        I2Cx->CR2 |= I2C_CR2_DMAEN;
000002  8882              LDRH     r2,[r0,#4]
000004  f4426200          ORR      r2,r2,#0x800
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L9.22|
                  |L9.12|
;;;919      }
;;;920      else
;;;921      {
;;;922        /* Disable the selected I2C DMA requests */
;;;923        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
00000c  8882              LDRH     r2,[r0,#4]
00000e  f24f73ff          MOV      r3,#0xf7ff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L9.22|
;;;924      }
;;;925    }
000016  4770              BX       lr
;;;926    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;933      */
;;;934    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L10.12|
;;;935    {
;;;936      /* Check the parameters */
;;;937      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;938      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;939      if (NewState != DISABLE)
;;;940      {
;;;941        /* Next DMA transfer is the last transfer */
;;;942        I2Cx->CR2 |= I2C_CR2_LAST;
000002  8882              LDRH     r2,[r0,#4]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L10.22|
                  |L10.12|
;;;943      }
;;;944      else
;;;945      {
;;;946        /* Next DMA transfer is not the last transfer */
;;;947        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L10.22|
;;;948      }
;;;949    }
000016  4770              BX       lr
;;;950    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;136      */
;;;137    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;138    {
000002  4604              MOV      r4,r0
;;;139      /* Check the parameters */
;;;140      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;141    
;;;142      if (I2Cx == I2C1)
000004  4813              LDR      r0,|L11.84|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L11.30|
;;;143      {
;;;144        /* Enable I2C1 reset state */
;;;145        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0548              LSLS     r0,r1,#21
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;146        /* Release I2C1 from reset state */
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
000012  2100              MOVS     r1,#0
000014  f44f1000          MOV      r0,#0x200000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e018              B        |L11.80|
                  |L11.30|
;;;148      }
;;;149      else if (I2Cx == I2C2)
00001e  480e              LDR      r0,|L11.88|
000020  4284              CMP      r4,r0
000022  d109              BNE      |L11.56|
;;;150      {
;;;151        /* Enable I2C2 reset state */
;;;152        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000024  2101              MOVS     r1,#1
000026  0588              LSLS     r0,r1,#22
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;153        /* Release I2C2 from reset state */
;;;154        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
00002c  2100              MOVS     r1,#0
00002e  f44f0080          MOV      r0,#0x400000
000032  f7fffffe          BL       RCC_APB1PeriphResetCmd
000036  e00b              B        |L11.80|
                  |L11.56|
;;;155      }
;;;156      else 
;;;157      {
;;;158        if (I2Cx == I2C3)
000038  4808              LDR      r0,|L11.92|
00003a  4284              CMP      r4,r0
00003c  d108              BNE      |L11.80|
;;;159        {
;;;160          /* Enable I2C3 reset state */
;;;161          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
00003e  2101              MOVS     r1,#1
000040  05c8              LSLS     r0,r1,#23
000042  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;162          /* Release I2C3 from reset state */
;;;163          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
000046  2100              MOVS     r1,#0
000048  f44f0000          MOV      r0,#0x800000
00004c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L11.80|
;;;164        }
;;;165      }
;;;166    }
000050  bd10              POP      {r4,pc}
;;;167    
                          ENDP

000052  0000              DCW      0x0000
                  |L11.84|
                          DCD      0x40005400
                  |L11.88|
                          DCD      0x40005800
                  |L11.92|
                          DCD      0x40005c00

                          AREA ||i.I2C_DigitalFilterConfig||, CODE, READONLY, ALIGN=1

                  I2C_DigitalFilterConfig PROC
;;;370      */
;;;371    void I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter)
000000  460a              MOV      r2,r1
;;;372    {
;;;373      uint16_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;374      
;;;375      /* Check the parameters */
;;;376      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;377      assert_param(IS_I2C_DIGITAL_FILTER(I2C_DigitalFilter));
;;;378      
;;;379      /* Get the old register value */
;;;380      tmpreg = I2Cx->FLTR;
000004  8c81              LDRH     r1,[r0,#0x24]
;;;381      
;;;382      /* Reset I2Cx DNF bit [3:0] */
;;;383      tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
000006  f64f73f0          MOV      r3,#0xfff0
00000a  4019              ANDS     r1,r1,r3
;;;384      
;;;385      /* Set I2Cx DNF coefficient */
;;;386      tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
00000c  f002030f          AND      r3,r2,#0xf
000010  4319              ORRS     r1,r1,r3
;;;387      
;;;388      /* Store the new register value */
;;;389      I2Cx->FLTR = tmpreg;
000012  8481              STRH     r1,[r0,#0x24]
;;;390    }
000014  4770              BX       lr
;;;391    
                          ENDP


                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;527      */
;;;528    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;529    {
;;;530      /* Check the parameters */
;;;531      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;532      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;533      if (NewState != DISABLE)
;;;534      {
;;;535        /* Enable dual addressing mode */
;;;536        I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;537      }
;;;538      else
;;;539      {
;;;540        /* Disable dual addressing mode */
;;;541        I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L13.22|
;;;542      }
;;;543    }
000016  4770              BX       lr
;;;544    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;627      */
;;;628    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;629    {
;;;630      /* Check the parameters */
;;;631      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;632      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;633      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000004  d005              BEQ      |L14.18|
;;;634      {
;;;635        /* I2C fast mode Tlow/Thigh=2 */
;;;636        I2Cx->CCR &= I2C_DutyCycle_2;
000006  8b82              LDRH     r2,[r0,#0x1c]
000008  f64b73ff          MOV      r3,#0xbfff
00000c  401a              ANDS     r2,r2,r3
00000e  8382              STRH     r2,[r0,#0x1c]
000010  e003              B        |L14.26|
                  |L14.18|
;;;637      }
;;;638      else
;;;639      {
;;;640        /* I2C fast mode Tlow/Thigh=16/9 */
;;;641        I2Cx->CCR |= I2C_DutyCycle_16_9;
000012  8b82              LDRH     r2,[r0,#0x1c]
000014  f4424280          ORR      r2,r2,#0x4000
000018  8382              STRH     r2,[r0,#0x1c]
                  |L14.26|
;;;642      }
;;;643    }
00001a  4770              BX       lr
;;;644    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;551      */
;;;552    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L15.12|
;;;553    {
;;;554      /* Check the parameters */
;;;555      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;556      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;557      if (NewState != DISABLE)
;;;558      {
;;;559        /* Enable general call */
;;;560        I2Cx->CR1 |= I2C_CR1_ENGC;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420240          ORR      r2,r2,#0x40
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L15.22|
                  |L15.12|
;;;561      }
;;;562      else
;;;563      {
;;;564        /* Disable general call */
;;;565        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73bf          MOV      r3,#0xffbf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L15.22|
;;;566      }
;;;567    }
000016  4770              BX       lr
;;;568    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;398      */
;;;399    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L16.12|
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;403      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;404      if (NewState != DISABLE)
;;;405      {
;;;406        /* Generate a START condition */
;;;407        I2Cx->CR1 |= I2C_CR1_START;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427280          ORR      r2,r2,#0x100
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L16.22|
                  |L16.12|
;;;408      }
;;;409      else
;;;410      {
;;;411        /* Disable the START condition generation */
;;;412        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f63ff          MOV      r3,#0xfeff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L16.22|
;;;413      }
;;;414    }
000016  4770              BX       lr
;;;415    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;422      */
;;;423    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;424    {
;;;425      /* Check the parameters */
;;;426      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;427      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;428      if (NewState != DISABLE)
;;;429      {
;;;430        /* Generate a STOP condition */
;;;431        I2Cx->CR1 |= I2C_CR1_STOP;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427200          ORR      r2,r2,#0x200
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;432      }
;;;433      else
;;;434      {
;;;435        /* Disable the STOP condition generation */
;;;436        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f53ff          MOV      r3,#0xfdff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L17.22|
;;;437      }
;;;438    }
000016  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1260     */
;;;1261   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b50c              PUSH     {r2,r3,lr}
;;;1262   {
000002  4602              MOV      r2,r0
;;;1263     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1264     __IO uint32_t i2creg = 0, i2cxbase = 0;
000006  2300              MOVS     r3,#0
000008  9301              STR      r3,[sp,#4]
00000a  9300              STR      r3,[sp,#0]
;;;1265   
;;;1266     /* Check the parameters */
;;;1267     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1268     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1269   
;;;1270     /* Get the I2Cx peripheral base address */
;;;1271     i2cxbase = (uint32_t)I2Cx;
00000c  9200              STR      r2,[sp,#0]
;;;1272     
;;;1273     /* Read flag register index */
;;;1274     i2creg = I2C_FLAG >> 28;
00000e  0f0b              LSRS     r3,r1,#28
000010  9301              STR      r3,[sp,#4]
;;;1275     
;;;1276     /* Get bit[23:0] of the flag */
;;;1277     I2C_FLAG &= FLAG_MASK;
000012  f021417f          BIC      r1,r1,#0xff000000
;;;1278     
;;;1279     if(i2creg != 0)
000016  9b01              LDR      r3,[sp,#4]
000018  b11b              CBZ      r3,|L18.34|
;;;1280     {
;;;1281       /* Get the I2Cx SR1 register address */
;;;1282       i2cxbase += 0x14;
00001a  9b00              LDR      r3,[sp,#0]
00001c  3314              ADDS     r3,r3,#0x14
00001e  9300              STR      r3,[sp,#0]
000020  e003              B        |L18.42|
                  |L18.34|
;;;1283     }
;;;1284     else
;;;1285     {
;;;1286       /* Flag in I2Cx SR2 Register */
;;;1287       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
000022  0c09              LSRS     r1,r1,#16
;;;1288       /* Get the I2Cx SR2 register address */
;;;1289       i2cxbase += 0x18;
000024  9b00              LDR      r3,[sp,#0]
000026  3318              ADDS     r3,r3,#0x18
000028  9300              STR      r3,[sp,#0]
                  |L18.42|
;;;1290     }
;;;1291     
;;;1292     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00002a  9b00              LDR      r3,[sp,#0]
00002c  681b              LDR      r3,[r3,#0]
00002e  400b              ANDS     r3,r3,r1
000030  b10b              CBZ      r3,|L18.54|
;;;1293     {
;;;1294       /* I2C_FLAG is set */
;;;1295       bitstatus = SET;
000032  2001              MOVS     r0,#1
000034  e000              B        |L18.56|
                  |L18.54|
;;;1296     }
;;;1297     else
;;;1298     {
;;;1299       /* I2C_FLAG is reset */
;;;1300       bitstatus = RESET;
000036  2000              MOVS     r0,#0
                  |L18.56|
;;;1301     }
;;;1302     
;;;1303     /* Return the I2C_FLAG status */
;;;1304     return  bitstatus;
;;;1305   }
000038  bd0c              POP      {r2,r3,pc}
;;;1306   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1371     */
;;;1372   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1373   {
000002  4602              MOV      r2,r0
;;;1374     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1375     uint32_t enablestatus = 0;
000006  2300              MOVS     r3,#0
;;;1376   
;;;1377     /* Check the parameters */
;;;1378     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1379     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1380   
;;;1381     /* Check if the interrupt source is enabled or not */
;;;1382     enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
000008  8894              LDRH     r4,[r2,#4]
00000a  f00165e0          AND      r5,r1,#0x7000000
00000e  ea044315          AND      r3,r4,r5,LSR #16
;;;1383     
;;;1384     /* Get bit[23:0] of the flag */
;;;1385     I2C_IT &= FLAG_MASK;
000012  f021417f          BIC      r1,r1,#0xff000000
;;;1386   
;;;1387     /* Check the status of the specified I2C flag */
;;;1388     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000016  8a94              LDRH     r4,[r2,#0x14]
000018  400c              ANDS     r4,r4,r1
00001a  b114              CBZ      r4,|L19.34|
00001c  b10b              CBZ      r3,|L19.34|
;;;1389     {
;;;1390       /* I2C_IT is set */
;;;1391       bitstatus = SET;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L19.36|
                  |L19.34|
;;;1392     }
;;;1393     else
;;;1394     {
;;;1395       /* I2C_IT is reset */
;;;1396       bitstatus = RESET;
000022  2000              MOVS     r0,#0
                  |L19.36|
;;;1397     }
;;;1398     /* Return the I2C_IT status */
;;;1399     return  bitstatus;
;;;1400   }
000024  bd30              POP      {r4,r5,pc}
;;;1401   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1205     */
;;;1206   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;1207   {
000002  4601              MOV      r1,r0
;;;1208     uint32_t lastevent = 0;
000004  2000              MOVS     r0,#0
;;;1209     uint32_t flag1 = 0, flag2 = 0;
000006  2300              MOVS     r3,#0
000008  2200              MOVS     r2,#0
;;;1210   
;;;1211     /* Check the parameters */
;;;1212     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1213   
;;;1214     /* Read the I2Cx status register */
;;;1215     flag1 = I2Cx->SR1;
00000a  8a8b              LDRH     r3,[r1,#0x14]
;;;1216     flag2 = I2Cx->SR2;
00000c  8b0a              LDRH     r2,[r1,#0x18]
;;;1217     flag2 = flag2 << 16;
00000e  0412              LSLS     r2,r2,#16
;;;1218   
;;;1219     /* Get the last event value from I2C status register */
;;;1220     lastevent = (flag1 | flag2) & FLAG_MASK;
000010  ea430402          ORR      r4,r3,r2
000014  f024407f          BIC      r0,r4,#0xff000000
;;;1221   
;;;1222     /* Return status */
;;;1223     return lastevent;
;;;1224   }
000018  bd10              POP      {r4,pc}
;;;1225   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;876      */
;;;877    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;878    {
;;;879      /* Check the parameters */
;;;880      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;881      /* Return the selected I2C PEC value */
;;;882      return ((I2Cx->SR2) >> 8);
000002  8b08              LDRH     r0,[r1,#0x18]
000004  1200              ASRS     r0,r0,#8
;;;883    }
000006  4770              BX       lr
;;;884    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;1098     */
;;;1099   void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L22.10|
;;;1100   {
;;;1101     /* Check the parameters */
;;;1102     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1103     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1104     assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;1105     
;;;1106     if (NewState != DISABLE)
;;;1107     {
;;;1108       /* Enable the selected I2C interrupts */
;;;1109       I2Cx->CR2 |= I2C_IT;
000002  8883              LDRH     r3,[r0,#4]
000004  430b              ORRS     r3,r3,r1
000006  8083              STRH     r3,[r0,#4]
000008  e002              B        |L22.16|
                  |L22.10|
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       /* Disable the selected I2C interrupts */
;;;1114       I2Cx->CR2 &= (uint16_t)~I2C_IT;
00000a  8883              LDRH     r3,[r0,#4]
00000c  438b              BICS     r3,r3,r1
00000e  8083              STRH     r3,[r0,#4]
                  |L22.16|
;;;1115     }
;;;1116   }
000010  4770              BX       lr
;;;1117   
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;179      */
;;;180    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;181    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;182      uint16_t tmpreg = 0, freqrange = 0;
000008  2600              MOVS     r6,#0
00000a  46b1              MOV      r9,r6
;;;183      uint16_t result = 0x04;
00000c  2704              MOVS     r7,#4
;;;184      uint32_t pclk1 = 8000000;
00000e  f8df80cc          LDR      r8,|L23.220|
;;;185      RCC_ClocksTypeDef  rcc_clocks;
;;;186      /* Check the parameters */
;;;187      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;188      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;189      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;190      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;191      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;192      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;193      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;194    
;;;195    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;196      /* Get the I2Cx CR2 value */
;;;197      tmpreg = I2Cx->CR2;
000012  88a6              LDRH     r6,[r4,#4]
;;;198      /* Clear frequency FREQ[5:0] bits */
;;;199      tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
000014  f64f70c0          MOV      r0,#0xffc0
000018  4006              ANDS     r6,r6,r0
;;;200      /* Get pclk1 frequency value */
;;;201      RCC_GetClocksFreq(&rcc_clocks);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       RCC_GetClocksFreq
;;;202      pclk1 = rcc_clocks.PCLK1_Frequency;
000020  f8dd8008          LDR      r8,[sp,#8]
;;;203      /* Set frequency bits depending on pclk1 value */
;;;204      freqrange = (uint16_t)(pclk1 / 1000000);
000024  482e              LDR      r0,|L23.224|
000026  fbb8f0f0          UDIV     r0,r8,r0
00002a  fa1ff980          UXTH     r9,r0
;;;205      tmpreg |= freqrange;
00002e  ea460609          ORR      r6,r6,r9
;;;206      /* Write to I2Cx CR2 */
;;;207      I2Cx->CR2 = tmpreg;
000032  80a6              STRH     r6,[r4,#4]
;;;208    
;;;209    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;210      /* Disable the selected I2C peripheral to configure TRISE */
;;;211      I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000034  8820              LDRH     r0,[r4,#0]
000036  f64f71fe          MOV      r1,#0xfffe
00003a  4008              ANDS     r0,r0,r1
00003c  8020              STRH     r0,[r4,#0]
;;;212      /* Reset tmpreg value */
;;;213      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;214      tmpreg = 0;
00003e  2600              MOVS     r6,#0
;;;215    
;;;216      /* Configure speed in standard mode */
;;;217      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000040  4928              LDR      r1,|L23.228|
000042  6828              LDR      r0,[r5,#0]
000044  4288              CMP      r0,r1
000046  d80c              BHI      |L23.98|
;;;218      {
;;;219        /* Standard mode speed calculate */
;;;220        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000048  6828              LDR      r0,[r5,#0]
00004a  0040              LSLS     r0,r0,#1
00004c  fbb8f0f0          UDIV     r0,r8,r0
000050  b287              UXTH     r7,r0
;;;221        /* Test if CCR value is under 0x4*/
;;;222        if (result < 0x04)
000052  2f04              CMP      r7,#4
000054  da00              BGE      |L23.88|
;;;223        {
;;;224          /* Set minimum allowed value */
;;;225          result = 0x04;  
000056  2704              MOVS     r7,#4
                  |L23.88|
;;;226        }
;;;227        /* Set speed value for standard mode */
;;;228        tmpreg |= result;	  
000058  433e              ORRS     r6,r6,r7
;;;229        /* Set Maximum Rise Time for standard mode */
;;;230        I2Cx->TRISE = freqrange + 1; 
00005a  f1090001          ADD      r0,r9,#1
00005e  8420              STRH     r0,[r4,#0x20]
000060  e027              B        |L23.178|
                  |L23.98|
;;;231      }
;;;232      /* Configure speed in fast mode */
;;;233      /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
;;;234         input clock) must be a multiple of 10 MHz */
;;;235      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;236      {
;;;237        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000062  88e8              LDRH     r0,[r5,#6]
000064  f64b71ff          MOV      r1,#0xbfff
000068  4288              CMP      r0,r1
00006a  d106              BNE      |L23.122|
;;;238        {
;;;239          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;240          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
00006c  6828              LDR      r0,[r5,#0]
00006e  eb000040          ADD      r0,r0,r0,LSL #1
000072  fbb8f0f0          UDIV     r0,r8,r0
000076  b287              UXTH     r7,r0
000078  e009              B        |L23.142|
                  |L23.122|
;;;241        }
;;;242        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;243        {
;;;244          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;245          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
00007a  6828              LDR      r0,[r5,#0]
00007c  eb0001c0          ADD      r1,r0,r0,LSL #3
000080  eb011000          ADD      r0,r1,r0,LSL #4
000084  fbb8f0f0          UDIV     r0,r8,r0
000088  b287              UXTH     r7,r0
;;;246          /* Set DUTY bit */
;;;247          result |= I2C_DutyCycle_16_9;
00008a  f4474780          ORR      r7,r7,#0x4000
                  |L23.142|
;;;248        }
;;;249    
;;;250        /* Test if CCR value is under 0x1*/
;;;251        if ((result & I2C_CCR_CCR) == 0)
00008e  f3c7000b          UBFX     r0,r7,#0,#12
000092  b908              CBNZ     r0,|L23.152|
;;;252        {
;;;253          /* Set minimum allowed value */
;;;254          result |= (uint16_t)0x0001;  
000094  f0470701          ORR      r7,r7,#1
                  |L23.152|
;;;255        }
;;;256        /* Set speed value and set F/S bit for fast mode */
;;;257        tmpreg |= (uint16_t)(result | I2C_CCR_FS);
000098  f4474000          ORR      r0,r7,#0x8000
00009c  4306              ORRS     r6,r6,r0
;;;258        /* Set Maximum Rise Time for fast mode */
;;;259        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
00009e  f44f7096          MOV      r0,#0x12c
0000a2  fb09f000          MUL      r0,r9,r0
0000a6  f44f717a          MOV      r1,#0x3e8
0000aa  fb90f0f1          SDIV     r0,r0,r1
0000ae  1c40              ADDS     r0,r0,#1
0000b0  8420              STRH     r0,[r4,#0x20]
                  |L23.178|
;;;260      }
;;;261    
;;;262      /* Write to I2Cx CCR */
;;;263      I2Cx->CCR = tmpreg;
0000b2  83a6              STRH     r6,[r4,#0x1c]
;;;264      /* Enable the selected I2C peripheral */
;;;265      I2Cx->CR1 |= I2C_CR1_PE;
0000b4  8820              LDRH     r0,[r4,#0]
0000b6  f0400001          ORR      r0,r0,#1
0000ba  8020              STRH     r0,[r4,#0]
;;;266    
;;;267    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;268      /* Get the I2Cx CR1 value */
;;;269      tmpreg = I2Cx->CR1;
0000bc  8826              LDRH     r6,[r4,#0]
;;;270      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;271      tmpreg &= CR1_CLEAR_MASK;
0000be  f64f30f5          MOV      r0,#0xfbf5
0000c2  4006              ANDS     r6,r6,r0
;;;272      /* Configure I2Cx: mode and acknowledgement */
;;;273      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;274      /* Set ACK bit according to I2C_Ack value */
;;;275      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000c4  88a8              LDRH     r0,[r5,#4]
0000c6  8969              LDRH     r1,[r5,#0xa]
0000c8  4308              ORRS     r0,r0,r1
0000ca  4306              ORRS     r6,r6,r0
;;;276      /* Write to I2Cx CR1 */
;;;277      I2Cx->CR1 = tmpreg;
0000cc  8026              STRH     r6,[r4,#0]
;;;278    
;;;279    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;280      /* Set I2Cx Own Address1 and acknowledged address */
;;;281      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000ce  89a8              LDRH     r0,[r5,#0xc]
0000d0  8929              LDRH     r1,[r5,#8]
0000d2  4308              ORRS     r0,r0,r1
0000d4  8120              STRH     r0,[r4,#8]
;;;282    }
0000d6  e8bd87ff          POP      {r0-r10,pc}
;;;283    
                          ENDP

0000da  0000              DCW      0x0000
                  |L23.220|
                          DCD      0x007a1200
                  |L23.224|
                          DCD      0x000f4240
                  |L23.228|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;665      */
;;;666    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;667    {
;;;668      /* Check the parameters */
;;;669      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;670      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;671      
;;;672      /* Check the input parameter */
;;;673      if (I2C_NACKPosition == I2C_NACKPosition_Next)
000004  d104              BNE      |L24.16|
;;;674      {
;;;675        /* Next byte in shift register is the last received byte */
;;;676        I2Cx->CR1 |= I2C_NACKPosition_Next;
000006  8802              LDRH     r2,[r0,#0]
000008  f4426200          ORR      r2,r2,#0x800
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L24.26|
                  |L24.16|
;;;677      }
;;;678      else
;;;679      {
;;;680        /* Current byte in shift register is the last received byte */
;;;681        I2Cx->CR1 &= I2C_NACKPosition_Current;
000010  8802              LDRH     r2,[r0,#0]
000012  f24f73ff          MOV      r3,#0xf7ff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L24.26|
;;;682      }
;;;683    }
00001a  4770              BX       lr
;;;684    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;500      */
;;;501    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  460a              MOV      r2,r1
;;;502    {
;;;503      uint16_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;504    
;;;505      /* Check the parameters */
;;;506      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;507    
;;;508      /* Get the old register value */
;;;509      tmpreg = I2Cx->OAR2;
000004  8981              LDRH     r1,[r0,#0xc]
;;;510    
;;;511      /* Reset I2Cx Own address2 bit [7:1] */
;;;512      tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
000006  f64f7301          MOV      r3,#0xff01
00000a  4019              ANDS     r1,r1,r3
;;;513    
;;;514      /* Set I2Cx Own address2 */
;;;515      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
00000c  f00203fe          AND      r3,r2,#0xfe
000010  4319              ORRS     r1,r1,r3
;;;516    
;;;517      /* Store the new register value */
;;;518      I2Cx->OAR2 = tmpreg;
000012  8181              STRH     r1,[r0,#0xc]
;;;519    }
000014  4770              BX       lr
;;;520    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;830      */
;;;831    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;832    {
;;;833      /* Check the parameters */
;;;834      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;835      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;836      if (I2C_PECPosition == I2C_PECPosition_Next)
000004  d104              BNE      |L26.16|
;;;837      {
;;;838        /* Next byte in shift register is PEC */
;;;839        I2Cx->CR1 |= I2C_PECPosition_Next;
000006  8802              LDRH     r2,[r0,#0]
000008  f4426200          ORR      r2,r2,#0x800
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L26.26|
                  |L26.16|
;;;840      }
;;;841      else
;;;842      {
;;;843        /* Current byte in shift register is PEC */
;;;844        I2Cx->CR1 &= I2C_PECPosition_Current;
000010  8802              LDRH     r2,[r0,#0]
000012  f24f73ff          MOV      r3,#0xf7ff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L26.26|
;;;845      }
;;;846    }
00001a  4770              BX       lr
;;;847    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;1071     */
;;;1072   uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b508              PUSH     {r3,lr}
;;;1073   {
000002  4602              MOV      r2,r0
;;;1074     __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1075   
;;;1076     /* Check the parameters */
;;;1077     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1078     assert_param(IS_I2C_REGISTER(I2C_Register));
;;;1079   
;;;1080     tmp = (uint32_t) I2Cx;
000008  9200              STR      r2,[sp,#0]
;;;1081     tmp += I2C_Register;
00000a  9800              LDR      r0,[sp,#0]
00000c  4408              ADD      r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;1082   
;;;1083     /* Return the selected register value */
;;;1084     return (*(__IO uint16_t *) tmp);
000010  9800              LDR      r0,[sp,#0]
000012  8800              LDRH     r0,[r0,#0]
;;;1085   }
000014  bd08              POP      {r3,pc}
;;;1086   
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;768      */
;;;769    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;770    {
;;;771      /* Check the parameters */
;;;772      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;773      /* Return the data in the DR register */
;;;774      return (uint8_t)I2Cx->DR;
000002  8a08              LDRH     r0,[r1,#0x10]
000004  b2c0              UXTB     r0,r0
;;;775    }
000006  4770              BX       lr
;;;776    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;693      */
;;;694    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;695    {
;;;696      /* Check the parameters */
;;;697      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;698      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;699      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000004  d104              BNE      |L29.16|
;;;700      {
;;;701        /* Drive the SMBusAlert pin Low */
;;;702        I2Cx->CR1 |= I2C_SMBusAlert_Low;
000006  8802              LDRH     r2,[r0,#0]
000008  f4425200          ORR      r2,r2,#0x2000
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L29.26|
                  |L29.16|
;;;703      }
;;;704      else
;;;705      {
;;;706        /* Drive the SMBusAlert pin High  */
;;;707        I2Cx->CR1 &= I2C_SMBusAlert_High;
000010  8802              LDRH     r2,[r0,#0]
000012  f64d73ff          MOV      r3,#0xdfff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L29.26|
;;;708      }
;;;709    }
00001a  4770              BX       lr
;;;710    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;450      */
;;;451    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L30.8|
;;;452    {
;;;453      /* Check the parameters */
;;;454      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;455      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;456      /* Test on the direction to set/reset the read/write bit */
;;;457      if (I2C_Direction != I2C_Direction_Transmitter)
;;;458      {
;;;459        /* Set the address bit0 for read */
;;;460        Address |= I2C_OAR1_ADD0;
000002  f0410101          ORR      r1,r1,#1
000006  e001              B        |L30.12|
                  |L30.8|
;;;461      }
;;;462      else
;;;463      {
;;;464        /* Reset the address bit0 for write */
;;;465        Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
000008  f00101fe          AND      r1,r1,#0xfe
                  |L30.12|
;;;466      }
;;;467      /* Send the address */
;;;468      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;469    }
00000e  4770              BX       lr
;;;470    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;755      */
;;;756    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;757    {
;;;758      /* Check the parameters */
;;;759      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;760      /* Write in the DR register the data to be sent */
;;;761      I2Cx->DR = Data;
;;;762    }
000002  4770              BX       lr
;;;763    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;577      */
;;;578    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L32.12|
;;;579    {
;;;580      /* Check the parameters */
;;;581      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;582      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;583      if (NewState != DISABLE)
;;;584      {
;;;585        /* Peripheral under reset */
;;;586        I2Cx->CR1 |= I2C_CR1_SWRST;
000002  8802              LDRH     r2,[r0,#0]
000004  f4424200          ORR      r2,r2,#0x8000
000008  8002              STRH     r2,[r0,#0]
00000a  e003              B        |L32.20|
                  |L32.12|
;;;587      }
;;;588      else
;;;589      {
;;;590        /* Peripheral not under reset */
;;;591        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f3c2020e          UBFX     r2,r2,#0,#15
000012  8002              STRH     r2,[r0,#0]
                  |L32.20|
;;;592      }
;;;593    }
000014  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;601      */
;;;602    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b921              CBNZ     r1,|L33.12|
;;;603    {
;;;604      /* Check the parameters */
;;;605      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;606      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;607      if (NewState == DISABLE)
;;;608      {
;;;609        /* Enable the selected I2C Clock stretching */
;;;610        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L33.22|
                  |L33.12|
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Disable the selected I2C Clock stretching */
;;;615        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L33.22|
;;;616      }
;;;617    }
000016  4770              BX       lr
;;;618    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;288      */
;;;289    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;290    {
;;;291    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;292      /* initialize the I2C_ClockSpeed member */
;;;293      I2C_InitStruct->I2C_ClockSpeed = 5000;
000004  6001              STR      r1,[r0,#0]
;;;294      /* Initialize the I2C_Mode member */
;;;295      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;296      /* Initialize the I2C_DutyCycle member */
;;;297      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b71ff          MOV      r1,#0xbfff
00000e  80c1              STRH     r1,[r0,#6]
;;;298      /* Initialize the I2C_OwnAddress1 member */
;;;299      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  2100              MOVS     r1,#0
000012  8101              STRH     r1,[r0,#8]
;;;300      /* Initialize the I2C_Ack member */
;;;301      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000014  8141              STRH     r1,[r0,#0xa]
;;;302      /* Initialize the I2C_AcknowledgedAddress member */
;;;303      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000016  f44f4180          MOV      r1,#0x4000
00001a  8181              STRH     r1,[r0,#0xc]
;;;304    }
00001c  4770              BX       lr
;;;305    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;799      */
;;;800    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L35.12|
;;;801    {
;;;802      /* Check the parameters */
;;;803      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;804      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;805      if (NewState != DISABLE)
;;;806      {
;;;807        /* Enable the selected I2C PEC transmission */
;;;808        I2Cx->CR1 |= I2C_CR1_PEC;
000002  8802              LDRH     r2,[r0,#0]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L35.22|
                  |L35.12|
;;;809      }
;;;810      else
;;;811      {
;;;812        /* Disable the selected I2C PEC transmission */
;;;813        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L35.22|
;;;814      }
;;;815    }
000016  4770              BX       lr
;;;816    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\src\\stm32f4xx_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___15_stm32f4xx_i2c_c_7174d409____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REVSH|
#line 153
|__asm___15_stm32f4xx_i2c_c_7174d409____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____RRX|
#line 328
|__asm___15_stm32f4xx_i2c_c_7174d409____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
