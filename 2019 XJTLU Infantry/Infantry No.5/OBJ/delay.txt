; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\delay.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\delay.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\FWLIB\inc -I..\BSP -I..\HAL -I..\TASK -I..\DSP\Include -I..\AHRS -IC:\Users\15719\Desktop\Ambition-f427-步兵3.8（二段加速)\USER\RTE -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0 -IC:\Keil_v5\ARM\CMSIS\Include -IE:\MDK514\Keil\STM32F4xx_DFP\2.13.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F427xx -DSTM32F427X -DUSE_STDPERIPH_DRIVER -D__FPU_USED -D__FPU_PRESENT -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=..\obj\delay.crf ..\SYSTEM\delay\delay.c]
                          THUMB

                          AREA ||i.delay_init||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;114    //SYSCLK:系统时钟频率
;;;115    void delay_init(u8 SYSCLK)
000000  b510              PUSH     {r4,lr}
;;;116    {
000002  4604              MOV      r4,r0
;;;117    #if SYSTEM_SUPPORT_OS 						//如果需要支持OS.
;;;118    	u32 reload;
;;;119    #endif
;;;120     	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); 
000004  f06f0004          MVN      r0,#4
000008  f7fffffe          BL       SysTick_CLKSourceConfig
;;;121    	fac_us=SYSCLK/8;						//不论是否使用OS,fac_us都需要使用
00000c  17e1              ASRS     r1,r4,#31
00000e  eb047151          ADD      r1,r4,r1,LSR #29
000012  f3c101c7          UBFX     r1,r1,#3,#8
000016  4a07              LDR      r2,|L1.52|
000018  7011              STRB     r1,[r2,#0]
;;;122    #if SYSTEM_SUPPORT_OS 						//如果需要支持OS.
;;;123    	reload=SYSCLK/8;						//每秒钟的计数次数 单位为M	   
;;;124    	reload*=1000000/delay_ostickspersec;	//根据delay_ostickspersec设定溢出时间
;;;125    											//reload为24位寄存器,最大值:16777216,在168M下,约合0.7989s左右	
;;;126    	fac_ms=1000/delay_ostickspersec;		//代表OS可以延时的最少单位	   
;;;127    	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;   	//开启SYSTICK中断
;;;128    	SysTick->LOAD=reload; 					//每1/delay_ostickspersec秒中断一次	
;;;129    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk; 	//开启SYSTICK    
;;;130    #else
;;;131    	fac_ms=(u16)fac_us*1000;				//非OS下,代表每个ms需要的systick时钟数   
00001a  4610              MOV      r0,r2
00001c  7800              LDRB     r0,[r0,#0]  ; fac_us
00001e  eb000140          ADD      r1,r0,r0,LSL #1
000022  ebc110c0          RSB      r0,r1,r0,LSL #7
000026  f64f71ff          MOV      r1,#0xffff
00002a  ea0100c0          AND      r0,r1,r0,LSL #3
00002e  4902              LDR      r1,|L1.56|
000030  8008              STRH     r0,[r1,#0]
;;;132    #endif
;;;133    }								    
000032  bd10              POP      {r4,pc}
;;;134    
                          ENDP

                  |L1.52|
                          DCD      fac_us
                  |L1.56|
                          DCD      fac_ms

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=1

                  delay_ms PROC
;;;212    //nms:0~65535
;;;213    void delay_ms(u16 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;214    {	 	 
000002  4604              MOV      r4,r0
;;;215    	u8 repeat=nms/540;						//这里用540,是考虑到某些客户可能超频使用,
000004  f44f7007          MOV      r0,#0x21c
000008  fb94f0f0          SDIV     r0,r4,r0
00000c  b2c6              UXTB     r6,r0
;;;216    											//比如超频到248M的时候,delay_xms最大只能延时541ms左右了
;;;217    	u16 remain=nms%540;
00000e  f44f7007          MOV      r0,#0x21c
000012  fb94f1f0          SDIV     r1,r4,r0
000016  fb004011          MLS      r0,r0,r1,r4
00001a  b285              UXTH     r5,r0
;;;218    	while(repeat)
00001c  e005              B        |L2.42|
                  |L2.30|
;;;219    	{
;;;220    		delay_xms(540);
00001e  f44f7007          MOV      r0,#0x21c
000022  f7fffffe          BL       delay_xms
;;;221    		repeat--;
000026  1e70              SUBS     r0,r6,#1
000028  b2c6              UXTB     r6,r0
                  |L2.42|
00002a  2e00              CMP      r6,#0                 ;218
00002c  d1f7              BNE      |L2.30|
;;;222    	}
;;;223    	if(remain)delay_xms(remain);
00002e  b115              CBZ      r5,|L2.54|
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       delay_xms
                  |L2.54|
;;;224    } 
000036  bd70              POP      {r4-r6,pc}
;;;225    #endif
                          ENDP


                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;178    //注意:nus的值,不要大于798915us(最大值即2^24/fac_us@fac_us=21)
;;;179    void delay_us(u32 nus)
000000  4601              MOV      r1,r0
;;;180    {		
;;;181    	u32 temp;	    	 
;;;182    	SysTick->LOAD=nus*fac_us; 				//时间加载	  		 
000002  4a11              LDR      r2,|L3.72|
000004  7812              LDRB     r2,[r2,#0]  ; fac_us
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;183    	SysTick->VAL=0x00;        				//清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;184    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ; //开始倒数 	 
000012  461a              MOV      r2,r3
000014  6912              LDR      r2,[r2,#0x10]
000016  f0420201          ORR      r2,r2,#1
00001a  611a              STR      r2,[r3,#0x10]
;;;185    	do
00001c  bf00              NOP      
                  |L3.30|
;;;186    	{
;;;187    		temp=SysTick->CTRL;
00001e  f04f22e0          MOV      r2,#0xe000e000
000022  6910              LDR      r0,[r2,#0x10]
;;;188    	}while((temp&0x01)&&!(temp&(1<<16)));	//等待时间到达   
000024  f0000201          AND      r2,r0,#1
000028  b11a              CBZ      r2,|L3.50|
00002a  f4003280          AND      r2,r0,#0x10000
00002e  2a00              CMP      r2,#0
000030  d0f5              BEQ      |L3.30|
                  |L3.50|
;;;189    	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk; //关闭计数器
000032  f04f22e0          MOV      r2,#0xe000e000
000036  6912              LDR      r2,[r2,#0x10]
000038  f0220201          BIC      r2,r2,#1
00003c  f04f23e0          MOV      r3,#0xe000e000
000040  611a              STR      r2,[r3,#0x10]
;;;190    	SysTick->VAL =0X00;       				//清空计数器 
000042  2200              MOVS     r2,#0
000044  619a              STR      r2,[r3,#0x18]
;;;191    }
000046  4770              BX       lr
;;;192    //延时nms
                          ENDP

                  |L3.72|
                          DCD      fac_us

                          AREA ||i.delay_xms||, CODE, READONLY, ALIGN=2

                  delay_xms PROC
;;;197    //对168M条件下,nms<=798ms 
;;;198    void delay_xms(u16 nms)
000000  4601              MOV      r1,r0
;;;199    {	 		  	  
;;;200    	u32 temp;		   
;;;201    	SysTick->LOAD=(u32)nms*fac_ms;			//时间加载(SysTick->LOAD为24bit)
000002  4a11              LDR      r2,|L4.72|
000004  8812              LDRH     r2,[r2,#0]  ; fac_ms
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;202    	SysTick->VAL =0x00;           			//清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;203    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;          //开始倒数 
000012  461a              MOV      r2,r3
000014  6912              LDR      r2,[r2,#0x10]
000016  f0420201          ORR      r2,r2,#1
00001a  611a              STR      r2,[r3,#0x10]
;;;204    	do
00001c  bf00              NOP      
                  |L4.30|
;;;205    	{
;;;206    		temp=SysTick->CTRL;
00001e  f04f22e0          MOV      r2,#0xe000e000
000022  6910              LDR      r0,[r2,#0x10]
;;;207    	}while((temp&0x01)&&!(temp&(1<<16)));	//等待时间到达   
000024  f0000201          AND      r2,r0,#1
000028  b11a              CBZ      r2,|L4.50|
00002a  f4003280          AND      r2,r0,#0x10000
00002e  2a00              CMP      r2,#0
000030  d0f5              BEQ      |L4.30|
                  |L4.50|
;;;208    	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;       //关闭计数器
000032  f04f22e0          MOV      r2,#0xe000e000
000036  6912              LDR      r2,[r2,#0x10]
000038  f0220201          BIC      r2,r2,#1
00003c  f04f23e0          MOV      r3,#0xe000e000
000040  611a              STR      r2,[r3,#0x10]
;;;209    	SysTick->VAL =0X00;     		  		//清空计数器	  	    
000042  2200              MOVS     r2,#0
000044  619a              STR      r2,[r3,#0x18]
;;;210    } 
000046  4770              BX       lr
;;;211    //延时nms 
                          ENDP

                  |L4.72|
                          DCD      fac_ms

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\delay\\delay.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_f6a9c549____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___7_delay_c_f6a9c549____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_f6a9c549____REVSH|
#line 153
|__asm___7_delay_c_f6a9c549____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_f6a9c549____RRX|
#line 328
|__asm___7_delay_c_f6a9c549____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
